# イテレータ

ループについて話しよう。

Rust's `for`ループを覚え`for`ますか？
ここに例があります：

```rust
for x in 0..10 {
    println!("{}", x);
}
```

あなたがRustをもっと知るようになったので、我々はこれがどのように機能するかについて詳しく話すことができます。
範囲（`0..10`）は「反復子」です。
イテレータは、`.next()`メソッドを繰り返し呼び出すことができるものであり、一連の処理を行います。

`0..10`ような2つの点がある範囲は、左に（0から始まるように）含まれ、右にのみ（したがって9で終わります）です。
数学者は "[0、10]"と書く。

このような：

```rust
let mut range = 0..10;

loop {
    match range.next() {
        Some(x) => {
            println!("{}", x);
        },
        None => { break }
    }
}
```

我々は反復子である範囲に対して可変バインディングを行います。
次に内側の`match` `loop`。
この`match`は、`range.next()`結果に使用され、イテレータの次の値への参照を与えます。
`next`、 `Option<i32>`返します。この場合、値がある場合は`Some(i32)`、なくなると`None`になります。
私たちが出た場合`Some(i32)`、我々はそれをプリントアウトして、我々は取得しない場合は`None`、我々は`break`ループの外に。

このコードサンプルは、基本的に`for`ループバージョンと同じです。
`for`ループは、この`loop` / `match` / `break`構造を書く便利な方法です。

`for`ループはイテレータを使用する唯一のものではありません。
独自のイテレータを書くには、`Iterator`特性を実装する必要があります。
これを行うのはこのガイドの範囲外ですが、Rustはさまざまなタスクを達成するための数多くの有用なイテレータを提供しています。
しかし、まず、範囲の限界についてのいくつかの注意。

範囲は非常に原始的であり、我々はしばしばより良い選択肢を使用することができます。
以下のRustアンチパターンを考えてみましょう。範囲を使用してCスタイル`for`ループをエミュレート`for`ます。
ベクトルの内容を繰り返し処理する必要があるとしましょう。
あなたはこれを書くように誘惑されるかもしれません：

```rust
let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!("{}", nums[i]);
}
```

これは、実際のイテレータを使用するよりも厳密に悪いことです。
ベクトルを直接反復処理することができますので、これを書いてください：

```rust
let nums = vec![1, 2, 3];

for num in &nums {
    println!("{}", num);
}
```

これには2つの理由があります。
まず、これは我々が意味するものをより直接的に表しています。
インデックス全体を反復処理するのではなく、ベクトル全体を反復処理し、ベクトルをインデックス化します。
第2に、このバージョンがより効率的です。最初のバージョンでは、インデックス`nums[i]`使用しているため、余分な境界チェックが行われます。
しかし、イテレータでベクトルの各要素への参照を順番に生成するので、2番目の例では境界チェックはありません。
これはイテレータでは非常に一般的です。不要な境界チェックを無視できますが、まだ安全であることはわかります。

`println!`がどのように動作するかによって100％明確ではない別の詳細がここにあります。
`num`は実際には`&i32`型です。
つまり、それはへの参照です`i32`、ない`i32`そのもの。
`println!`は私たちの参照解除を処理するので、表示されません。
このコードもうまくいきます：

```rust
let nums = vec![1, 2, 3];

for num in &nums {
    println!("{}", *num);
}
```

今我々は`num`明示的に逆参照している。
なぜ`&nums`は私たちに参照を与えるのですか？
まず、`&`。
第二に、それがデータそのものを私たちに与えたならば、データのコピーを作成して私たちにそれを与えることを含む所有者でなければなりません。
参考文献では、データへの参照のみを借用しているため、参照を渡すだけで、移動する必要はありません。

それで、範囲がしばしばあなたが望むものではないことを確立したので、代わりにあなたがしたいことについて話しましょう。

ここでは、*イテレーター*、 *イテレーター・アダプター*、および*コンシューマーの* 3つのクラスに大別できます。
いくつかの定義があります：

* *イテレータ*は一連の値を*返し*ます。
* *イテレータアダプタ*はイテレータ上で動作し、異なる出力シーケンスを持つ新しいイテレータを生成します。
* *消費者*はイテレータ上で動作し、最終的な値セットを生成します。

すでにイテレータ、範囲を見てきたので、最初に消費者について話しましょう。

## 消費者

*消費者*はイテレータで動作し、ある種の値や値を返します。
最も一般的なコンシューマーは`collect()`です。
このコードはあまりコンパイルされませんが、意図を示しています：

```rust,ignore
let one_to_one_hundred = (1..101).collect();
```

ご覧のとおり、イテレータの`collect()`を呼び出します。
`collect()`はイテレータが与える多くの値をとり、結果のコレクションを返します。
だから、なぜこれはコンパイルされませんか？
錆は、あなたが収集したいもののタイプを決定することができないので、それを知らせる必要があります。
コンパイルするバージョンは次のとおりです。

```rust
let one_to_one_hundred = (1..101).collect::<Vec<i32>>();
```

覚えていれば、[`::<>`構文](generics.html#resolving-ambiguities)は、コンパイラに整数のベクトルが必要なことを伝えるヒントを与えることができます。
しかし、必ずしも全体の型を使う必要はありません。
`_`を使用すると、部分的なヒントを提供できます：

```rust
let one_to_one_hundred = (1..101).collect::<Vec<_>>();
```

これは「 `Vec<T>`に集めてください。しかし、`T`が私のためにあると推測してください」と言います。
`_`は、このため「タイププレースホルダ」と呼ばれることがあります。

`collect()`は最も一般的な消費者ですが、他にもあります。
`find()`は1つです：

```rust
let greater_than_forty_two = (0..100)
                             .find(|x| *x > 42);

match greater_than_forty_two {
    Some(_) => println!("Found a match!"),
    None => println!("No match found :("),
}
```

`find`はクロージャ`find`とり、イテレータの各要素への参照で動作します。
この閉鎖は返し`true`要素は、私たちが探している要素であり、そして場合`false`そう。
`find`は、指定された述語を満たす最初の要素を返します。
一致する要素が`find`ない可能性があるため、`find`は要素自体ではなく`Option` `find`返します。

もう一つの重要な消費者は`fold`です。
以下はその様子です：

```rust
let sum = (1..4).fold(0, |sum, x| sum + x);
```

`fold()`は`fold(base, |accumulator, element| ...)`ようなコンシューマ`fold(base, |accumulator, element| ...)`。
これには2つの引数があります。最初の要素は*ベース*と呼ばれる要素です。
2つ目はクロージャーで、2つの引数をとります。最初は*アキュムレータ*、2つ目は*要素*です。
各反復で、クロージャが呼び出され、結果が次の反復でのアキュムレータの値になります。
最初の反復では、ベースにアキュムレータの値が割り当てられます。

さて、それは少し混乱しています。
このイテレータでこれらのすべての値を調べてみましょう：

|<!--base |-->ベース|<!--accumulator |-->アキュムレータ|<!--element |-->要素|<!--closure result |-->閉鎖の結果|
|<!--------|-------------|---------|----------------|-->------| -------------| ---------| ----------------|
|<!--0 |-->0 |<!--0 |-->0 |<!--1 |-->1 |<!--1 |-->1 |
|<!--0 |-->0 |<!--1 |-->1 |<!--2 |-->2 |<!--3 |-->3 |
|<!--0 |-->0 |<!--3 |-->3 |<!--3 |-->3 |<!--6 |-->6 |

`fold()`は次の引数で呼び出されました。

```rust
# (1..4)
.fold(0, |sum, x| sum + x);
```

したがって、`0`はベース、`sum`はアキュムレータ、`x`は要素です。
最初の反復では、`sum`を`0`に設定し、`x`は`nums`、 `1`最初の要素です。
次に、`sum`と`x`を`sum`、 `0 + 1 = 1`ます。
第2の反復で、その値は、我々のアキュムレータとなる`sum`、及び要素は、アレイの第二の要素である`2`。
`1 + 2 = 3`となるので、最後の反復のアキュムレータの値になります。
その反復では、`x`は最後の要素`3`と`3 + 3 = 6`。これは最終的な結果です。
`1 + 2 + 3 = 6`となり、これが結果です。

ホウ
`fold`あなたはそれを参照してください最初の数回少し奇妙なことができますが、それはクリックすると、あなたはあらゆる場所にそれを使用することができます。
あなたが物事のリストを持っていて、あなたが一つの結果を望む時はいつでも、`fold`は適切です。

消費者は、私たちがまだ話していないイテレータのもう一つの特性、すなわち怠惰のために重要です。
イテレーターについてもう少し詳しく説明しましょう。消費者がなぜ重要であるかを理解してください。

## イテレータ

前にも述べたように、イテレータは`.next()`メソッドを繰り返し呼び出すことができ、一連の処理を行います。
メソッドを呼び出す必要があるため、イテレータは*遅延*していて、すべての値を前もって生成することはできません。
たとえば、このコードでは、実際には数字`1-99`が生成されるのではなく、単にシーケンスを表す値が作成されます。

```rust
let nums = 1..100;
```

範囲で何もしなかったので、シーケンスを生成しませんでした。
消費者を追加しましょう：

```rust
let nums = (1..100).collect::<Vec<i32>>();
```

さて、`collect()`は、その範囲にいくつかの数値を与える必要があるので、シーケンスを生成する作業を行います。

範囲は、2つの基本的な反復子のうちの1つです。
もう一つは`iter()`です。
`iter()`は、ベクトルを順番に各要素を与える単純なイテレータに変えることができます：

```rust
let nums = vec![1, 2, 3];

for num in nums.iter() {
   println!("{}", num);
}
```

これらの2つの基本的なイテレータは、あなたにうまく役立つはずです。
無限大を含むいくつかの高度なイテレータがあります。

iteratorsについては十分です。
イテレーターアダプターはイテレーターに関して最後に私たちが話す必要がある概念です。
それに行きましょう！

## イテレータアダプタ

*イテレータアダプタ*はイテレータを受け取り、それを何らかの形で変更して、新しいイテレータを生成します。
最も簡単なものは`map`と呼ばれ`map`：

```rust,ignore
(1..100).map(|x| x + 1);
```

`map`は別のイテレーターで呼び出され、新しいイテレーターを生成します。ここで、各エレメント参照は、呼び出された引数として与えられたクロージャーを持ちます。
これで`2-100`の数字が得られます。
よくほとんど！
この例をコンパイルすると、警告が表示されます。

```text
warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

怠惰が再び襲う！
その閉鎖は決して実行されません。
この例では数値は表示されません。

```rust,ignore
(1..100).map(|x| println!("{}", x));
```

副作用のために反復子でクロージャを実行しようとしている場合は`for`代わりに`for`を使用`for`ます。

興味深いイテレーターアダプターがたくさんあります。
`take(n)`は、元のイテレータの次の`n`要素`n`イテレータを返します。
無限のイテレータで試してみましょう：

```rust
for i in (1..).take(5) {
    println!("{}", i);
}
```

これは印刷されます

```text
1
2
3
4
5
```

`filter()`は、引数としてクロージャをとるアダプタです。
このクロージャは`true`または`false`返し`true`。
新しい反復子`filter()`は、クロージャが`true`を返す要素のみを生成します。

```rust
for i in (1..100).filter(|&x| x % 2 == 0) {
    println!("{}", i);
}
```

これは、1と100の間のすべての偶数を印刷します。
（とは異なり、なお`map`に渡さ閉鎖`filter`代わり素子自体の要素への参照を渡される。ここで、フィルタ述語が使用`&x`整数を抽出するパターンをそれが返すためのフィルタ閉鎖基準を渡される`true`又は要素の代わりに`false`使用するため、`filter`実装は、新しく構築されたイテレータに要素を入れるために所有権を保持する必要があります。

3つの要素を1つにまとめることができます。イテレータから始め、数回それを適用してから、結果を消費します。
見てみな：

```rust
(1..)
    .filter(|&x| x % 2 == 0)
    .filter(|&x| x % 3 == 0)
    .take(5)
    .collect::<Vec<i32>>();
```

これは、あなたを含むベクター与える`6`、 `12`、 `18`、 `24`、および`30`。

これは、イテレーター、イテレーターアダプター、および消費者があなたを助けることができるもののほんの少しの味です。
本当に便利なイテレータは数多くあり、独自のイテレータを書くこともできます。
イテレータは、あらゆる種類のリストを操作するための安全で効率的な方法を提供します。
彼らは最初は少し珍しいですが、もしあなたがそれらと遊ぶなら、あなたは夢中になるでしょう。
異なるイテレータとコンシューマの完全なリストについては、[イテレータモジュールのドキュメントを参照してください](../../std/iter/index.html)。
