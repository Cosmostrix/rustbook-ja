# 反復子

ループについて話しよう。

Rust's `for`ループを覚え`for`ますか？　
ここに例があります。

```rust
for x in 0..10 {
    println!("{}", x);
}
```

あなたがRustをもっと知るようになったので、これがどのように機能するかについて詳しく話すことができます。
範囲（`0..10`）は「反復子」です。
反復子は、`.next()`操作法を繰り返し呼び出すことができるものであり、一連の処理を行います。

`0..10`ような2つの点がある範囲は、左に（0から始まるように）含まれ、右にのみ（したがって9で終わります）です。
数学者は "[0、10]"と書く。

このような。

```rust
let mut range = 0..10;

loop {
    match range.next() {
        Some(x) => {
            println!("{}", x);
        },
        None => { break }
    }
}
```

反復子である範囲に対して可変束縛を行います。
次に内側の`match` `loop`。
この`match`は、`range.next()`結果に使用され、反復子の次の値への参照を与えます。
`next`、 `Option<i32>`返します。この場合、値がある場合は`Some(i32)`、なくなると`None`になります。
出た場合`Some(i32)`、それを印字して、取得しない場合は`None`、`break`ループの外に。

この譜面サンプルは、基本的に`for`ループ版と同じです。
`for`ループは、この`loop` / `match` / `break`構造を書く便利な方法です。

`for`ループは反復子を使用する唯一のものではありません。
独自の反復子を書くには、`Iterator`特性を実装する必要があります。
これを行うのはこのガイドの範囲外ですが、Rustはさまざまな仕事を達成するための数多くの有用な反復子を提供しています。
しかし、まず、範囲の限界についての多少の注意。

範囲は非常に原始的であり、しばしばより良い選択肢を使用することができます。
以下のRustアンチパターンを考えてみましょう。範囲を使用してCスタイル`for`ループを再現`for`ます。
ベクトルの内容を繰り返し処理する必要があるとしましょう。
あなたはこれを書くように誘惑されるかもしれません。

```rust
let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!("{}", nums[i]);
}
```

これは、実際の反復子を使用するよりも厳密に悪いことです。
ベクトルを直接反復処理することができますので、これを書いてください。

```rust
let nums = vec![1, 2, 3];

for num in &nums {
    println!("{}", num);
}
```

これには2つの理由があります。
まず、これは意味するものをより直接的に表しています。
添字全体を反復処理するのではなく、ベクトル全体を反復処理し、ベクトルを添字化します。
第2に、この版がより効率的です。最初の版では、添字`nums[i]`使用しているため、余分な境界チェックが行われます。
しかし、反復子でベクトルの各要素への参照を順番に生成するので、2番目の例では境界チェックはありません。
これは反復子では非常に一般的です。不要な境界チェックを無視できますが、まだ安全であることはわかります。

`println!`がどのように動作するかによって100％明確ではない別の詳細がここにあります。
`num`は実際には`&i32`型です。
つまり、それはへの参照です`i32`、ない`i32`そのもの。
`println!`は参照解除を処理するので、表示されません。
この譜面もうまくいきます。

```rust
let nums = vec![1, 2, 3];

for num in &nums {
    println!("{}", *num);
}
```

今`num`明示的に逆参照しています。
なぜ`&nums`は私たちに参照を与えるのでしょうか？　
まず、`&`。
第二に、それがデータそのものを私たちに与えたならば、データのコピーを作成して私たちにそれを与えることを含む所有者でなければなりません。
参考文献では、データへの参照のみを借用しているため、参照を渡すだけで、移動する必要はありません。

それで、範囲がしばしばあなたが望むものではないことを確立したので、代わりにあなたがしたいことについて話しましょう。

ここでは、*反復子ー*、 *反復子ー・アダプター*、および*コンシューマーの* 3つのクラスに大別できます。
いくつかの定義があります。

* *反復子*は一連の値を*返し*ます。
* *反復子アダプタ*は反復子上で動作し、異なる出力シーケンスを持つ新しい反復子を生成します。
* *消費者*は反復子上で動作し、最終的な値セットを生成します。

すでに反復子、範囲を見てきたので、最初に消費者について話しましょう。

## 消費者

*消費者*は反復子で動作し、ある種の値や値を返します。
最も一般的なコンシューマーは`collect()`です。
この譜面はあまり製譜されませんが、意図を示しています。

```rust,ignore
let one_to_one_hundred = (1..101).collect();
```

ご覧のとおり、反復子の`collect()`を呼び出します。
`collect()`は反復子が与える多くの値をとり、結果の集まりを返します。
だから、なぜこれは製譜されませんか？　
Rustは、あなたが収集したいものの型を決定することができないので、それを知らせる必要があります。
製譜する版は次のとおりです。

```rust
let one_to_one_hundred = (1..101).collect::<Vec<i32>>();
```

覚えていれば、[`::<>`構文](generics.html#resolving-ambiguities)は、製譜器に整数のベクトルが必要なことを伝えるヒントを与えることができます。
しかし、必ずしも全体の型を使う必要はありません。
`_`を使用すると、部分的なヒントを提供できます。

```rust
let one_to_one_hundred = (1..101).collect::<Vec<_>>();
```

これは「 `Vec<T>`に集めてください。しかし、`T`が私のためにあると推測してください」と言います。
`_`は、このため「型場所取り」と呼ばれることがあります。

`collect()`は最も一般的な消費者ですが、他にもあります。
`find()`は1つです。

```rust
let greater_than_forty_two = (0..100)
                             .find(|x| *x > 42);

match greater_than_forty_two {
    Some(_) => println!("Found a match!"),
    None => println!("No match found :("),
}
```

`find`は閉包`find`とり、反復子の各要素への参照で動作します。
この閉包は返し`true`要素は、探している要素であり、そして場合`false`そう。
`find`は、指定された述語を満たす最初の要素を返します。
一致する要素が`find`ない可能性があるため、`find`は要素自体ではなく`Option` `find`返します。

もう一つの重要な消費者は`fold`です。
以下はその様子です。

```rust
let sum = (1..4).fold(0, |sum, x| sum + x);
```

`fold()`は`fold(base, |accumulator, element| ...)`ようなコンシューマ`fold(base, |accumulator, element| ...)`。
これには2つの引数があります。最初の要素は*ベース*と呼ばれる要素です。
2つ目は閉包で、2つの引数をとります。最初は*アキュムレータ*、2つ目は*要素*です。
各反復で、閉包が呼び出され、結果が次の反復でのアキュムレータの値になります。
最初の反復では、ベースにアキュムレータの値が割り当てられます。

さて、それは少し混乱しています。
この反復子でこれらのすべての値を調べてみましょう。

|<!--base |-->ベース|<!--accumulator |-->アキュムレータ|<!--element |-->要素|<!--closure result |-->閉包の結果|
|<!--------|-------------|---------|----------------|-->------| -------------| ---------| ----------------|
|<!--0 |-->0 |<!--0 |-->0 |<!--1 |-->1 |<!--1 |-->1 |
|<!--0 |-->0 |<!--1 |-->1 |<!--2 |-->2 |<!--3 |-->3 |
|<!--0 |-->0 |<!--3 |-->3 |<!--3 |-->3 |<!--6 |-->6 |

`fold()`は次の引数で呼び出されました。

```rust
# (1..4)
.fold(0, |sum, x| sum + x);
```

したがって、`0`はベース、`sum`はアキュムレータ、`x`は要素です。
最初の反復では、`sum`を`0`に設定し、`x`は`nums`、 `1`最初の要素です。
次に、`sum`と`x`を`sum`、 `0 + 1 = 1`ます。
第2の反復で、その値は、アキュムレータとなる`sum`、及び要素は、配列の第二の要素である`2`。
`1 + 2 = 3`となるので、最後の反復のアキュムレータの値になります。
その反復では、`x`は最後の要素`3`と`3 + 3 = 6`。これは最終的な結果です。
`1 + 2 + 3 = 6`となり、これが結果です。

ホウ
`fold`あなたはそれを参照してください最初の数回少し奇妙なことができますが、それはクリックすると、あなたはあらゆる場所にそれを使用することができます。
あなたが物事のリストを持っていて、あなたが一つの結果を望む時はいつでも、`fold`は適切です。

消費者は、まだ話していない反復子のもう一つの特性、すなわち怠惰のために重要です。
反復子ーについてもう少し詳しく説明しましょう。消費者がなぜ重要であるかを理解してください。

## 反復子

前にも述べたように、反復子は`.next()`操作法を繰り返し呼び出すことができ、一連の処理を行います。
操作法を呼び出す必要があるため、反復子は*遅延*していて、すべての値を前もって生成することはできません。
たとえば、この譜面では、実際には数字`1-99`が生成されるのではなく、単にシーケンスを表す値が作成されます。

```rust
let nums = 1..100;
```

範囲で何もしなかったので、シーケンスを生成しませんでした。
消費者を追加しましょう。

```rust
let nums = (1..100).collect::<Vec<i32>>();
```

さて、`collect()`は、その範囲に複数の数値を与える必要があるので、シーケンスを生成する作業を行います。

範囲は、2つの基本的な反復子のうちの1つです。
もう一つは`iter()`です。
`iter()`は、ベクトルを順番に各要素を与える単純な反復子に変えることができます。

```rust
let nums = vec![1, 2, 3];

for num in nums.iter() {
   println!("{}", num);
}
```

これらの2つの基本的な反復子は、あなたにうまく役立つはずです。
無限大を含むいくつかの高度な反復子があります。

iteratorsについては十分です。
反復子ーアダプターは反復子ーに関して最後に話す必要がある概念です。
それに行きましょう！　

## 反復子アダプタ

*反復子アダプタ*は反復子を受け取り、それを何らかの形で変更して、新しい反復子を生成します。
最も簡単なものは`map`と呼ばれ`map`。

```rust,ignore
(1..100).map(|x| x + 1);
```

`map`は別の反復子ーで呼び出され、新しい反復子ーを生成します。ここで、各エレメント参照は、呼び出された引数として与えられた閉包を持ちます。
これで`2-100`の数字が得られます。
よくほとんど！　
この例を製譜すると、警告が表示されます。

```text
warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

怠惰が再び襲う！　
その閉包は決して実行されません。
この例では数値は表示されません。

```rust,ignore
(1..100).map(|x| println!("{}", x));
```

副作用のために反復子で閉包を実行しようとしている場合は`for`代わりに`for`を使用`for`ます。

興味深い反復子ーアダプターがたくさんあります。
`take(n)`は、元の反復子の次の`n`要素`n`反復子を返します。
無限の反復子で試してみましょう。

```rust
for i in (1..).take(5) {
    println!("{}", i);
}
```

これは印字されます

```text
1
2
3
4
5
```

`filter()`は、引数として閉包をとるアダプタです。
この閉包は`true`または`false`返し`true`。
新しい反復子`filter()`は、閉包が`true`を返す要素のみを生成します。

```rust
for i in (1..100).filter(|&x| x % 2 == 0) {
    println!("{}", i);
}
```

これは、1と100の間のすべての偶数を印字します。
（とは異なり、なお`map`に渡さ閉包`filter`代わり素子自体の要素への参照を渡されます。ここで、フィルタ述語が使用`&x`整数を抽出するパターンをそれが返すためのフィルタ閉包基準を渡される`true`又は要素の代わりに`false`使用するため、`filter`実装は、新しく構築された反復子に要素を入れるために所有権を保持する必要があります。

3つの要素を1つにまとめることができます。反復子から始め、数回それを適用してから、結果を消費します。
見てみな。

```rust
(1..)
    .filter(|&x| x % 2 == 0)
    .filter(|&x| x % 3 == 0)
    .take(5)
    .collect::<Vec<i32>>();
```

これは、あなたを含むベクター与える`6`、 `12`、 `18`、 `24`、および`30`。

これは、反復子ー、反復子ーアダプター、および消費者があなたを助けることができるもののほんの少しの味です。
本当に便利な反復子は数多くあり、独自の反復子を書くこともできます。
反復子は、あらゆる種類のリストを操作するための安全で効率的な方法を提供します。
それらは最初は少し珍しいですが、もしあなたがそれらと遊ぶなら、あなたは夢中になるでしょう。
異なる反復子とコンシューマの完全なリストについては、[反復子役区の開発資料を参照してください](../../std/iter/index.html)。
