# 所有

これは、Rustの所有権体系を提示する3つの章のうちの最初のものです。
これは、Rustの最も顕著で魅力的な機能の1つで、Rustの開発者はかなり知り合いになるはずです。
所有権とは、Rustが最大の目標である記憶域の安全性を達成する方法です。
いくつかの異なる概念があり、それぞれ独自の章があります。

* あなたが今読んでいる所有権
* [borrowing][borrowing]、およびそれらの関連する特徴 '参照'
* [lifetimes][lifetimes]、高度な借入概念

これら3つの章は関連しており、順番に説明されています。
所有権システムを完全に理解するには、3つすべてが必要です。

[lifetimes]: lifetimes.html
 [borrowing]: references-and-borrowing.html


# メタ

詳細を知る前に、所有権システムに関する2つの重要な注意事項。

Rustは安全性とスピードに焦点を当てています。
これは、多くの「ゼロコスト抽象化」によってこれらの目標を達成します。つまり、Rustでは抽象化のコストをできるだけ少なくして機能させることを意味します。
所有権システムは、ゼロコスト抽象化の主要な例です。
このガイド _で説明する_ すべての分析は _、製譜時に行われます_ 。
これらの機能の実行時コストを支払うことはありません。

しかし、このシステムには一定のコストがあります。学習曲線。
Rustの新しいユーザーの多くは、Rust製譜器が作成者が有効だと思う算譜を製譜することを拒否する「borrow checkerとの戦い」と呼ばれることを経験しています。
これは、所有者がどのように動作するかについての演譜師の心的模型が、Rustが実装する実際のルールと一致しないためによく発生します。
最初は似たようなことを経験するでしょう。
ただし、経験豊かなRust開発者は、所有権体系のルールを一定期間使用すると、借用検査器との競争が少なくなることを報告しています。

そのことを念頭に置いて、所有権について学びましょう。

# 所有

[変数束縛][bindings]はRustのプロパティを持っています。束縛されているものの所有権を持っています。
つまり、束縛が有効範囲外になると、Rustは束縛された資源を解放します。
例えば。

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

`v`が有効になると[、山][stack]上に新しい[vector][vectors]が作成され[、原上][heap]にその要素のためのスペースが割り当てられます。
`v`が`foo()`終わりに有効範囲から外れると、Rustはベクトルに関連するすべてのもの、原割り当て記憶さえも後始末します。
これは、有効範囲の最後に確定的に発生します。

前の章で[vectors]ました。
実行時に原上に領域を割り当てる型の例としてここで使用します。
それらは[arrays]ように振る舞い[arrays]、それらの要素に`push()`することでサイズが変わることがあります。

ベクタは[汎用型][generics] `Vec<T>`を持つため、この例では`v`は`Vec<i32>`型になります。
[generics]については、後の章で詳しく説明します。

[arrays]: primitive-types.html#arrays
 [vectors]: vectors.html
 [heap]: the-stack-and-the-heap.html#the-heap
 [stack]: the-stack-and-the-heap.html#the-stack
 [bindings]: variable-bindings.html
 [generics]: generics.html


# 意味論を移動する

しかし、ここではさらに細かいことがあります。Rustは、特定の資源への束縛が _1つだけ_ であることを保証します。
たとえば、ベクターがある場合は、それを別の束縛に割り当てることができます。

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

しかし、`v`後で使用しようとすると、誤りが発生します。

```rust,ignore
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]);
```

これは次のようになります。

```text
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
                        ^
```

所有権を取得する機能を定義し、それを引数として渡した後に何かを使用しようとすると、同様のことが起こります。

```rust,ignore
fn take(v: Vec<i32>) {
#    // What happens here isn’t important.
    // ここで起こることは重要ではありません。
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

同じ誤り。 '移動値の使用'。
所有権を他のものに移すと、参照するものを「移動」したと言います。
特別な注釈は必要ありません.Rustが行う黙用のものです。

## 詳細

移動した後に束縛を使用できない理由は微妙ですが、重要です。

このような譜面を書くときは。

```rust
let x = 10;
```

Rustは[stack][sh]上の整数[i32]記憶を割り当て、10の値を表すビットパターンを割り当てられた記憶にコピーし、将来の参照のために変数名xをこの記憶領域に束縛します。

[i32]: primitive-types.html#numeric-types

ここで、次の譜面断片を考えてみましょう。

```rust
let v = vec![1, 2, 3];

let mut v2 = v;
```

最初の行は、上記の`x`場合と同様に、ベクトル対象`v`記憶を山に割り当てます。
しかしそれに加えて、[heap][sh]上に実際のデータ（`[1, 2, 3]`）のためにいくらかの記憶も割り当て[heap][sh]。
Rustは、この原割り当ての番地を内部指し手にコピーします。内部指し手は、山に配置されたベクタ対象の一部です（データ指し手と呼ばせてください）。

ベクトル対象とそのデータは、単一の連続した記憶割り当てではなく、別々の記憶領域に存在することを指摘する価値があります（この時点では取り上げない理由による）。
ベクトルの2つの部分（山上のものと原上のもの）は、長さ、容量などの点で常に一致しなければなりません。

`v`を`v2`に移動すると、Rustは実際にベクトル対象`v`ビット単位のコピーを`v2`表される山割り当てに行います。
この浅いコピーは、実際のデータを含む原割り当てのコピーを作成しません。
これは、ベクトルの内容に対する2つの指し手が、原上の同じ記憶割り当てを指し示すことを意味します。
`v`と`v2`両方に同時にアクセスできる場合、データ競争を導入することでRustの安全保証に違反することになります。

たとえば、ベクトルを`v2`から2つの要素に切り捨てた場合、

```rust
# let v = vec![1, 2, 3];
# let mut v2 = v;
v2.truncate(2);
```

そして`v`以来、無効なベクトルで終わるだろうまだアクセスした`v`、原データが切り捨てられたことを知ることはできません。
さて、山上のベクトル`v`部分は、原上の対応する部分と一致しません。
`v`まだベクトルに3つの要素があると思っていて、幸せには存在しない要素`v[2]`アクセスできるようになりますが、これは災害のためのレシピです。
特に、セグメンテーションフォールトにつながる可能性があるか、悪化すると、権限のないユーザーがアクセスできない記憶から読み取ることができるためです。

これは、Rustが移動を行った後に`v`を使用することを禁じている理由です。

[sh]: the-stack-and-the-heap.html

状況によっては、最適化によって山上のバ​​イトの実際のコピーが削除されることに注意することも重要です。
だから最初のように非効率的ではないかもしれません。

## `Copy`型

所有権が別の束縛に転送されると、元の束縛を使用することはできません。
しかし、この振る舞いを変える[trait][traits]があり、`Copy`と呼ばれています。
まだ特性について議論していませんが、今のところ特別な動作を追加する特定の型の注釈と考えることができます。
例えば。

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);
```

この場合、`v`は`i32`、これは`Copy`特性を実装します。
つまり、移動と同様に、`v`を`v2`に代入すると、データのコピーが作成されます。
しかし、移動とは違って、後で`v`使うことができます。
これは、`i32`は他の場所へのデータへの指し手がないため、コピーは完全なコピーであるためです。

すべての基本型は`Copy`特性を実装しているため、その所有権は '所有権ルール'に従うと想定されるように移動されません。
例を挙げると、譜面の2つのスニペットは、`i32`と`bool`型が`Copy`特性を実装しているため、製譜するだけです。

```rust
fn main() {
    let a = 5;

    let _y = double(a);
    println!("{}", a);
}

fn double(x: i32) -> i32 {
    x * 2
}
```

```rust
fn main() {
    let a = true;

    let _y = change_truth(a);
    println!("{}", a);
}

fn change_truth(x: bool) -> bool {
    !x
}
```

`Copy`特性を実装していない型を使用した場合、移動した値を使用しようとしたため製譜誤りが発生していました。

```text
error: use of moved value: `a`
println!("{}", a);
               ^
```

あなた自身の型が作成する方法について説明します`Copy`に[traits][traits]章。

[traits]: traits.html

# 所有権以上

もちろん、書いたすべての機能を所有権に戻さなければならない場合は、

```rust
fn foo(v: Vec<i32>) -> Vec<i32> {
#    // Do stuff with `v`.
    //  `v`物をしなさい。

#    // Hand back ownership.
    // 所有権を手渡す。
    v
}
```

これは非常に退屈になるでしょう。
所有権を取得したいことが増えれば悪化します。

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
#    // Do stuff with `v1` and `v2`.
    //  `v1`と`v2`ものを使ってください。

#    // Hand back ownership, and the result of our function.
    // 手持ちの所有権と機能の結果。
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

うん！　
戻り値の型、返り値、機能を呼び出すことはもっと複雑になります。

幸運にも、Rustはこの問題を解決するのに役立つ機能を提供しています。
それは借用と呼ばれ、次の章の話題です！　

