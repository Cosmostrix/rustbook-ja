# 所有

これは、Rustの所有システムを提示する3つのセクションのうちの最初のものです。
これは、Rustの最も顕著で魅力的な機能の1つで、Rustの開発者はかなり知り合いになるはずです。
所有権とは、Rustが最大の目標であるメモリの安全性を達成する方法です。
いくつかの異なる概念があり、それぞれ独自の章があります。

* あなたが今読んでいる所有権
* [borrowing][borrowing]、およびそれらの関連するフィーチャ '参照'
* [lifetimes][lifetimes]、高度な借入概念

これら3つの章は関連しており、順番に説明されています。
所有権システムを完全に理解するには、3つすべてが必要です。

[lifetimes]: lifetimes.html
 [borrowing]: references-and-borrowing.html


# メタ

詳細を知る前に、オーナーシップシステムに関する2つの重要な注意事項。

錆は安全性とスピードに焦点を当てています。
これは、多くの「ゼロコスト抽象化」によってこれらの目標を達成します。つまり、Rustでは抽象化のコストをできるだけ少なくして機能させることを意味します。
所有権システムは、ゼロコスト抽象化の主要な例です。
このガイド _で説明する_ すべての分析は _、コンパイル時に行われます_ 。
これらの機能のランタイムコストを支払うことはありません。

しかし、このシステムには一定のコストがあります：学習曲線。
Rustの新しいユーザーの多くは、Rustコンパイラが作成者が有効だと思うプログラムをコンパイルすることを拒否する「borrow checkerとの戦い」と呼ばれることを経験しています。
これは、所有者がどのように動作するかについてのプログラマーの精神モデルが、Rustが実装する実際のルールと一致しないためによく発生します。
最初は似たようなことを経験するでしょう。
ただし、経験豊かなRustデベロッパーは、所有システムのルールを一定期間使用すると、借りチェッカーとの競争が少なくなることを報告しています。

そのことを念頭に置いて、所有権について学びましょう。

# 所有

[変数バインディング][bindings]はRustのプロパティを持っています。バインドされているものの所有権を持っています。
つまり、バインディングが有効範囲外になると、Rustはバインドされたリソースを解放します。
例えば：

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

`v`が有効になると[、スタック][stack]上に新しい[vector][vectors]が作成され[、ヒープ上][heap]にその要素のためのスペースが割り当てられます。
`v`が`foo()`終わりにスコープから外れると、Rustはベクトルに関連するすべてのもの、ヒープ割り当てメモリさえもクリーンアップします。
これは、スコープの最後に確定的に発生します。

前の章で[vectors]ました。
実行時にヒープ上に領域を割り当てる型の例としてここで使用します。
それらは[arrays]ように振る舞い[arrays]、それらの要素に`push()`することでサイズが変わることがあります。

ベクタは[汎用型][generics] `Vec<T>`を持つため、この例では`v`は`Vec<i32>`型になります。
[generics]については、後の章で詳しく説明します。

[arrays]: primitive-types.html#arrays
 [vectors]: vectors.html
 [heap]: the-stack-and-the-heap.html#the-heap
 [stack]: the-stack-and-the-heap.html#the-stack
 [bindings]: variable-bindings.html
 [generics]: generics.html


# セマンティクスを移動する

しかし、ここではさらに細かいことがあります：Rustは、特定のリソースへのバインディングが _1つだけ_ であることを保証します。
たとえば、ベクターがある場合は、それを別のバインディングに割り当てることができます。

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

しかし、`v`後で使用しようとすると、エラーが発生します。

```rust,ignore
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]);
```

これは次のようになります。

```text
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
                        ^
```

所有権を取得する関数を定義し、それを引数として渡した後に何かを使用しようとすると、同様のことが起こります。

```rust,ignore
fn take(v: Vec<i32>) {
#    // What happens here isn’t important.
    // ここで起こることは重要ではありません。
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

同じエラー： '移動値の使用'。
所有権を他のものに移すと、私たちが参照するものを「移動」したと言います。
特別な注釈は必要ありません.Rustが行うデフォルトのものです。

## 詳細

私たちが移動した後にバインディングを使用できない理由は微妙ですが、重要です。

このようなコードを書くときは：

```rust
let x = 10;
```

Rustは[stack][sh]上の整数[i32]メモリを割り当て、10の値を表すビットパターンを割り当てられたメモリにコピーし、将来の参照のために変数名xをこのメモリ領域にバインドします。

[i32]: primitive-types.html#numeric-types

ここで、次のコード断片を考えてみましょう。

```rust
let v = vec![1, 2, 3];

let mut v2 = v;
```

最初の行は、上記の`x`場合と同様に、ベクトルオブジェクト`v`メモリをスタックに割り当てます。
しかしそれに加えて、[heap][sh]上に実際のデータ（`[1, 2, 3]`）のためにいくらかのメモリも割り当て[heap][sh]。
錆は、このヒープ割り当てのアドレスを内部ポインタにコピーします。内部ポインタは、スタックに配置されたベクタオブジェクトの一部です（データポインタと呼ばせてください）。

ベクトルオブジェクトとそのデータは、単一の連続したメモリ割り当てではなく、別々のメモリ領域に存在することを指摘する価値があります（この時点では取り上げない理由による）。
ベクトルの2つの部分（スタック上のものとヒープ上のもの）は、長さ、容量などの点で常に一致しなければなりません。

`v`を`v2`に移動すると、Rustは実際にベクトルオブジェクト`v`ビット単位のコピーを`v2`表されるスタック割り当てに行います。
この浅いコピーは、実際のデータを含むヒープ割り当てのコピーを作成しません。
これは、ベクトルの内容に対する2つのポインタが、ヒープ上の同じメモリ割り当てを指し示すことを意味する。
`v`と`v2`両方に同時にアクセスできる場合、データ競争を導入することでRustの安全保証に違反することになります。

たとえば、ベクトルを`v2`から2つの要素に切り捨てた場合、

```rust
# let v = vec![1, 2, 3];
# let mut v2 = v;
v2.truncate(2);
```

そして`v`以来、私たちは、無効なベクトルで終わるだろうまだアクセスした`v`、ヒープデータが切り捨てられたことを知ることはできません。
さて、スタック上のベクトル`v`部分は、ヒープ上の対応する部分と一致しません。
`v`まだベクトルに3つの要素があると思っていて、幸せには存在しない要素`v[2]`アクセスできるようになりますが、これは災害のためのレシピです。
特に、セグメンテーションフォールトにつながる可能性があるか、悪化すると、権限のないユーザーがアクセスできないメモリから読み取ることができるためです。

これは、Rustが私たちが移動を行った後に`v`を使用することを禁じている理由です。

[sh]: the-stack-and-the-heap.html

状況によっては、最適化によってスタック上のバ​​イトの実際のコピーが削除されることに注意することも重要です。
だから最初のように非効率的ではないかもしれません。

## `Copy`タイプ

所有権が別のバインディングに転送されると、元のバインディングを使用することはできません。
しかし、この振る舞いを変える[trait][traits]があり、`Copy`と呼ばれています。
私たちはまだ特性について議論していませんが、今のところ特別な動作を追加する特定のタイプの注釈と考えることができます。
例えば：

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);
```

この場合、`v`は`i32`、これは`Copy`特性を実装します。
つまり、移動と同様に、`v`を`v2`に代入すると、データのコピーが作成されます。
しかし、移動とは違って、私たちは後で`v`使うことができます。
これは、`i32`は他の場所へのデータへのポインタがないため、コピーは完全なコピーであるためです。

すべてのプリミティブ型は`Copy`特性を実装しているため、その所有権は '所有権ルール'に従うと想定されるように移動されません。
例を挙げると、コードの2つのスニペットは、`i32`と`bool`タイプが`Copy`特性を実装しているため、コンパイルするだけです。

```rust
fn main() {
    let a = 5;

    let _y = double(a);
    println!("{}", a);
}

fn double(x: i32) -> i32 {
    x * 2
}
```

```rust
fn main() {
    let a = true;

    let _y = change_truth(a);
    println!("{}", a);
}

fn change_truth(x: bool) -> bool {
    !x
}
```

`Copy`特性を実装していない型を使用した場合、移動した値を使用しようとしたためコンパイルエラーが発生していました。

```text
error: use of moved value: `a`
println!("{}", a);
               ^
```

私たちは、あなた自身の型が作成する方法について説明します`Copy`に[traits][traits]セクション。

[traits]: traits.html

# 所有権以上

もちろん、私たちが書いたすべての機能を所有権に戻さなければならない場合は、

```rust
fn foo(v: Vec<i32>) -> Vec<i32> {
#    // Do stuff with `v`.
    //  `v`物をしなさい。

#    // Hand back ownership.
    // 所有権を手渡す。
    v
}
```

これは非常に退屈になるでしょう。
所有権を取得したいことが増えれば悪化します：

```rust
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
#    // Do stuff with `v1` and `v2`.
    //  `v1`と`v2`ものを使ってください。

#    // Hand back ownership, and the result of our function.
    // 手持ちの所有権と私たちの機能の結果。
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

うん！
戻り値の型、返り値、関数を呼び出すことはもっと複雑になります。

幸運にも、Rustはこの問題を解決するのに役立つ機能を提供しています。
それは借用と呼ばれ、次のセクションのトピックです！

