# constと静的

Rustは`const`予約語で定数を定義する方法を持っています。

```rust
const N: i32 = 5;
```

[`let`][let]束縛とは異なり、`const`型に注釈を付ける必要があります。

[let]: variable-bindings.html

定数は算譜の寿命にわたって生きています。
具体的には、Rustの定数には記憶内の固定番地がありません。
これは、使用されている各場所に効果的にインライン展開されているためです。
同じ定数への参照が、同じ理由で同じ記憶番地を参照するとは必ずしも保証されません。

# `static`
Rustは、静的な項目に「全体変数」の機能を提供します。
これらは定数に似ていますが、静的な項目は使用時にインライン化されません。
これは、各値に対して実例が1つしかなく、記憶内の固定された場所にあることを意味します。

ここに例があります。

```rust
static N: i32 = 5;
```

[`let`][let]束縛とは異なり、`static`型の注釈を付ける必要があり`static`。

静的は、算譜の寿命にわたって生きるため、静的に保存されている参照には[`'static`寿命があり][lifetimes]ます。

```rust
static NAME: &'static str = "Steve";
```

型の`static`値でなければなりません`Sync`しない限り、`static`値が変更可能です。

[lifetimes]: lifetimes.html

## 可変性

`mut`予約語でmutabilityを導入することができます。

```rust
static mut N: i32 = 5;
```

これは変更可能であるため、ある走脈が`N`を更新している間に別の走脈がそれを読み込んでいるため、記憶が不安定になる可能性があります。
したがって、`static mut`アクセスと変更は[`unsafe`][unsafe]では[`unsafe`][unsafe]ため、`unsafe`段落で行う必要があります。

```rust
# static mut N: i32 = 5;

unsafe {
    N += 1;

    println!("N: {}", N);
}
```

[unsafe]: unsafe.html

# 初期化中

`const`と`static`両方に値を与えるための要件が​​あります。
それらには定数式である値を与えなければなりません。
言い換えれば、機能呼び出しの結果や同様の複雑なものや実行時の結果は使用できません。

# 落ちる

[`Drop`][drop]を実装する型は、`const`と`static`定義で使用できます。
定数はインラインで使用され、それに従って脱落されます。
`static`値は削除されません。

[drop]: drop.html

# どの構成要素を使用する必要がありますか？　

ほとんどの場合、2つの間で選択できる場合は、`const`選択します。
実際にあなたの定数に関連付けられた記憶位置がほしいということは非常にまれですが、`const`を使用すると、あなたの通い箱だけでなく下流の通い箱でも定数伝播のような最適化が可能になります。
