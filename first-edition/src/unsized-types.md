# サイズの小さい型

ほとんどの型はコンパイル時に知ることができる特定のサイズ（バイト単位）を持ちます。
たとえば、`i32`は32ビットビッグ、つまり4バイトです。
しかし、表現するのに便利ですが、定義されたサイズを持たないタイプもあります。
これらは、「サイズ未定義」または「動的サイズ」タイプと呼ばれます。
一例は`[T]`です。
このタイプは、ある数の`T`を順番に表します。
しかし、その数はわからないので、サイズは分かりません。

錆はこれらのタイプのいくつかを理解していますが、いくつかの制限があります。
3つあります：

1. 私たちは、ポインタを使ってunsized型のインスタンスを操作することしかできません。
    `&[T]`は正常に動作しますが、`[T]`は動作しません。
2. 変数と引数には、動的にサイズの変更された型はありません。
3. `struct`最後のフィールドだけが動的にサイズの指定された型を持つことができます。
    他のフィールドは使用できません。
    Enumバリアントは、データとして動的にサイズの変更された型を持つことはできません。

だからどうして気になる？
さて、`[T]`はポインタの後ろにしか使えないので、サイズの指定されていない型の言語サポートがなければ、これを書くことは不可能です：

```rust,ignore
impl Foo for str {
```

または

```rust,ignore
impl<T> Foo for [T] {
```

代わりに、次のように記述する必要があります。

```rust,ignore
impl Foo for &str {
```

つまり、この実装は[references][ref]のみで機能し、他のタイプのポインタでは機能しません。
`impl for str`の`impl for str`は、（ある時点で、最初に修正するいくつかのバグがありますが）ユーザ定義のカスタムスマートポインタを含むすべてのポインタがこの`impl`を使用できます。

[ref]: references-and-borrowing.html

# ？サイズ

動的にサイズの指定された型を受け入れる関数を記述したい場合は、特別なバインドされた構文「 `?Sized`：

```rust
struct Foo<T: ?Sized> {
    f: T,
}
```

これ`?Sized` 「Tがたりしてもしなくてもよいよう読んで、`Sized`私たちは、両方のサイズと無サイズの型と一致することを可能にします、」。
すべてのジェネリック型パラメータは暗黙的に`Sized`バウンドを持つため、`?Sized`を使用して暗黙的なバウンドをオプトアウトすることができます。
