# 入門

本の最初の章では、Rustとそのツールを使って私たちに行くことができます。
まず、Rustをインストールします。
そして、古典的な「Hello World」プログラム。
最後に、Cargo、Rustのビルドシステムとパッケージマネージャについて説明します。

ターミナルを使っていくつかのコマンドを見せてくれるでしょう。これらの行はすべて`$`始まります。
`$` sを入力する必要はありません。各コマンドの開始を示すためのものです。
この慣習に従ったWebの周りのチュートリアルや例は、通常のユーザーとして実行するコマンドの場合は`$`、管理者として実行する必要があるコマンドの場合は`#`れます。

# 錆のインストール

Rustを使用するための最初のステップは、それをインストールすることです。
一般的に言えば、インターネットからRustをダウンロードするので、このセクションでコマンドを実行するにはインターネット接続が必要です。

Rustコンパイラは多数のプラットフォーム上で実行され、コンパイルされますが、Linux、Mac、Windows、x86およびx86-64 CPUアーキテクチャで最もよくサポートされています。
これらのプラットフォーム用のRustコンパイラと標準ライブラリの公式ビルドなどがあります。
[Rustプラットフォームのサポートの詳細については、Webサイトを参照してください][platform-support]。

[platform-support]: https://forge.rust-lang.org/platform-support.html

## 錆のインストール

LinuxやmacOSのようなUnixシステムで行う必要があるのは、ターミナルを開いて次のように入力するだけです：

```bash
$ curl https://sh.rustup.rs -sSf | sh
```

スクリプトをダウンロードしてインストールを開始します。
すべてがうまくいくと、これが表示されます：

```text
Rust is installed now. Great! 
```

Windowsにインストールするのは簡単です： [rustup-init.exe]ダウンロードして実行して[rustup-init.exe]。
コンソールにインストールを開始し、上記のメッセージを表示します。

その他のインストールオプションと情報については、Rust Webサイトの[install]ページを参照してください。

[rustup-init.exe]: https://win.rustup.rs
 [install]: https://www.rust-lang.org/install.html


## アンインストール

錆を取り除くのは、それをインストールするのと同じくらい簡単です：

```bash
$ rustup self uninstall
```

## トラブルシューティング

Rustがインストールされている場合は、シェルを開いて次のように入力します。

```bash
$ rustc --version
```

バージョン番号、ハッシュコミット、およびコミット日付が表示されます。

もしそうなら、Rustは正常にインストールされました！
おめでとう！

そうしなければ、おそらく`PATH`環境変数にCargoのバイナリディレクトリ、UNIXでは`~/.cargo/bin` `%USERPROFILE%\.cargo\bin`、Windowsでは`%USERPROFILE%\.cargo\bin`が含まれていないことを意味します。
これはRust開発ツールが存在するディレクトリであり、ほとんどのRust開発者は`PATH`環境変数にそれを`rustc`しているので、コマンドラインで`rustc`を実行することができます。
オペレーティングシステム、コマンドシェル、およびインストール時のバグの違いにより、シェルを再起動したり、システムからログアウトしたり、`PATH`手動で設定したりする必要があります。

Rustは独自のリンクをしないので、リンカーをインストールする必要があります。
そうすることは、あなたの特定のシステムに依存します。
Linuxベースのシステムの場合、Rustはリンクのために`cc`を呼び出そうとします。
`windows-msvc`（Microsoft Visual StudioでWindows上に構築されたRust）では、これは[Microsoft Visual C ++ビルドツールが][msvbt]インストールされているかどうかによって異なり[ます][msvbt]。
`rustc`がそれらを自動的に見つけるので、これらは`%PATH%`必要はありません。
一般的に、非伝統的な場所にリンカーがある場合、`/path/to/cc`はリンカーパスを指す必要がある`rustc linker=/path/to/cc`を呼び出すことができます。

[msvbt]: http://landinghub.visualstudio.com/visual-cpp-build-tools

あなたがまだ立ち往生しているなら、私たちが助けを得ることができる場所がいくつかあります。
最も簡単である[irc.mozilla.orgの＃錆-初心者のIRCチャンネル][irc-beginners]や一般的な議論のための[irc.mozilla.orgの#rust IRCチャンネル][irc]我々は介してアクセスすることができ、[Mibbit][mibbit]。
それから私たちは、私たちを助けることができる他の錆びた人（私たち自身と呼ぶ愚かなニックネーム）とチャットします。
その他の素晴らしいリソースには[、ユーザーフォーラム][users]と[スタックオーバーフローがあり][stackoverflow]ます。

[irc-beginners]: irc://irc.mozilla.org/#rust-beginners
 [irc]: irc://irc.mozilla.org/#rust
 [mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-beginners,%23rust
 [users]: https://users.rust-lang.org/
 [stackoverflow]: http://stackoverflow.com/questions/tagged/rust


このインストーラは、ドキュメンテーションのコピーもローカルにインストールするので、オフラインで読むことができます。
それは唯一の`rustup doc`です！

# こんにちは世界！

Rustをインストールしたので、最初のRustプログラムを書くのを手伝います。
伝統的に新しい言語を学んで、"Hello、world！"というテキストを画面に表示する小さなプログラムを書いています。このセクションでは、その伝統に従います。

このようなシンプルなプログラムを使い始めることの良い点は、コンパイラがインストールされていることと、正しく動作していることを素早く確認できることです。
スクリーンに情報を印刷することも非常に一般的なことです。早く練習することは良いことです。

> > 注意：このマニュアルでは、コマンドラインについての基本的な知識があることを前提としています。
> > 錆そのものは、編集、ツーリング、コードがどこに保存されているかについて特別な要求をしません。そのため、コマンドラインへのIDEを望むなら、それはオプションです。
> > あなたは、Rustを念頭に置いて作られた[SolidOak]をチェックしたいかもしれません。
> > コミュニティの開発にはいくつかの拡張があり、Rustチームは[various editors]用のプラグインを提供し[various editors]ます。
> > エディタまたはIDEの設定はこのチュートリアルの範囲外です。具体的な設定については、ドキュメントをチェックしてください。

[SolidOak]: https://github.com/oakes/SolidOak
 [various editors]: https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md


## プロジェクトファイルの作成

まず、Rustコードを入れるファイルを作ってください。Rustはあなたのコードがどこにあるのか気にしませんが、この本ではあなたのホームディレクトリに*projects*ディレクトリを作ってそこにすべてのプロジェクトを置いておくことをお勧めします。
端末を開き、次のコマンドを入力して、この特定のプロジェクトのディレクトリを作成します。

```bash
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

> > 注：Windows上でPowerShellを使用していない場合、`~`が機能しない可能性があります。
> > 詳細については、シェルのマニュアルを参照してください。

## 錆プログラムの作成と実行

Rustプログラム用のソースファイルを作成する必要があります。
錆ファイルは常に*.rs*拡張子で終わります。
ファイル名に複数の単語を使用している場合は、アンダースコアを使用して単語を区切ります。
たとえば、*myprogram.rs*ではなく*my_program.rs*を使用します。

さて、新しいファイルを作り、それを*main.rs*と呼んで*ください*。
ファイルを開き、次のコードを入力します。

```rust
fn main() {
    println!("Hello, world!");
}
```

ファイルを保存して、ターミナルウィンドウに戻ります。
LinuxまたはmacOSの場合は、次のコマンドを入力します。

```bash
$ rustc main.rs
$ ./main
Hello, world!
```

Windowsでは`main`を`main.exe`に置き換えて`main.exe`。
オペレーティングシステムにかかわらず、文字列`Hello, world!`という文字列が端末に表示されます。
あなたがしたら、おめでとう！
あなたは正式にRustプログラムを書いています。
それであなたは錆のプログラマーになります！
ようこそ。

## 錆プログラムの解剖

今、あなたの「こんにちは、世界！」で起こったことを見て行きましょう。
詳細なプログラム。
パズルの最初の部分は次のとおりです。

```rust
fn main() {

}
```

これらの行は、Rustの*関数*を定義し*ます*。
`main`機能は特別です：すべてのRustプログラムの始まりです。
最初の行では、「引数を取らずに何も返さない`main`という関数を宣言しています」引数があれば、それらは括弧の中に入ります（`(`と`)`）。関数では、戻り値の型を完全に省略することができます。

関数本体は中括弧（`{`と`}`）で囲まれています。
錆はすべての機能体の周りにこれらを必要とします。
開始中括弧を関数宣言と同じ行に置き、その間に1つのスペースを入れるのは良いスタイルだと考えられます。

`main()`関数の内部：

```rust
    println!("Hello, world!");
```

この行は、この小さなプログラムのすべての作業を行います。スクリーンにテキストを印刷します。
ここで重要な多くの詳細があります。
1つは、タブではなく4つのスペースでインデントされていることです。

2番目の重要な部分は`println!()`行です。
これは、Rust *[マクロ]を*呼び出しています。これは、Rustでメタプログラミングが行われる方法です。
代わりに関数を呼び出していた場合は、`println()`（！なし`println()`ようになります。
Rustマクロについては、後で詳しく説明しますが、今のところ、通常の関数の代わりにマクロを呼び出すことを意味する`!`を知る必要があります。


[macro]: macros.html

次は`"Hello, world!"`という*文字列*です。
文字列は、システムプログラミング言語では驚くほど複雑なトピックであり、*[静的に割り当てられた]*文字列です。
この文字列を`println!`への引数として渡します。この文字列はスクリーンに文字列を出力します。
十分に簡単！

[statically allocated]: the-stack-and-the-heap.html

行はセミコロン（`;`）で終わり`;`。
錆は*[表現指向言語]*です。つまり、ほとんどのことは文ではなく表現です。
`;`
この式が終了し、次の式が開始する準備ができていることを示します。
ほとんどの行のRustコードはaで終わり`;`
。

[expression-oriented language]: glossary.html#expression-oriented-language

## コンパイルと実行は別々の手順です

「錆プログラムの作成と実行」では、新しく作成したプログラムを実行する方法を示しました。
私たちはそのプロセスを打ち破り、それぞれのステップを今調べます。

Rustプログラムを実行する前に、それをコンパイルする必要があります。
Rustコンパイラを使用するには、`rustc`コマンドを入力し、ソースファイルの名前を次のように渡します。

```bash
$ rustc main.rs
```

CまたはC ++のバックグラウンドから来た場合、これは`gcc`または`clang`似ていることが`clang`ます。
正常にコンパイルした後、Rustはバイナリ実行可能ファイルを出力する必要があります。この実行可能ファイルは、LinuxまたはMacOS上で、次のように`ls`コマンドをシェルに入力すると表示されます。

```bash
$ ls
main  main.rs
```

Windowsでは、次のように入力します。

```bash
$ dir
main.exe
main.rs
```

これは、ソースコードと拡張子が`.rs` 2つのファイルと、実行可能ファイル（Windowsの場合は`main.exe`、他のすべては`main`）です。
ここからやるべきことは、`main`や`main.exe`ファイルを次のように実行することです。

```bash
$ ./main  # or .\main.exe on Windows
```

*main.rs*があなたの「こんにちは、世界！
これはあなたの端末に`Hello, world!`を出力します。

Ruby、Python、JavaScriptなどの動的言語を使用している場合、別の手順でプログラムをコンパイルして実行することはできません。
Rustは*先にコンパイルされた*言語です。つまり、プログラムをコンパイルして他の人に与えることができ、Rustをインストールしなくても実行できます。
一方、`.rb`ファイルまたは`.py`または`.js`ファイルを提供する場合は、Ruby、Python、またはJavaScript実装をそれぞれインストールする必要がありますが、プログラムをコンパイルして実行するには1つのコマンドだけが必要です。
すべてが言語デザインのトレードオフです。

`rustc`を`rustc`コンパイルするだけで簡単なプログラムはうまくいきますが、プロジェクトが成長するにつれて、プロジェクトにあるすべてのオプションを管理し、他の人やプロジェクトとコードを簡単に共有できるようにしたいと考えています。
次に、Cargoというツールを紹介しましょう。実際のRustプログラムを書くのに役立ちます。

# こんにちは、貨物！

CargoはRustのビルドシステムとパッケージマネージャーであり、RustaceansはRustプロジェクトを管理するためにCargoを使用しています。
Cargoは、コードの構築、コードが依存するライブラリのダウンロード、およびそれらのライブラリの構築といった3つのことを管理します。
あなたのコードはそれらに依存しているので、私たちはライブラリにあなたのコードが必要とするものを「依存関係」と呼びます。

最も単純なRustプログラムは依存性がないので、今はその機能の最初の部分のみを使用します。
もっと複雑なRustプログラムを書いていくうちに、依存関係を追加したいと思っています。そして、Cargoを使い始めた方がはるかに簡単です。

膨大な数のRustプロジェクトがCargoを使用しているので、あなたはそれを他の本のために使用していると想定します。
あなたが公式のインストーラを使用した場合、CargoにはRust自身がインストールされています。
Rustを他の手段でインストールした場合は、次のように入力してCargoがインストールされているかどうかを確認できます。

```bash
$ cargo --version
```

ターミナルに。
バージョン番号が表示されている場合は、素晴らしい！
' `command not found` 'のようなエラーが表示された場合は、Rustをインストールしたシステムのドキュメントを参照して、Cargoが分離しているかどうかを判断する必要があります。

## 貨物に変換する

Hello WorldプログラムをCargoに変換しましょう。
プロジェクトを貨物にするには、次の3つのことを行う必要があります。

1. あなたのソースファイルを正しいディレクトリに置きます。
2. 古い実行可能ファイル（Windowsの`main.exe`、他のすべての`main`）を取り除く。
3. 貨物設定ファイルを作成します。

始めましょう！

### ソースディレクトリの作成と古い実行ファイルの削除

まず、端末に戻り、*hello_world*ディレクトリに移動し、次のコマンドを入力します。

```bash
$ mkdir src
$ mv main.rs src/main.rs # or 'move main.rs src/main.rs' on Windows
$ rm main  # or 'del main.exe' on Windows
```

Cargoはあなたのソースファイルが*src*ディレクトリ内に存在することを期待しています。
これにより、トップレベルのプロジェクトディレクトリ（この場合は*hello_world*）に、README、ライセンス情報、およびコードに関係のないものが残ります。
このように、Cargoを使用すると、プロジェクトをきれいに整えておくことができます。
すべての場所があり、すべてがその場所にあります。

*main.rs*を*src*ディレクトリに移動し、`rustc`作成したコンパイル済みファイルを削除します。
いつものように、Windowsの場合`main`を`main.exe`に置き換えてください。

この例では、ソースファイル名として`main.rs`を保持しているため、実行可能ファイルが作成されています。
代わりにライブラリを作成したい場合は、ファイル名を`lib.rs`ます。
このコンベンションは、Cargoによってプロジェクトのコンパイルに使用されますが、必要に応じてオーバーライドできます。

### 構成ファイルの作成

次に、*hello_world*ディレクトリ内に新しいファイルを作成し、`Cargo.toml`という`Cargo.toml`ます。

`Cargo.toml`で`C`を大文字にしてください。そうしないと、Cargoは設定ファイルの処理方法を知らないでしょう。

このファイルは*[TOML]*（Tom's Obvious、Minimal Language）形式です。
TOMLはINIに似ていますが、いくつかの追加機能があり、Cargoの設定形式として使用されています。

[TOML]: https://github.com/toml-lang/toml

このファイルの中に、次の情報を入力します。

```toml
[package]

name = "hello_world"
version = "0.0.1"
authors = [ "Your name <you@example.com>" ]
```

最初の行`[package]`は、次の文がパッケージを構成していることを示します。
このファイルに情報を追加すると、他のセクションも追加されますが、今のところパッケージの設定のみが行われています。

他の3行は、あなたのプログラムをコンパイルするためにCargoが知っておく必要がある3ビットの設定を設定します：名前、バージョン、バージョン

この情報を*Cargo.toml*ファイルに追加したら、保存して設定ファイルの作成を完了します。

## 貨物プロジェクトの構築と実行

*Cargo.toml*ファイルをプロジェクトのルートディレクトリに置き、Hello Worldプログラムをビルドして実行する準備ができているはずです。
これを行うには、次のコマンドを入力します。

```bash
$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Hello, world!
```

バム！
すべてうまくいけば、`Hello, world!`もう一度端末にプリントしてください。

あなたは単に`cargo build`プロジェクトを`cargo build`し、. `./target/debug/hello_world`で走らせましたが、実際には両方とも、以下のように`cargo run`て1つのステップで行うことができます：

```bash
$ cargo run
     Running `target/debug/hello_world`
Hello, world!
```

`run`コマンドは、プロジェクトを迅速に反復処理する必要がある場合に便利です。

この例はプロジェクトを再構築しなかったことに注意してください。
Cargoはファイルが変更されていないと判断し、バイナリを実行しました。
ソースコードを変更した場合、Cargoはプロジェクトを実行する前にプロジェクトを再構築しています。

```bash
$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Hello, world!
```

Cargoは、プロジェクトのファイルが変更されたかどうかを確認し、最後にビルドしてから変更があった場合にのみプロジェクトを再構築します。

シンプルなプロジェクトでは、Cargoは`rustc`だけを使用しているだけではありませんが、将来的には便利になります。
これは、あなたが箱を使用し始めたときに特に当てはまります。
これらは他のプログラミング言語の 'ライブラリ'または 'パッケージ'と同義です。
複数のクレートで構成される複雑なプロジェクトの場合、Cargoにビルドを調整させるのはずっと簡単です。
貨物を使用`cargo build`、 `cargo build`を実行することができ、正しい方法で動作するはずです。

### リリースのためのビルディング

プロジェクトのリリース準備が整ったら、`cargo build --release`を使用してプロジェクトを最適化してコンパイルできます。
これらの最適化により、Rustコードはより速く実行されますが、これらを有効にすると、プログラムのコンパイル時間が長くなります。
これは、開発用のプロファイルと、ユーザーに与える最終的なプログラムを構築するプロファイルの2つのプロファイルが存在する理由です。

### `Cargo.lock`とは何ですか？

`cargo build`実行`cargo build`と、Cargoは*Cargo.lock*という新しいファイルを作成します。これは次のようになります。

```toml
[root]
name = "hello_world"
version = "0.0.1"
```

Cargoは*Cargo.lock*ファイルを使用してアプリケーションの依存関係を追跡します。
これはHello Worldプロジェクトの*Cargo.lock*ファイルです。
このプロジェクトは依存関係がないので、ファイルは少しばかりです。
現実的に、あなたはこのファイルを自分で触れる必要はありません。
Cargoにそれを処理させてください。

それでおしまい！
あなたがフォローしてきたなら、Cargoで`hello_world`を正常に構築しておく必要があります。

プロジェクトはシンプルですが、現在はRustの残りの仕事に使用する実際のツールの多くを使用しています。
実際には、以下のコマンドでいくつかのバリエーションを使ってほぼ全てのRustプロジェクトを開始することが期待できます：

```bash
$ git clone someurl.com/foo
$ cd foo
$ cargo build
```

## 新しい貨物プロジェクトを簡単にする

新しいプロジェクトを開始するたびに、前のプロセスを終了する必要はありません。
貨物はすぐに開発を開始できるベアボーンのプロジェクトディレクトリをすぐに作ることができます。

Cargoで新規プロジェクトを開始するには、コマンドラインで`cargo new`入力します。

```bash
$ cargo new hello_world --bin
```

このコマンドは、ライブラリではなく、実行可能なアプリケーションを作成することを目的としているため、--`--bin`を`--bin`ます。
実行可能ファイルは、*バイナリ*と呼ばれることがよくあります（UNIXシステムの場合は、`/usr/bin`ように）。

Cargoは2つのファイルと1つのディレクトリを生成しています`Cargo.toml`と*src*ディレクトリに*main.rs*ファイルがあります。
これらはよく知られているはずです。

この出力は、始めに必要なものです。
まず、`Cargo.toml`開き`Cargo.toml`。
これは次のようになります。

```toml
[package]

name = "hello_world"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
```

`[dependencies]`行を心配しないで、後でそれに戻ります。

Cargoは、*Cargo.tomlに*与えた引数と`git`グローバル設定に基づいて、適切なデフォルト値を設定しています。
Cargoが`hello_world`ディレクトリを`git`リポジトリとして初期化していることに気付くかもしれません。

`src/main.rs`は何が必要ですか？

```rust
fn main() {
    println!("Hello, world!");
}
```

貨物は "ハローワールド！"を生成しました。
あなたのために、あなたはコーディングを開始する準備ができています！

> > 注：貨物をより詳細に見たい場合は、すべての機能をカバーする公式の[Cargo guide]を参照してください。

[Cargo guide]: http://doc.crates.io/guide.html

# 終わりの思考

この章では、この本の残りの部分で十分に役立つ基本と、Rustの残りの部分について説明しました。
ツールを手に入れたので、Rust言語そのものについて詳しく説明します。

2つの選択肢があります：「 [チュートリアル：ゲーム][guessinggame]の[推測][guessinggame] 」を使ってプロジェクトに潜入するか、下から始めて「 [構文とセマンティクス][syntax] 」で作業してください。
より経験豊富なシステムプログラマは、おそらく「チュートリアル：推測ゲーム」を好むでしょうが、動的な背景のプログラマもどちらかを楽しむことができます。
さまざまな人々が違った方法で学ぶ！
あなたに合ったものを選んでください。

[guessinggame]: guessing-game.html
 [syntax]: syntax-and-semantics.html

