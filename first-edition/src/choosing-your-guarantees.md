# 保証の選択

Rustの重要な特徴の1つは、プログラムのコストと保証を制御できることです。

さまざまな＆ldquo;ラッパータイプ＆rdquo;があります。
コスト、人間工学、および保証の間の多数のトレードオフを具現化するRust標準ライブラリの抽象化。
多くの場合、実行時とコンパイル時のどちらを選択するかを選択できます。
このセクションでは、いくつかの選択された抽象化について詳しく説明します。

先に進む前に、Rustの[ownership][ownership]と[borrowing][borrowing]について読むことを強くお勧めします。

[ownership]: ownership.html
 [borrowing]: references-and-borrowing.html


# 基本的なポインタ型

## `Box<T>`
[`Box<T>`][box]は＆ldquo;所有＆rdquo;
ポインタ、または＆ldquo;ボックス＆rdquo;
含まれているデータへの参照を渡すことはできますが、それはデータの唯一の所有者です。
特に、次の点を考慮してください。

```rust
let x = Box::new(1);
let y = x;
#// `x` is no longer accessible here.
//  `x`はここではアクセスできなくなりました。
```

ここでは、ボックスを`y`に _移動_ しました。
`x`はもはやそれを所有していないので、コンパイラはもはやプログラマがこれの後に`x`を使うことを許さないでしょう。
同様に、ボックスを返すことで、関数 _から_ ボックスを移動 _する_ ことができます。

移動されていないボックスが範囲外になると、デストラクタが実行されます。
これらのデストラクタは内部データの割り当てを解除します。

これは、動的割り当てのためのゼロコストの抽象化です。
ヒープ上にいくつかのメモリを割り当て、そのメモリへのポインタを安全に渡したい場合は、これが理想的です。
コンパイル時にチェックされる通常の借用ルールによってのみ、これへの参照を共有することができます。

[box]: ../../std/boxed/struct.Box.html

## `&T`と`&mut T`

これらはそれぞれ不変で変更可能な参照です。
それらは＆ldquo;読み書きロック＆rdquo;の後に続きます。
あるデータに対する1つの可変参照、または任意の数の不変の参照を持つことができますが、両方ではありません。
この保証はコンパイル時に強制され、実行時に表示されるコストはありません。
ほとんどの場合、これらの2つのポインタ型は、コードのセクション間で安価な参照を共有するのに十分です。

これらのポインタは、それらのポインタに関連付けられた存続期間を超えてコピーすることはできません。

## `*const T`と`*mut T`

これらは生涯や所有権がないCのような生ポインタです。
彼らは他の制限なしでメモリ内のある場所を指しています。
これらが提供する唯一の保証は、`unsafe`マークされたコードを除き、参照解除することができないことです。

これらは`Vec<T>`ような安全で低コストな抽象化を構築する場合には便利ですが、安全なコードでは避けるべきです。

## `Rc<T>`
これはランタイムコストを持つ最初のラッパーです。

[`Rc<T>`][rc]は参照カウントポインタである。
つまり、これにより、同じデータへの複数の「所有」ポインタを持つことができ、すべてのポインタが有効範囲外になるとデータが破棄されます（デストラクタが実行されます）。

内部的には、＆ldquo;参照カウントが共有されています。
`Rc`がクローンされるたびにインクリメントされ、`Rc`の1つが範囲外になるたびにデクリメントされます（＆ldquo; refcount＆rdquo;とも呼ばれます）。
`Rc<T>`の主な責任は、デストラクタが共有データのために呼び出されるようにすることです。

ここの内部データは不変であり、参照のサイクルが作成された場合、データはリークされます。
サイクルがあるときにリークしないデータが必要な場合は、ガベージコレクタが必要です。

#### 保証

ここで提供される主な保証は、データへのすべての参照が範囲外になるまでデータが破棄されないことです。

これは、プログラムのさまざまな部分の間でデータを動的に割り当てたり共有したりする場合に使用します。ポインタが最後に使用される部分がわからない場合は、この部分を使用してください。
これは、する実行可能な代案だ`&T` `&T`静的正しさを確認するためのいずれかに不可能である、またはプログラマが作業の開発コストを費やすしたくない極めてunergonomicコードを作成します。

このポインタはスレッドセーフでは _なく_ 、Rustは他のスレッドとの共有や共有を許可しません。
これにより、不要な状況でのアトミックスのコストを回避できます。

これに姉妹のスマートポインタ`Weak<T>`ます。
これは所有していないが、借りていないスマートポインタです。
また、`&T`と似ていますが、生涯に制限されず、`Weak<T>`が永遠に保持されます。
しかし、内部データにアクセスしようとする試みが失敗し、`None`返される可能性があります。これは、所有されている`Rc`よりも長くなる可能性があるためです。
これは、周期的なデータ構造などに役立ちます。

#### コスト

メモリが移動する限り、`Rc<T>`は単一の割り当てですが、通常の`Box<T>`（ "強い"と "弱い"参照）と比べて2つの余分な単語（つまり2つの`usize`値）を`usize`ます。

`Rc<T>`は、それがクローンされるかまたはスコープ外になるたびに、refcountをインクリメント/デクリメントする計算コストを有する。
クローンはディープコピーを行いません。内部参照カウントをインクリメントして`Rc<T>`コピーを返します。

[rc]: ../../std/rc/struct.Rc.html

# 細胞の種類

`Cell`は内部の変異性を提供する。
言い換えれば、型が変更可能な形式で取得できない場合でも（たとえば、`&` ptrまたは`Rc<T>`後ろにある場合など）、操作できるデータが含まれています。

[`cell`モジュールのドキュメントには、これらの説明があります][cell-mod]。

これらの型は _一般_ に構造体フィールドにありますが、他の場所にもあります。

## `Cell<T>`
[`Cell<T>`][cell]は、セルの内外にデータを移動することによってゼロコストの内部の変更可能性を提供する型です。
コンパイラは、格納された値が所有するすべてのデータがスタック上にあることを知っているので、単にデータを置き換えるだけで、参照の背後にあるデータが漏れる（または悪化する）心配はありません。

このラッパーを使用して独自のインバリアントに違反する可能性があるので、使用する際は注意してください。
フィールドが`Cell`にラップされている場合は、データのチャンクが変更可能であり、最初に読み込んだときから使用する予定までの間に変更されないという良い指標です。

```rust
use std::cell::Cell;

let x = Cell::new(1);
let y = &x;
let z = &x;
x.set(2);
y.set(3);
z.set(4);
println!("{}", x.get());
```

ここでは、さまざまな不変参照から同じ値を変更することができたことに注意してください。

これは以下のランタイムコストと同じです：

```rust,ignore
let mut x = 1;
let y = &mut x;
let z = &mut x;
x = 2;
*y = 3;
*z = 4;
println!("{}", x);
```

実際に正常にコンパイルするという利点があります。

#### 保証

これにより、＆ldquo; mutability＆rdquoのエイリアシングが緩和されます。
それが不要な場所での制限。
ただし、これにより、制限によって提供される保証が緩和されます。
したがって、invariantが`Cell`内に格納されたデータに依存する場合は、注意が必要です。

これは、`&`と`&mut`静的規則に沿って簡単に行うことができない場合に、プリミティブやその他の型を変更する場合に便利です。

`Cell`は、データへの内部参照を取得することはできません。自由に変異させることができます。

#### コスト

`Cell<T>`を使用するためのランタイム・コストはありませんが、より大きな構造体をラップするために使用している場合は、`Cell<T>`内の個々のフィールドをラップする代わりに、各書き込みが構造体のフル・コピーであるため、


## `RefCell<T>`
[`RefCell<T>`][refcell]は内部の[`RefCell<T>`][refcell]も提供しますが、セル内外のデータは移動しません。

ただし、ランタイムコストがあります。
`RefCell<T>`は、コンパイル時に実行する`&T` / `&mut T`とは異なり、実行時に読み書き可能なロックパターンを強制します（単一スレッドのミューテックスのようなものです）。
これは`borrow_mut()` `borrow()`と`borrow_mut()`関数によって行われ、内部参照カウントを変更してスマートポインタを返します。これらのスマートポインタはそれぞれ参照不可能で可変的に変更可能です。
スマートポインタが範囲外になると、refcountが復元されます。
このシステムでは、変更可能な借用がアクティブなときに他の借用がアクティブでないことを動的に保証することができます。
プログラマーがそのような借用をしようとすると、スレッドはパニックに陥ります。

```rust
use std::cell::RefCell;

let x = RefCell::new(vec![1,2,3,4]);
{
    println!("{:?}", *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
```

`Cell`と同様に、これは主に借用チェッカーを満たすことが困難または不可能な状況で役に立ちます。
一般的に、このような突然変異はネストされた形では起こりませんが、確認するのは良いことです。

大規模で複雑なプログラムの場合、`RefCell`にいくつかの事柄を入れて物事をより簡単にすることが有用になります。
たとえば、Rustコンパイラ内部の`ctxt`構造体のマップの多くは、このラッパーの内側にあります。
これらは一度だけ（作成中は初期化直後ではない）一度変更されるか、または十分に離れた場所で数回修正されます。
しかし、この構造体はどこにでも普遍的に使用されているので、変更可能なポインタと変更不能なポインタを扱うのは難しいかもしれません（たぶん不可能です）。おそらく拡張が困難な`&` -ptrのスープを形成します。
一方、`RefCell`は安価な（ゼロコストではない）方法でこれらに安全にアクセスします。
将来、誰かがすでに借用しているときにセルを修正しようとするコードを追加した場合、それは原因となる借りにさかのぼることができる（通常は確定的な）パニックを引き起こします。

同様にServoのDOMには多くの変異がありますが、その大部分はDOM型の局所ですが、DOMの中には十字架があり、さまざまなものが変更されています。
`RefCell`と`Cell`を使用してすべての変異を守ることで、あらゆる場所での変異の心配を避けることができ、突然変異が _実際に_ 起こっている場所を同時にハイライトすることができます。

`&`ポインタを使ってほとんど単純な解決策が可能な場合、`RefCell`は避けるべきです。

#### 保証

`RefCell`は、エイリアシングされた変異を防ぐ _静的な_ 制限を緩和し、それらを _動的な_ ものに置き換えます。
そのような保証は変更されていません。

#### コスト

`RefCell`は`RefCell`ませんが、データとともに、追加の「ボロー状態」インジケーター（サイズは1ワード）が含まれています。

実行時に、それぞれの借り入れによって参照カウントの変更/チェックが行われます。

[cell-mod]: ../../std/cell/index.html
 [cell]: ../../std/cell/struct.Cell.html
 [refcell]: ../../std/cell/struct.RefCell.html
 [cell]: ../../std/cell/struct.Cell.html


# 同期型

上記のタイプの多くは、スレッドセーフな方法で使用することはできません。
特に、非原子参照カウント（ _原子_ 参照カウントはデータ競合を引き起こすことなく複数のスレッドからインクリメントできるもの）を使用する`Rc<T>`および`RefCell<T>`、このように使用することはできません。
これにより、使用するのが安くなりますが、スレッドセーフなバージョンも必要になります。
それらは、`Arc<T>`および`Mutex<T>` / `RwLock<T>`の形で存在し、

スレッドセーフで _はない_ タイプ _は_ スレッド間で送信 _できない_ ことに注意してください。これはコンパイル時にチェックされます。

[sync][sync]モジュールの並列プログラミングには多くの有用なラッパーがありますが、主要なものだけを以下で説明します。

[sync]: ../../std/sync/index.html

## `Arc<T>`
[`Arc<T>`][arc]は原子参照カウント（したがって "Arc"）を使用する`Rc<T>`バージョンです。
これはスレッド間で自由に送信できます。

C ++の`shared_ptr`は`Arc`と似ていますが、C ++の場合、内部データは常に変更可能です。
`Arc<Mutex<T>>`、 `Arc<RwLock<T>>`、または`Arc<UnsafeCell<T>>` [^4]使用する必要があります（`UnsafeCell<T>`は、使用可能なセルタイプですデータを保持し、実行時コストはありませんが、アクセスには`unsafe`ブロックが必要です）。
最後のものは、その使用がメモリー不足の原因とならないことが確かな場合にのみ使用してください。
構造体への書き込みはアトミックな操作ではなく、`vec.push()`などの多くの関数は内部的に再割り当てして安全でない動作を引き起こすことがあるので、単調性でさえ`UnsafeCell`を正当化するには不十分かもしれません。

[^4]: %60Arc%3CUnsafeCell%3CT%3E%3E%60%20actually%20won't%20compile%20since%20%60UnsafeCell%3CT%3E%60%20isn't%20%60Send%60%20or%20%60Sync%60,%20but%20we%20can%20wrap%20it%20in%20a%20type%20and%20implement%20%60Send%60/%60Sync%60%20for%20it%20manually%20to%20get%20%60Arc%3CWrapper%3CT%3E%3E%60%20where%20%60Wrapper%60%20is%20%60struct%20Wrapper%3CT%3E(UnsafeCell%3CT%3E)%60.

#### 保証

`Rc`と同様に、これは、最後の`Arc`がスコープ外に出たとき（内部サイクルを除く）、内部データのデストラクタが実行される（スレッドセーフである）ことを保証します。

#### コスト

これは、参照カウントを変更するためにアトミックを使用するコストが追加されます（クローンが作成されるかスコープ外になるたびに発生します）。
以下からのデータを共有するときに`Arc`シングルスレッドでは、共有することが好ましい`&`できるだけポインタ。

[arc]: ../../std/sync/struct.Arc.html

## `Mutex<T>`および`RwLock<T>`

[`Mutex<T>`][mutex]と[`RwLock<T>`][rwlock]は、RAIIガード（ガードは、デストラクタが呼び出されるまでロックのような状態を維持するオブジェクトです）を介して相互排除を提供します。
どちらの場合でも、mutexは`lock()`を呼び出すまでは不透明で、ロックが獲得できるまでスレッドはブロックし、ガードが返されます。
このガードを使用して内側のデータにアクセスすることができ（変更可能）、ガードが有効範囲外になるとロックが解除されます。

```rust,ignore
{
    let guard = mutex.lock();
#    // `guard` dereferences mutably to the inner type.
    // 内側の型に変更可能なdereferencesを`guard`ます。
    *guard += 1;
#//} // Lock is released when destructor runs.
} // ロックは、デストラクタが実行されるときに解放されます。
```


`RwLock`は、複数の読み取りに効率的であるという利点があります。
ライターがいない限り、共有データに複数のリーダーを置くことは常に安全です。
`RwLock`使用すると、読者は「読み取りロック」を取得できます。
このようなロックは同時に取得することができ、参照カウントによって追跡することができます。
ライターは、すべての読者が範囲外になった場合にのみ得られる「書込みロック」を取得する必要があります。

#### 保証

これらの両方は、スレッド間で安全な共有の変更を提供しますが、デッドロックが発生しやすくなります。
タイプ・システムを介して、あるレベルの追加のプロトコル安全性を得ることができる。

#### コスト

これらは内部原子型の型を使用してロックを維持しますが、これは非常にコストがかかります（処理が完了するまですべてのメモリ読み込みをプロセッサ間でブロックすることができます）。
並行アクセスが頻繁に発生すると、これらのロックの待機も遅くなる可能性があります。

[rwlock]: ../../std/sync/struct.RwLock.html
 [mutex]: ../../std/sync/struct.Mutex.html
 [sessions]: https://github.com/Munksgaard/rust-sessions


# 組成

錆コードを読み取るときの一般的な不満は、`Rc<RefCell<Vec<T>>>`（またはそのようなタイプのさらに複雑な構成）のようなタイプです。
コンポジションが何をしているのか、作者がこのようなものを選んだ理由（そして自分自身のコードでそのようなコンポジションを使用する必要がある場合）

通常、不要なものを払うことなく、必要な保証を一緒に構成することがあります。

例えば、`Rc<RefCell<T>>`はそのような構成の1つである。
`Rc<T>`自体は、逆参照することはできません。
`Rc<T>`は共有を提供し、共有の変更は安全ではない動作につながる可能性があるため、内部で`RefCell<T>`を動的に検証された共有の変更可能にします。
ここでは、変更可能なデータを共有しましたが、ミューテータが1つだけ（および読者なし）または複数の読者のみが存在するように共有されています。

これをさらに進めて、`Rc<RefCell<Vec<T>>>`または`Rc<Vec<RefCell<T>>>`ます。
これらは共有可能な可変ベクトルですが、同じではありません。

前者の場合、`RefCell<T>`は`Vec<T>`ラッピングしているため、`Vec<T>`全体が変更可能です。
同時に、`Vec`全体を一度に1つだけ変更することができます。
これは、コードが異なる`Rc`ハンドルからのベクトルの異なる要素で同時に動作できないことを意味します。
しかし、私たちは`Vec<T>`を押すことができます。
これは実行時に借用チェックが行われる`&mut Vec<T>`似ています。

後者の場合、借用は個々の要素で行われますが、全体のベクトルは不変です。
したがって、独立した要素を別々に借りることはできますが、ベクトルからプッシュまたはポップすることはできません。
これは`&mut [T]` [^3]と似ていますが、もう一度、借用チェックは実行時に行われます。

並行プログラムでは、`Arc<Mutex<T>>`と同様の状況があります。これは、共有の変更と所有権を提供します。

これらを使用するコードを読むときは、段階的に進み、提供された保証/コストを見てください。

複合型を選択するときは、その逆を行う必要があります。
私たちが望む保証と、それが必要な構成のどの時点であるかを把握します。
たとえば、`Vec<RefCell<T>>`と`RefCell<Vec<T>>`間に選択肢がある場合は、上記のようにトレードオフを把握して選択する必要があります。

[^3]: %60&%5BT%5D%60%20and%20%60&mut%20%5BT%5D%60%20are%20_slices_;%20they%20consist%20of%20a%20pointer%20and%20a%20length%20and%20can%20refer%20to%20a%20portion%20of%20a%20vector%20or%20array.%20%60&mut%20%5BT%5D%60%20can%20have%20its%20elements%20mutated,%20however%20its%20length%20cannot%20be%20touched.
