# 保証の選択

Rustの重要な特徴の1つは、算譜のコストと保証を制御できることです。

さまざまな＆ldquo;の包み型＆rdquo;があります。
コスト、使いやすさ、および保証の間の多数の相殺取引を具現化するRust標準譜集の抽象化。
多くの場合、実行時と製譜時のどちらを選択するかを選択できます。
この章では、いくつかの選択された抽象化について詳しく説明します。

先に進む前に、Rustの[ownership][ownership]と[borrowing][borrowing]について読むことを強くお勧めします。

[ownership]: ownership.html
 [borrowing]: references-and-borrowing.html


# 基本的な指し手型

## `Box<T>`
[`Box<T>`][box]は＆ldquo;所有＆rdquo;
指し手、または＆ldquo;ボックス＆rdquo;
含まれているデータへの参照を渡すことはできますが、それはデータの唯一の所有者です。
特に、次の点を考慮してください。

```rust
let x = Box::new(1);
let y = x;
#// `x` is no longer accessible here.
//  `x`はここではアクセスできなくなりました。
```

ここでは、ボックスを`y`に _移動_ しました。
`x`はもはやそれを所有していないので、製譜器はもはや演譜師がこれの後に`x`を使うことを許さないでしょう。
同様に、ボックスを返すことで、機能 _から_ ボックスを移動 _する_ ことができます。

移動されていないボックスが範囲外になると、破棄子が実行されます。
これらの破棄子は内部データの割り当てを解除します。

これは、動的割り当てのためのゼロコストの抽象化です。
原上にいくつかの記憶を割り当て、その記憶への指し手を安全に渡したい場合は、これが理想的です。
製譜時にチェックされる通常の借用ルールによってのみ、これへの参照を共有することができます。

[box]: ../../std/boxed/struct.Box.html

## `&T`と`&mut T`

これらはそれぞれ不変で変更可能な参照です。
それらは＆ldquo;読み書きロック＆rdquo;の後に続きます。
あるデータに対する1つの可変参照、または任意の数の不変の参照を持つことができますが、両方ではありません。
この保証は製譜時に強制型変換され、実行時に表示されるコストはありません。
ほとんどの場合、これらの2つの指し手型は、譜面の章間で安価な参照を共有するのに十分です。

これらの指し手は、それらの指し手に関連付けられた存続期間を超えてコピーすることはできません。

## `*const T`と`*mut T`

これらは寿命や所有権がないCのような生指し手です。
それらは他の制限なしで記憶内のある場所を指しています。
これらが提供する唯一の保証は、`unsafe`マークされた譜面を除き、参照解除することができないことです。

これらは`Vec<T>`ような安全で低コストな抽象化を構築する場合には便利ですが、安全な譜面では避けるべきです。

## `Rc<T>`
これは実行時コストを持つ最初のの包みです。

[`Rc<T>`][rc]は参照カウント指し手であます。
つまり、これにより、同じデータへの複数の「所有」指し手を持つことができ、すべての指し手が有効範囲外になるとデータが破棄されます（破棄子が実行されます）。

内部的には、＆ldquo;参照カウントが共有されています。
`Rc`がクローンされるたびに増分され、`Rc`の1つが範囲外になるたびに減分されます（＆ldquo; refcount＆rdquo;とも呼ばれます）。
`Rc<T>`の主な責任は、破棄子が共有データのために呼び出されるようにすることです。

ここの内部データは不変であり、参照の円環が作成された場合、データはリークされます。
円環があるときにリークしないデータが必要な場合は、ごみ集め部が必要です。

#### 保証

ここで提供される主な保証は、データへのすべての参照が範囲外になるまでデータが破棄されないことです。

これは、算譜のさまざまな部分の間でデータを動的に割り当てたり共有したりする場合に使用します。指し手が最後に使用される部分がわからない場合は、この部分を使用してください。
これは、する実行可能な代案だ`&T` `&T`静的正しさを確認するためのいずれかに不可能である、または演譜師が作業の開発コストを費やすしたくない極めてunergonomic譜面を作成します。

この指し手は走脈セーフでは _なく_ 、Rustは他の走脈との共有や共有を許可しません。
これにより、不要な状況でのアトミックスのコストを回避できます。

これに姉妹のスマート指し手`Weak<T>`ます。
これは所有していないが、借りていないスマート指し手です。
また、`&T`と似ていますが、寿命に制限されず、`Weak<T>`が永遠に保持されます。
しかし、内部データにアクセスしようとする試みが失敗し、`None`返される可能性があります。これは、所有されている`Rc`よりも長くなる可能性があるためです。
これは、周期的なデータ構造などに役立ちます。

#### コスト

記憶が移動する限り、`Rc<T>`は単一の割り当てですが、通常の`Box<T>`（ "強い"と "弱い"参照）と比べて2つの余分な単語（つまり2つの`usize`値）を`usize`ます。

`Rc<T>`は、それがクローンされるかまたは有効範囲外になるたびに、refcountを増分/減分する計算コストを有します。
クローンはディープコピーを行いません。内部参照カウントを増分して`Rc<T>`コピーを返します。

[rc]: ../../std/rc/struct.Rc.html

# 細胞の種類

`Cell`は内部の可変性を提供します。
言い換えれば、型が変更可能な形式で取得できない場合でも（たとえば、`&` ptrまたは`Rc<T>`後ろにある場合など）、操作できるデータが含まれています。

[`cell`役区の開発資料には、これらの説明があります][cell-mod]。

これらの型は _一般_ に構造体欄にありますが、他の場所にもあります。

## `Cell<T>`
[`Cell<T>`][cell]は、セルの内外にデータを移動することによってゼロコストの内部の変更可能性を提供する型です。
製譜器は、格納された値が所有するすべてのデータが山上にあることを知っているので、単にデータを置き換えるだけで、参照の背後にあるデータが漏れる（または悪化する）心配はありません。

このの包みを使用して独自の不変条件に違反する可能性があるので、使用する際は注意してください。
欄が`Cell`に包まれている場合は、データのチャンクが変更可能であり、最初に読み込んだときから使用する予定までの間に変更されないという良い指標です。

```rust
use std::cell::Cell;

let x = Cell::new(1);
let y = &x;
let z = &x;
x.set(2);
y.set(3);
z.set(4);
println!("{}", x.get());
```

ここでは、さまざまな不変参照から同じ値を変更することができたことに注意してください。

これは以下の実行時コストと同じです。

```rust,ignore
let mut x = 1;
let y = &mut x;
let z = &mut x;
x = 2;
*y = 3;
*z = 4;
println!("{}", x);
```

実際に正常に製譜するという利点があります。

#### 保証

これにより、＆ldquo; mutability＆rdquoの別名付与が緩和されます。
それが不要な場所での制限。
ただし、これにより、制限によって提供される保証が緩和されます。
したがって、invariantが`Cell`内に格納されたデータに依存する場合は、注意が必要です。

これは、`&`と`&mut`静的規則に沿って簡単に行うことができない場合に、基本型やその他の型を変更する場合に便利です。

`Cell`は、データへの内部参照を取得することはできません。自由に変更させることができます。

#### コスト

`Cell<T>`を使用するための実行時・コストはありませんが、より大きな構造体を包むために使用している場合は、`Cell<T>`内の個々の欄を包む代わりに、各書き込みが構造体のフル・コピーであるため、


## `RefCell<T>`
[`RefCell<T>`][refcell]は内部の[`RefCell<T>`][refcell]も提供しますが、セル内外のデータは移動しません。

ただし、実行時コストがあります。
`RefCell<T>`は、製譜時に実行する`&T` / `&mut T`とは異なり、実行時に読み書き可能なロックパターンを強制型変換します（単一走脈のミューテックスのようなものです）。
これは`borrow_mut()` `borrow()`と`borrow_mut()`機能によって行われ、内部参照カウントを変更してスマート指し手を返します。これらのスマート指し手はそれぞれ参照不可能で可変的に変更可能です。
スマート指し手が範囲外になると、refcountが復元されます。
このシステムでは、変更可能な借用がアクティブなときに他の借用がアクティブでないことを動的に保証することができます。
演譜師がそのような借用をしようとすると、走脈はパニックに陥ります。

```rust
use std::cell::RefCell;

let x = RefCell::new(vec![1,2,3,4]);
{
    println!("{:?}", *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
```

`Cell`と同様に、これは主に借用検査器を満たすことが困難または不可能な状況で役に立ちます。
一般的に、このような変更は入れ子になった形では起こりませんが、確認するのは良いことです。

大規模で複雑な算譜の場合、`RefCell`にいくつかの事柄を入れて物事をより簡単にすることが有用になります。
たとえば、Rust製譜器内部の`ctxt`構造体のマップの多くは、このの包みの内側にあります。
これらは一度だけ（作成中は初期化直後ではない）一度変更されるか、または十分に離れた場所で数回修正されます。
しかし、この構造体はどこにでも普遍的に使用されているので、変更可能な指し手と変更不能な指し手を扱うのは難しいかもしれません（たぶん不可能です）。おそらく拡張が困難な`&` -ptrのスープを形成します。
一方、`RefCell`は安価な（ゼロコストではない）方法でこれらに安全にアクセスします。
将来、誰かがすでに借用しているときにセルを修正しようとする譜面を追加した場合、それは原因となる借用にさかのぼることができる（通常は確定的な）パニックを引き起こします。

同様にServoのDOMには多くの変更がありますが、その大部分はDOM型の局所ですが、DOMの中には十字架があり、さまざまなものが変更されています。
`RefCell`と`Cell`を使用してすべての変更を守ることで、あらゆる場所での変更の心配を避けることができ、変更が _実際に_ 起こっている場所を同時にハイライトすることができます。

`&`指し手を使ってほとんど単純な解決策が可能な場合、`RefCell`は避けるべきです。

#### 保証

`RefCell`は、別名付与された変更を防ぐ _静的な_ 制限を緩和し、それらを _動的な_ ものに置き換えます。
そのような保証は変更されていません。

#### コスト

`RefCell`は`RefCell`ませんが、データとともに、追加の「ボロー状態」インジケーター（サイズは1ワード）が含まれています。

実行時に、それぞれの借用入れによって参照カウントの変更/チェックが行われます。

[cell-mod]: ../../std/cell/index.html
 [cell]: ../../std/cell/struct.Cell.html
 [refcell]: ../../std/cell/struct.RefCell.html
 [cell]: ../../std/cell/struct.Cell.html


# 同期型

上記の型の多くは、走脈セーフな方法で使用することはできません。
特に、非原子参照カウント（ _原子_ 参照カウントはデータ競合を引き起こすことなく複数の走脈から増分できるもの）を使用する`Rc<T>`および`RefCell<T>`、このように使用することはできません。
これにより、使用するのが安くなりますが、走脈セーフな版も必要になります。
それらは、`Arc<T>`および`Mutex<T>` / `RwLock<T>`の形で存在し、

走脈セーフで _はない_ 型 _は_ 走脈間で送信 _できない_ ことに注意してください。これは製譜時にチェックされます。

[sync][sync]役区の並列演譜には多くの有用なの包みがありますが、主要なものだけを以下で説明します。

[sync]: ../../std/sync/index.html

## `Arc<T>`
[`Arc<T>`][arc]は原子参照カウント（したがって "Arc"）を使用する`Rc<T>`版です。
これは走脈間で自由に送信できます。

C ++の`shared_ptr`は`Arc`と似ていますが、C ++の場合、内部データは常に変更可能です。
`Arc<Mutex<T>>`、 `Arc<RwLock<T>>`、または`Arc<UnsafeCell<T>>` [^4]使用する必要があります（`UnsafeCell<T>`は、使用可能なセル型ですデータを保持し、実行時コストはありませんが、アクセスには`unsafe`段落が必要です）。
最後のものは、その使用が記憶不足の原因とならないことが確かな場合にのみ使用してください。
構造体への書き込みは瞬間的な操作ではなく、`vec.push()`などの多くの機能は内部的に再割り当てして安全でない動作を引き起こすことがあるので、単調性でさえ`UnsafeCell`を正当化するには不十分かもしれません。

[^4]: %60Arc%3CUnsafeCell%3CT%3E%3E%60%20actually%20won't%20compile%20since%20%60UnsafeCell%3CT%3E%60%20isn't%20%60Send%60%20or%20%60Sync%60,%20but%20we%20can%20wrap%20it%20in%20a%20type%20and%20implement%20%60Send%60/%60Sync%60%20for%20it%20manually%20to%20get%20%60Arc%3CWrapper%3CT%3E%3E%60%20where%20%60Wrapper%60%20is%20%60struct%20Wrapper%3CT%3E(UnsafeCell%3CT%3E)%60.

#### 保証

`Rc`と同様に、これは、最後の`Arc`が有効範囲外に出たとき（内部円環を除く）、内部データの破棄子が実行される（走脈セーフである）ことを保証します。

#### コスト

これは、参照カウントを変更するためにアトミックを使用するコストが追加されます（クローンが作成されるか有効範囲外になるたびに発生します）。
以下からのデータを共有するときに`Arc`単一走脈では、共有することが好ましい`&`できるだけ指し手。

[arc]: ../../std/sync/struct.Arc.html

## `Mutex<T>`および`RwLock<T>`

[`Mutex<T>`][mutex]と[`RwLock<T>`][rwlock]は、RAIIガード（ガードは、破棄子が呼び出されるまでロックのような状態を維持する対象です）を介して相互排除を提供します。
どちらの場合でも、mutexは`lock()`を呼び出すまでは目隠しで、ロックが獲得できるまで走脈は段落し、ガードが返されます。
このガードを使用して内側のデータにアクセスすることができ（変更可能）、ガードが有効範囲外になるとロックが解除されます。

```rust,ignore
{
    let guard = mutex.lock();
#    // `guard` dereferences mutably to the inner type.
    // 内側の型に変更可能なdereferencesを`guard`ます。
    *guard += 1;
#//} // Lock is released when destructor runs.
} // ロックは、破棄子が実行されるときに解放されます。
```


`RwLock`は、複数の読み取りに効率的であるという利点があります。
ライターがいない限り、共有データに複数のリーダーを置くことは常に安全です。
`RwLock`使用すると、読者は「読み取りロック」を取得できます。
このようなロックは同時に取得することができ、参照カウントによって追跡することができます。
ライターは、すべての読者が範囲外になった場合にのみ得られる「書込みロック」を取得する必要があります。

#### 保証

これらの両方は、走脈間で安全な共有の変更を提供しますが、デッドロックが発生しやすくなります。
型・システムを介して、あるレベルの追加の約束事安全性を得ることができます。

#### コスト

これらは内部原子型の型を使用してロックを維持しますが、これは非常にコストがかかります（処理が完了するまですべての記憶読み込みをプロセッサ間で段落することができます）。
並行アクセスが頻繁に発生すると、これらのロックの待機も遅くなる可能性があります。

[rwlock]: ../../std/sync/struct.RwLock.html
 [mutex]: ../../std/sync/struct.Mutex.html
 [sessions]: https://github.com/Munksgaard/rust-sessions


# 組成

Rust譜面を読み取るときの一般的な不満は、`Rc<RefCell<Vec<T>>>`（またはそのような型のさらに複雑な構成）のような型です。
コンポジションが何をしているのか、作者がこのようなものを選んだ理由（そして自分自身の譜面でそのようなコンポジションを使用する必要がある場合）

通常、不要なものを払うことなく、必要な保証を一緒に構成することがあります。

例えば、`Rc<RefCell<T>>`はそのような構成の1つであます。
`Rc<T>`自体は、逆参照することはできません。
`Rc<T>`は共有を提供し、共有の変更は安全ではない動作につながる可能性があるため、内部で`RefCell<T>`を動的に検証された共有の変更可能にします。
ここでは、変更可能なデータを共有しましたが、変更者が1つだけ（および読者なし）または複数の読者のみが存在するように共有されています。

これをさらに進めて、`Rc<RefCell<Vec<T>>>`または`Rc<Vec<RefCell<T>>>`ます。
これらは共有可能な可変ベクトルですが、同じではありません。

前者の場合、`RefCell<T>`は`Vec<T>`ラッピングしているため、`Vec<T>`全体が変更可能です。
同時に、`Vec`全体を一度に1つだけ変更することができます。
これは、譜面が異なる`Rc`手綱からのベクトルの異なる要素で同時に動作できないことを意味します。
しかし、`Vec<T>`を押すことができます。
これは実行時に借用チェックが行われる`&mut Vec<T>`似ています。

後者の場合、借用は個々の要素で行われますが、全体のベクトルは不変です。
したがって、独立した要素を別々に借りることはできますが、ベクトルからプッシュまたはポップすることはできません。
これは`&mut [T]` [^3]と似ていますが、もう一度、借用チェックは実行時に行われます。

並行算譜では、`Arc<Mutex<T>>`と同様の状況があります。これは、共有の変更と所有権を提供します。

これらを使用する譜面を読むときは、段階的に進み、提供された保証/コストを見てください。

複合型を選択するときは、その逆を行う必要があります。
望む保証と、それが必要な構成のどの時点であるかを把握します。
たとえば、`Vec<RefCell<T>>`と`RefCell<Vec<T>>`間に選択肢がある場合は、上記のように相殺取引を把握して選択する必要があります。

[^3]: %60&%5BT%5D%60%20and%20%60&mut%20%5BT%5D%60%20are%20_slices_;%20they%20consist%20of%20a%20pointer%20and%20a%20length%20and%20can%20refer%20to%20a%20portion%20of%20a%20vector%20or%20array.%20%60&mut%20%5BT%5D%60%20can%20have%20its%20elements%20mutated,%20however%20its%20length%20cannot%20be%20touched.
