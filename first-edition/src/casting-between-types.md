# タイプ間のキャスト

錆は、安全性に重点を置いて、お互いに異なる種類のキャストに2つの異なる方法を提供します。
、最初`as`、安全なキャストのためです。
対照的に、`transmute`は任意のキャスティングを可能にし、Rustの最も危険な機能の1つです！

# 強制

タイプ間の強制は暗黙的であり、独自の構文はありませんが、[`as`](#explicit-coercions)で綴ることができます。

強制は`let`、 `const`、および`static`文で行われます。
関数呼び出しの引数。
構造体初期化のフィールド値
関数の結果に含まれます。

強制の最も一般的なケースは、参照からの変更を取り除くことです：

* `&mut T`から`&T`への`&mut T`

類似の変換は、[生ポインタ](raw-pointers.html)からの変更を取り除くことです：

* `*mut T`から`*const T`

参照は生ポインタに強制することもできます：

* `&T`から`*const T`

* `&mut T`から`*mut T`

カスタム変換は、[`Deref`](deref-coercions.html)を使用して定義できます。

強制は推移的です。

# `as`
`as`キーワードは安全なキャストを行います：

```rust
let x: i32 = 5;

let y = x as i64;
```

安全なキャストには、明示的な変換、数値型間のキャスト、およびポインタキャストの3つの主要なカテゴリがあります。

キャスティングは推移的ではありません。たとえ`e as U1 as U2`が有効な式であっても、`e as U2`は必ずしもそうである必要はありません（`U1`が`U2`強制する場合にのみ有効です）。


## 明示的な変換

キャスト`e as U`あれば有効である`e`型が`T`と`T`に*強制的に変換* `U`。

## 数値キャスト

`e as U`のキャスト`e as U`は、以下のいずれの場合にも有効です。

* `e`は`T`型を持ち、`T`と`U`は任意の数値型です。
   *数字キャスト*
* `e`は、バリアントにデータが添付されていない列挙型（「フィールドレス列挙」）であり、`U`は整数型です。
   *列挙型*
* `e`は`bool`または`char`型を持ち、`U`は整数型です。
   *プリムキャスト*
* `e`は`u8`型、`U`は`char`型です。
   *u8-char-cast*

例えば

```rust
let one = true as u8;
let at_sign = 64 as char;
let two_hundred = -56i8 as u8;
```

数値キャストのセマンティクスは次のとおりです。

* 同じサイズの2つの整数間のキャスト（例：i32 -> u32）はノーオペレーションです
* 大きな整数から小さな整数（例えば、u32 -> u8）へのキャスティングは、切り詰められます
* 小さな整数から大きな整数へのキャスト（例：u8 -> u32）
    * ソースが符号なしの場合はゼロ拡張
    * ソースが署名されている場合は符号拡張する
* 浮動小数点から整数へのキャストは浮動小数点をゼロに向かって丸めます
    * **[注記：現在、丸められた値をターゲット整数型で表現できない場合、未定義の振る舞いが発生します] [float-int]**。
       これには、InfとNaNが含まれます。
       これはバグであり修正される予定です。
* 整数から浮動小数点へのキャストは、必要に応じて丸められた整数の浮動小数点表現を生成します（丸め戦略は指定されていません）
* f32からf64へのキャストは完璧でロスレスです
* f64からf32へのキャストは、可能な限り近い値を生成します（丸め戦略は指定されていません）
    * **[注記：現在、値が有限であるが、f32で表現可能な最大または最小の有限値より大きいまたは小さい場合は、未定義動作が発生します**。 **[float-float]**
       これはバグであり修正される予定です。

[float-int]: https://github.com/rust-lang/rust/issues/10184
 [float-float]: https://github.com/rust-lang/rust/issues/15536


## ポインタキャスト

おそらく驚くべきことに、整数との間で[生ポインタ](raw-pointers.html)をキャストしたり、いくつかの制約のもとで異なる型へのポインタ間でキャストすることは安全です。
ポインタを逆参照することは危険です。

```rust
#//let a = 300 as *const char; // `a` is a pointer to location 300.
let a = 300 as *const char; //  `a`は位置300へのポインタです。
let b = a as u32;
```

`e as U`は、次のいずれかの場合に有効なポインタキャストです。

* `e`はタイプ`*T`を持ち、`U`はタイプ`*U_0`を持ち、`U_0: Sized`または`unsize_kind(T) == unsize_kind(U_0)`。
   *ptr-ptr-cast*

* `e`はタイプ`*T`持ち、`U`は数値タイプ、`T: Sized`です。
   *ptr-addr-cast*

* `e`は整数であり、`U`は`*U_0`であり、`U_0: Sized`。
   *addr-ptr-cast*

* `e`は`&[T; n]`
   `&[T; n]`あり、`U`は`*const T`。
   *配列-ptrキャスト*

* `e`は関数ポインタ型であり、`U`は`*T`型を持ち、`T: Sized`。
   *fptr-ptr-cast*

* `e`は関数ポインタ型であり、`U`は整数です。
   *fptr-addr-cast*


# `transmute`
唯一の安全なキャストを可能にし、例えば意志に4つのバイトをキャストしようとすると拒否`u32`：

```rust,ignore
let a = [0u8, 0u8, 0u8, 0u8];

#//let b = a as u32; // Four u8s makes a u32.
let b = a as u32; //  4つのu8はu32を作ります。
```

このエラーは、

```text
error: non-scalar cast: `[u8; 4]` as `u32`
#//let b = a as u32; // Four u8s makes a u32.
let b = a as u32; //  4つのu8はu32を作ります。
        ^~~~~~~~
```

これは、配列の4つの要素である複数の値を持つため、非スカラーキャストです。
これらの種類のキャストは、複数の基本構造が実装される方法について前提を定めているため、非常に危険です。
このためには、もっと危険なものが必要です。

`transmute`機能は非常にシンプルですが、非常に怖いです。
1つのタイプの値を別のタイプのように扱うようにRustに指示します。
それは型検査システムに関係なくこれを行い、完全にあなたを信頼します。

前の例では、4つの`u8`の配列が正しく`u32`表していることを知っています。したがって、キャストを行いたいと思います。
`as`代わりに`transmute`使うと、Rustは次のようになります：

```rust
use std::mem;

fn main() {
    unsafe {
        let a = [0u8, 1u8, 0u8, 0u8];
        let b = mem::transmute::<[u8; 4], u32>(a);
#//        println!("{}", b); // 256
        println!("{}", b); //  256
#        // Or, more concisely:
        // または、より簡潔に：
        let c: u32 = mem::transmute(a);
#//        println!("{}", c); // 256
        println!("{}", c); //  256
    }
}
```

これを正常にコンパイルするには、`unsafe`ブロックで操作をラップする必要があります。
技術的には、`mem::transmute`コールだけがブロック内に存在する必要がありますが、この場合は関連するすべてを囲むのがいいので、どこを見るか分かります。
この場合、`a`の詳細も重要なので、ブロック内にあります。
どちらのスタイルでもコードが表示されますが、状況があまりにも遠すぎる場合があります。`unsafe`でないコードをすべてラップするのは良い考えではありません。

`transmute`はほとんどチェックを行いませんが、少なくとも同じ種類の型であることを確認します。
このエラー：

```rust,ignore
use std::mem;

unsafe {
    let a = [0u8, 0u8, 0u8, 0u8];

    let b = mem::transmute::<[u8; 4], u64>(a);
}
```

with：

```text
error: transmute called with differently sized types: [u8; 4] (32 bits) to u64
(64 bits)
```

それ以外は、あなた自身である！
