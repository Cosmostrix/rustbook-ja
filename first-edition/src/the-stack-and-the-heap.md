# スタックとヒープ

システム言語として、Rustは低レベルで動作します。
高水準言語を使用している場合は、使い慣れていないシステムプログラミングのいくつかの側面があります。
最も重要なのは、スタックとヒープを使ってメモリがどのように動作するかです。
C言語のような言語がスタック割り当てをどのように使用するかに精通している方は、この章を参考にしてください。
あなたがそうでないなら、あなたはこのより一般的な概念について学ぶでしょうが、錆に焦点を当てます。

ほとんどの場合と同様に、それらについて学習するときは、単純化されたモデルを使用して開始します。
これは、基本的にハンドルを得ることができます。詳細については、今のところ無関係です。
使用する例は100％正確ではありませんが、現在学習しようとしているレベルを代表しています。
基本的な知識があれば、アロケータの実装方法、仮想メモリ、その他の高度なトピックを学ぶことで、この特定の抽象化におけるリークを明らかにすることができます。

# メモリ管理

これらの2つの用語はメモリ管理に関する用語です。
スタックとヒープは、いつメモリの割り当てと割り当て解除を決定するのに役立つ抽象です。

ここでは、高いレベルの比較があります：

スタックは非常に高速で、メモリはデフォルトでRustに割り当てられます。
しかし、割り当ては関数呼び出しにとってローカルであり、サイズが制限されています。
一方、ヒープは遅く、プログラムによって明示的に割り当てられます。
しかし、事実上、サイズは無制限で、グローバルにアクセス可能です。
任意の大きさのメモリブロックを任意の順序で割り当てるヒープの意味は、ヒープデータ構造とはまったく異なります。

# スタック

このRustプログラムについてお話しましょう：

```rust
fn main() {
    let x = 42;
}
```

このプログラムには、変数バインディング`x`が1つあります。
このメモリはどこかから割り当てられる必要があります。
デフォルトではRust 'stack allocates'となります。つまり、基本値はスタックに移動します。
どういう意味ですか？

関数が呼び出されると、いくつかのメモリがそのローカル変数のすべてとその他の情報に割り当てられます。
これは「スタックフレーム」と呼ばれ、このチュートリアルでは追加の情報を無視し、割り当てているローカル変数のみを考慮します。
この場合、`main()`を実行すると、スタックフレームに1つの32ビット整数が割り当てられます。
ご覧のように自動的に処理されます。
特別なRustコードなどを書く必要はありませんでした。

関数が終了すると、スタックフレームの割り当てが解除されます。
これも自動的に行われます。

このシンプルなプログラムのためのすべてがあります。
ここで理解すべき重要なことは、スタック割り当てが非常に高速であることです。
私たちは事前にすべてのローカル変数を知っているので、一度にすべてのメモリを取得できます。
そして、同時にそれらをすべて投げ捨てるので、私たちはそれも非常に速く取り除くことができます。

欠点は、単一の関数より長く必要な場合に値を保持できないことです。
私たちはまた、「スタック」という言葉が何を意味するのか話していません。
これを行うには、やや複雑な例が必要です。

```rust
fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
```

このプログラムは合計3つの変数を持っています： `foo()` 2つ、`main()` 1つです。
前と同じように、`main()`が呼び出されると、そのスタックフレームに単一の整数が割り当てられます。
しかし、`foo()`が呼び出されたときに何が起きるかを示す前に、メモリで何が起こっているのかを視覚化する必要があります。
あなたのオペレーティングシステムはあなたのプログラムにメモリのビューを提示します。これはかなりシンプルです。0から大きな数のアドレスの巨大なリストは、あなたのコンピュータのRAM容量を表します。
たとえば、ギガバイトのRAMがある場合、アドレスは`0`から`1,073,741,823`ます。
その数は2  __30__ から来て、ギガバイトのバイト数。
[^gigabyte]
[^gigabyte]: ‘Gigabyte’%20can%20mean%20two%20things:%2010%3Csup%3E9%3C/sup%3E,%20or%202%3Csup%3E30%3C/sup%3E.%20The%20IEC%20standard%20resolved%20this%20by%20stating%20that%20‘gigabyte’%20is%2010%3Csup%3E9%3C/sup%3E,%20and%20‘gibibyte’%20is%202%3Csup%3E30%3C/sup%3E.%20However,%20very%20few%20people%20use%20this%20terminology,%20and%20rely%20on%20context%20to%20differentiate.%20We%20follow%20in%20that%20tradition%20here.

このメモリは、巨大な配列のようなものです。アドレスはゼロから始まり、最終的な数値まで上がります。
そこで、最初のスタックフレームの図を示します。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

`x`はアドレス`0`にあり、値は`42`です。

`foo()`が呼び出されると、新しいスタックフレームが割り当てられます。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--2 |-->2 |<!--z |-->z |<!--100 |-->100 |
|<!--1 |-->1 |<!--y |-->y |<!--5 |-->5 |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

最初のフレームで`0`が取られたので、`foo()`のスタックフレームに`1`と`2`が使われます。
それは上に向かって成長し、私たちはより多くの機能を呼びます。
各変数のサイズを考慮して**いない**ことに注意してください（たとえば、32ビット変数は0〜3または4バイトのメモリアドレスを使用します）。


ここで注意しなければならない重要なことがいくつかあります。
数字0,1および2はすべて説明のためのものであり、実際にコンピュータが使用するアドレス値との関係はありません。
特に、一連のアドレスは実際には各アドレスを分離するいくつかのバイト数で区切られ、その区切りは格納される値のサイズを超えることさえあります。

`foo()`が終了すると、そのフレームは割り当て解除されます。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、`main()`後に、この最後の値さえもなくなります。
簡単！

それはディナープレートのスタックのように機能するので、「スタック」と呼ばれます。最初に置いたプレートは最後に取り戻すプレートです。
スタックは、スタックの最後の値が最初に取得した値であるため、このような理由から、「最後に先入れ先出し」と呼ばれることがあります。

3つの深い例を試してみましょう：

```rust
fn italic() {
    let i = 6;
}

fn bold() {
    let a = 5;
    let b = 100;
    let c = 1;

    italic();
}

fn main() {
    let x = 42;

    bold();
}
```

図をもっと鮮明にするために、いくつかの不気味な関数名があります。

さて、まず`main()`を呼び出します：

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

次に`main()`が`bold()`呼び出し`bold()`。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--**3** |-->**3** |<!--**c** |-->**c** |<!--**1** |-->**1** |
|<!--**2** |-->**2** |<!--**b** |-->**b** |<!--**100** |-->**100** |
|<!--**1** |-->**1** |<!--**a** |-->|<!--**5** |-->**5** |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、`bold()`は`italic()`呼び出します：

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--*4* |-->*4* |<!--*i* |-->*私* |<!--*6* |-->*6* |
|<!--**3** |-->**3** |<!--**c** |-->**c** |<!--**1** |-->**1** |
|<!--**2** |-->**2** |<!--**b** |-->**b** |<!--**100** |-->**100** |
|<!--**1** |-->**1** |<!--**a** |-->|<!--**5** |-->**5** |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

すごい！
私たちのスタックは大きくなっています。

`italic()`が終了すると、そのフレームは割り当てが解除され、`bold()`と`main()`のみが残されます。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--**3** |-->**3** |<!--**c** |-->**c** |<!--**1** |-->**1** |
|<!--**2** |-->**2** |<!--**b** |-->**b** |<!--**100** |-->**100** |
|<!--**1** |-->**1** |<!--**a** |-->|<!--**5** |-->**5** |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、`bold()`は終了し、`main()`だけが残っています：

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、私たちは終わりました。
それのハングアップを取得しますか？
それは料理を積むようなものです：上に追加すると、上から離れることになります。

# ヒープ

さて、これはかなりうまくいくが、すべてがこのように動作するわけではない。
場合によっては、異なる関数間でいくつかのメモリを渡す必要があります。また、1つの関数の実行より長い間メモリを保持する必要があります。
このために、ヒープを使用できます。

Rustでは、ヒープ上のメモリを[`Box<T>`型で][box]割り当てることができます。
ここに例があります：

```rust
fn main() {
    let x = Box::new(5);
    let y = 42;
}
```

[box]: ../../std/boxed/index.html

`main()`が呼び出されたときのメモリ内での処理

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--??????-->??????<!--|-->|

スタック上に2つの変数のためのスペースを割り当てます。
`y`は`42`、いつも通りですが、 `x`どうですか？
まあ、`x`は`Box<i32>`で、ボックスはヒープ上にメモリを割り当てます。
ボックスの実際の値は 'ヒープ'へのポインタを持つ構造体です。
関数の実行を開始し、`Box::new()`が呼び出されると、ヒープにいくつかのメモリが割り当てられ、そこに`5`が格納されます。
メモリは次のようになります。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |

私たちは仮想計算機に1GiBのRAMを持つ（2  __30__ ）番地を持っています。
スタックがゼロから増加するので、メモリを割り当てる最も簡単な場所はもう一方の端です。
だから、私たちの最初の価値は記憶の最高位にある。
そして、`x`の構造体の値は、ヒープ上に割り当てられた場所への[生ポインタ][rawpointer]を持ちます。したがって、`x`の値は、私たちが要求したメモリ位置です（2  __30__ ）-1です。

[rawpointer]: raw-pointers.html

これらのコンテキストでメモリを割り当てたり割り当てを解除することが実際に何を意味するかについては、あまり話を進めていません。
非常に詳細な説明はこのチュートリアルの範囲外ですが、ここで重要なことは、ヒープが反対側から成長するスタックではないということです。
これについては後で説明しますが、ヒープを割り当てて任意の順序で解放できるため、「穴」で終わる可能性があります。
ここで、しばらくの間実行されているプログラムのメモリレイアウトの図を示します：


|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--5 |-->5 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--|-->|
|<!--(2  __30__ ) -3 |-->（2  __30__ ） -3 |<!--|-->|<!--|-->|
|<!--(2  __30__ ) -4 |-->（2  __30__ ） -4 |<!--|-->|<!--42 |-->42 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--2 |-->2 |<!--z |-->z |<!--→ (2  __30__ ) -4 |-->→（2  __30__ ） -4 |
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |

この場合、ヒープには4つのものが割り当てられていますが、2つは割り当てが解除されています。
現在使用されていない（2  __30__ ） -1と（2  __30__ ） -4の間にはギャップがあります。
どのように、なぜこれが起こるかの具体的な詳細は、ヒープを管理するためにどのような戦略を使用するかによって異なります。
異なるプログラムでは、異なるメモリアロケータを使用できます。これは、これを管理するライブラリです。
錆プログラムは、この目的のために[jemalloc][jemalloc]を使用します。

[jemalloc]: http://www.canonware.com/jemalloc/

とにかく、私たちの例に戻ってください。
このメモリはヒープ上にあるので、ボックスを割り当てる関数よりも長く生き続けることができます。
しかし、この場合、そうではありません。
[^moving]関数が終了すると、`main()`スタックフレームを解放する必要があります。
`Box<T>`しかし、その袖のトリックを持っている[Drop][drop]。
`Drop` for `Box`の実装は、作成時に割り当てられたメモリの割り当てを解除します。
すばらしいです！
`x`がなくなると、最初にヒープに割り当てられたメモリが解放されます。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--??????-->??????<!--|-->|

[drop]: drop.html
 [^moving]: We%20can%20make%20the%20memory%20live%20longer%20by%20transferring%20ownership,

ときには「箱から出る」と呼ばれることもあります。
もっと複雑な例については後で説明します。


スタックフレームが消えて、私たちのメモリがすべて解放されます。

# 議論と借り入れ

スタックとヒープの基本的な例がありますが、関数の引数や借用はどうですか？
ここに小さなRustプログラムがあります：

```rust
fn foo(i: &i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &x;

    foo(y);
}
```

`main()`に入ると、メモリは次のようになります：

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--1 |-->1 |<!--y |-->y |<!--→ 0 |-->→0 |
|<!--0 |-->0 |<!--x |-->x |<!--5 |-->5 |

`x`は普通の古い`5`であり、`y`は`x`への参照です。
したがって、その値は`x`が存在するメモリ位置です。この場合は`0`です。

`y`を引数として渡すと、`foo()`を呼び出すとどうなりますか？

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--3 |-->3 |<!--z |-->z |<!--42 |-->42 |
|<!--2 |-->2 |<!--i |-->私|<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--y |-->y |<!--→ 0 |-->→0 |
|<!--0 |-->0 |<!--x |-->x |<!--5 |-->5 |

スタックフレームはローカルバインディングのためだけでなく、引数のためにもあります。
したがって、この場合には、我々は両方持っている必要があります`i`、私たちの引数、および`z`、私たちのローカル変数バインディング。
`i`は引数`y`コピーです。
`y`の値は`0`、 `i`もそうです。

これは、変数を借用してもメモリを解放しない理由の1つです。参照の値はメモリ位置へのポインタです。
私たちが根底にある記憶を取り除けば、うまくいくことはありません。

# 複雑な例

さて、この複雑なプログラムを段階的に進めてみましょう。

```rust
fn foo(x: &i32) {
    let y = 10;
    let z = &y;

    baz(z);
    bar(x, z);
}

fn bar(a: &i32, b: &i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &d;

    baz(e);
}

fn baz(f: &i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &h;

    foo(j);
}
```

最初に、`main()`を呼び出します。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

`j`、 `i`、 `h`メモリを割り当てます。
`i`はヒープ上にあり、値を指しています。

次に、`main()`最後に`foo()`が呼び出されます。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

`x`、 `y`、 `z`スペースが割り当てられます。
引数`x`は、`j`と同じ値を持ちます。これは、渡されたものです`j`が`h`指しているので、`0`アドレスへのポインタです。

次に、`foo()`は`z`を渡して`baz()` `foo()`呼び出します。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--7 |-->7 |<!--g |-->g |<!--100 |-->100 |
|<!--6 |-->6 |<!--f |-->f |<!--→ 4 |-->→4 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

私たちは`f`と`g`メモリを割り当てました。
`baz()`は非常に短いので、終了したらスタックフレームを取り除きます：

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

次に、`foo()`は`bar()`を`x`と`z`で呼び出し`bar()`。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--10 |-->10 |<!--e |-->e |<!--→ 9 |-->→9 |
|<!--9 |-->9 |<!--d |-->d |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--8 |-->8 |<!--c |-->c |<!--5 |-->5 |
|<!--7 |-->7 |<!--b |-->b |<!--→ 4 |-->→4 |
|<!--6 |-->6 |<!--a |-->|<!--→ 0 |-->→0 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

私たちはヒープに別の値を割り当てることになりますので、（2  __30__ ） -1から1を引く必要があります`1,073,741,822`よりも書く方が簡単です。
いずれにしても、いつものように変数を設定します。

`bar()`最後で、`baz()`呼び出します。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--12 |-->12 |<!--g |-->g |<!--100 |-->100 |
|<!--11 |-->11 |<!--f |-->f |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--10 |-->10 |<!--e |-->e |<!--→ 9 |-->→9 |
|<!--9 |-->9 |<!--d |-->d |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--8 |-->8 |<!--c |-->c |<!--5 |-->5 |
|<!--7 |-->7 |<!--b |-->b |<!--→ 4 |-->→4 |
|<!--6 |-->6 |<!--a |-->|<!--→ 0 |-->→0 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

これで、私たちは一番深いところにいる！
すごい！
これまでに続いてきたことをお祝いします。

`baz()`が終わったら、`f`と`g`を取り除きます：

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--10 |-->10 |<!--e |-->e |<!--→ 9 |-->→9 |
|<!--9 |-->9 |<!--d |-->d |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--8 |-->8 |<!--c |-->c |<!--5 |-->5 |
|<!--7 |-->7 |<!--b |-->b |<!--→ 4 |-->→4 |
|<!--6 |-->6 |<!--a |-->|<!--→ 0 |-->→0 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

次に、`bar()`から戻り`bar()`。
`d`は`Box<T>`であるので、それが指しているものも解放します：（2  __30__ ） -2。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

その後、`foo()`は次のように返します。

|<!--Address |-->アドレス|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

最後に、`main()`を実行し、残りの部分を消去します。
`i`が`Drop`ペダルであるとき、それはヒープの最後をもクリーンアップします。

# 他の言語は何をしていますか？

ガベージコレクタを持つほとんどの言語は、デフォルトでヒープ割り当てします。
これは、すべての値が囲まれていることを意味します。
これが行われる理由はいくつかありますが、このチュートリアルの対象外です。
時間の100％に当てはまらない可能性のある最適化もいくつかあります。
むしろスタックとに頼るよりも`Drop`ヒープとガベージコレクタのお得な情報ではなく、メモリをクリーンアップします。

# どちらを使いますか？

だから、スタックが速くて管理が簡単なら、なぜヒープが必要なのでしょうか？
大きな理由は、スタック割り当てだけでは、ストレージを再利用するための「先入れ先出し（LIFO）」セマンティクスしかないということです。
ヒープ割り当ては厳密に一般的です。ストレージを任意の順序でプールから取得してプールに戻すことができますが、複雑なコストがかかります。

一般に、スタック割り当てを優先する必要があります。したがって、Rustはデフォルトでスタックを割り当てます。
スタックのLIFOモデルは基本レベルで簡単です。
これには2つの大きな影響があります：ランタイム効率と意味的な影響。

## ランタイム効率

スタックのためのメモリの管理は簡単です：マシンは、いわゆる "スタックポインタ"という単一の値をインクリメントまたはデクリメントします。
ヒープ割り当てメモリーは任意のポイントで解放され、ヒープ割り当てメモリーの各ブロックは任意のサイズにすることができるため、メモリー・マネージャーは一般に、再使用のためにメモリーを識別するのがはるかに難しくなります。

このトピックを詳しく説明したい場合は、[このホワイトペーパー][wilson]を参考にしてください。

[wilson]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688

## 意味的な影響

スタック割り当ては、Rust言語そのもの、つまり開発者の精神モデルに影響を与えます。
LIFOセマンティクスは、Rust言語が自動メモリ管理をどのように処理するかを制御するものです。
一意に所有されているヒープ割り当てボックスの割り当て解除でさえ、この章で説明するスタックベースのLIFOセマンティクスによって駆動できます。
非LIFOセマンティクスの柔軟性（すなわち、表現力）は、一般にコンパイラがメモリを解放すべきコンパイル時に自動的に推論することができないことを意味する。
動的なプロトコルに依存する必要があります。潜在的には、言語自体の外部から、割り当て解除を実行する必要があります（`Rc<T>`と`Arc<T>`で使用される参照カウントがこれの1つの例です）。

極端な場合、ヒープ割り当ての増加した表現力は、重要なランタイムサポート（ガベージコレクタの形式など）または重要なプログラマ努力（検証を提供しない明示的メモリ管理呼び出しの形式）のいずれかを犠牲にして発生しますRustコンパイラによって）。
