# 山と原

システム言語として、Rustは低レベルで動作します。
高水準言語を使用している場合は、使い慣れていないシステム演譜の一部の側面があります。
最も重要なのは、山と原を使って記憶がどのように動作するかです。
C言語のような言語が山割り当てをどのように使用するかに精通している方は、この章を参考にしてください。
あなたがそうでないなら、あなたはこのより一般的な概念について学ぶでしょうが、Rustに焦点を当てます。

ほとんどの場合と同様に、それらについて学習するときは、単純化された模型を使用して開始します。
これは、基本的に手綱を得ることができます。詳細については、今のところ無関係です。
使用する例は100％正確ではありませんが、現在学習しようとしているレベルを代表しています。
基本的な知識があれば、割当譜の実装方法、仮想記憶、その他の高度な話題を学ぶことで、この特定の抽象化におけるリークを明らかにすることができます。

# 記憶管理

これらの2つの用語は記憶管理に関する用語です。
山と原は、いつ記憶域の割り当てと割り当て解除を決定するのに役立つ抽象です。

ここでは、高いレベルの比較があります。

山は非常に高速で、記憶は自動的にRustに割り当てられます。
しかし、割り当ては機能呼び出しにとって局所的であり、サイズが制限されています。
一方、原は遅く、算譜によって明示的に割り当てられます。
しかし、事実上、サイズは無制限で、全体が操作可能です。
任意の大きさの記憶段落を任意の順序で割り当てる原の意味は、原データ構造とはまったく異なります。

# 山

このRust算譜についてお話しましょう。

```rust
fn main() {
    let x = 42;
}
```

この算譜には、変数束縛`x`が1つあります。
この記憶はどこかから割り当てられる必要があります。
自動的にはRust 'stack allocates'となります。つまり、基本値は山に移動します。
どういう意味でしょうか？　

機能が呼び出されると、いくつかの記憶がそのローカル変数のすべてとその他の情報に割り当てられます。
これは「山積み枠」と呼ばれ、このチュートリアルでは追加の情報を無視し、割り当てているローカル変数のみを考慮します。
この場合、`main()`を実行すると、山積み枠に1つの32ビット整数が割り当てられます。
ご覧のように自動的に処理されます。
特別なRust譜面などを書く必要はありませんでした。

機能が終了すると、山積み枠の割り当てが解除されます。
これも自動的に行われます。

このシンプルな算譜のためのすべてがあります。
ここで理解すべき重要なことは、山割り当てが非常に高速であることです。
事前にすべてのローカル変数を知っているので、一度にすべての記憶を取得できます。
そして、同時にそれらをすべて投げ捨てるので、それも非常に速く取り除くことができます。

欠点は、単一の機能より長く必要な場合に値を保持できないことです。
また、「山」という言葉が何を意味するのか話していません。
これを行うには、やや複雑な例が必要です。

```rust
fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
```

この算譜は和3つの変数を持っています。 `foo()` 2つ、`main()` 1つです。
前と同じように、`main()`が呼び出されると、その山積み枠に単一の整数が割り当てられます。
しかし、`foo()`が呼び出されたときに何が起きるかを示す前に、記憶で何が起こっているのかを視覚化する必要があります。
あなたのオペレーティングシステムはあなたの算譜に記憶域のビューを提示します。これはかなりシンプルです。0から大きな数の番地の巨大なリストは、あなたの計算機のRAM容量を表します。
たとえば、ギガバイトのRAMがある場合、番地は`0`から`1,073,741,823`ます。
その数は2  __30__ から来て、ギガバイトのバイト数。
[^gigabyte]
[^gigabyte]: ‘Gigabyte’%20can%20mean%20two%20things:%2010%3Csup%3E9%3C/sup%3E,%20or%202%3Csup%3E30%3C/sup%3E.%20The%20IEC%20standard%20resolved%20this%20by%20stating%20that%20‘gigabyte’%20is%2010%3Csup%3E9%3C/sup%3E,%20and%20‘gibibyte’%20is%202%3Csup%3E30%3C/sup%3E.%20However,%20very%20few%20people%20use%20this%20terminology,%20and%20rely%20on%20context%20to%20differentiate.%20We%20follow%20in%20that%20tradition%20here.

この記憶は、巨大な配列のようなものです。番地はゼロから始まり、最終的な数値まで上がります。
そこで、最初の山積み枠の図を示します。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

`x`は番地`0`にあり、値は`42`です。

`foo()`が呼び出されると、新しい山積み枠が割り当てられます。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--2 |-->2 |<!--z |-->z |<!--100 |-->100 |
|<!--1 |-->1 |<!--y |-->y |<!--5 |-->5 |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

最初の枠で`0`が取られたので、`foo()`の山積み枠に`1`と`2`が使われます。
それは上に向かって成長し、より多くの機能を呼びます。
各変数のサイズを考慮して**いない**ことに注意してください（たとえば、32ビット変数は0〜3または4バイトの記憶番地を使用します）。


ここで注意しなければならない重要なことがいくつかあります。
数字0,1および2はすべて説明のためのものであり、実際に計算機が使用する番地値との関係はありません。
特に、一連の番地は実際には各番地を分離するいくつかのバイト数で区切られ、その区切りは格納される値のサイズを超えることさえあります。

`foo()`が終了すると、その枠は割り当て解除されます。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、`main()`後に、この最後の値さえもなくなります。
簡単！　

それは洋食器の山のように機能するので、「山」と呼ばれます。最初に置いた皿は最後に取り戻す皿です。
山は、山の最後の値が最初に取得した値であるため、このような理由から、「最後に先入れ先出し」と呼ばれることがあります。

3つの具体例を試してみましょう。

```rust
fn italic() {
    let i = 6;
}

fn bold() {
    let a = 5;
    let b = 100;
    let c = 1;

    italic();
}

fn main() {
    let x = 42;

    bold();
}
```

図をもっと鮮明にするために、いくつかの不気味な機能名があります。

さて、まず`main()`を呼び出します。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

次に`main()`が`bold()`呼び出し`bold()`。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--**3** |-->**3** |<!--**c** |-->**c** |<!--**1** |-->**1** |
|<!--**2** |-->**2** |<!--**b** |-->**b** |<!--**100** |-->**100** |
|<!--**1** |-->**1** |<!--**a** |-->|<!--**5** |-->**5** |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、`bold()`は`italic()`呼び出します。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--*4* |-->*4* |<!--*i* |-->*私* |<!--*6* |-->*6* |
|<!--**3** |-->**3** |<!--**c** |-->**c** |<!--**1** |-->**1** |
|<!--**2** |-->**2** |<!--**b** |-->**b** |<!--**100** |-->**100** |
|<!--**1** |-->**1** |<!--**a** |-->|<!--**5** |-->**5** |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

すごい！　
山は大きくなっています。

`italic()`が終了すると、その枠は割り当てが解除され、`bold()`と`main()`のみが残されます。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--**3** |-->**3** |<!--**c** |-->**c** |<!--**1** |-->**1** |
|<!--**2** |-->**2** |<!--**b** |-->**b** |<!--**100** |-->**100** |
|<!--**1** |-->**1** |<!--**a** |-->|<!--**5** |-->**5** |
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、`bold()`は終了し、`main()`だけが残っています。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|-------|-->---------| ------| -------|
|<!--0 |-->0 |<!--x |-->x |<!--42 |-->42 |

そして、終わりました。
それのハングアップを取得しますか？　
それは料理を積むようなものです。上に追加すると、上から離れることになります。

# 原

さて、これはかなりうまくいくが、すべてがこのように動作するわけではありません。
場合によっては、異なる機能間でいくつかの記憶を渡す必要があります。また、1つの機能の実行より長い間記憶を保持する必要があります。
このために、原を使用できます。

Rustでは、原上の記憶を[`Box<T>`型で][box]割り当てることができます。
ここに例があります。

```rust
fn main() {
    let x = Box::new(5);
    let y = 42;
}
```

[box]: ../../std/boxed/index.html

`main()`が呼び出されたときの記憶内での処理

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--??????-->??????<!--|-->|

山上に2つの変数のための空間を割り当てます。
`y`は`42`、いつも通りですが、 `x`どうでしょうか？　
まあ、`x`は`Box<i32>`で、ボックスは原上に記憶を割り当てます。
ボックスの実際の値は '原'への指し手を持つ構造体です。
機能の実行を開始し、`Box::new()`が呼び出されると、原にいくつかの記憶が割り当てられ、そこに`5`が格納されます。
記憶は次のようになります。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |

仮想計算機に1GiBのRAMを持つ（2  __30__ ）番地を持っています。
山がゼロから増加するので、記憶を割り当てる最も簡単な場所はもう一方の端です。
だから、最初の価値は記憶の最高位にあます。
そして、`x`の構造体の値は、原上に割り当てられた場所への[生指し手][rawpointer]を持ちます。したがって、`x`の値は、要求した記憶位置です（2  __30__ ）-1です。

[rawpointer]: raw-pointers.html

これらの文脈で記憶を割り当てたり割り当てを解除することが実際に何を意味するかについては、あまり話を進めていません。
非常に詳細な説明はこのチュートリアルの範囲外ですが、ここで重要なことは、原が反対側から成長する山ではないということです。
これについては後で説明しますが、原を割り当てて任意の順序で解放できるため、「穴」で終わる可能性があります。
ここで、しばらくの間実行されている算譜の記憶配置の図を示します。


|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--5 |-->5 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--|-->|
|<!--(2  __30__ ) -3 |-->（2  __30__ ） -3 |<!--|-->|<!--|-->|
|<!--(2  __30__ ) -4 |-->（2  __30__ ） -4 |<!--|-->|<!--42 |-->42 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--2 |-->2 |<!--z |-->z |<!--→ (2  __30__ ) -4 |-->→（2  __30__ ） -4 |
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |

この場合、原には4つのものが割り当てられていますが、2つは割り当てが解除されています。
現在使用されていない（2  __30__ ） -1と（2  __30__ ） -4の間にはギャップがあります。
どのように、なぜこれが起こるかの具体的な詳細は、原を管理するためにどのような戦略を使用するかによって異なります。
異なる算譜では、異なる記憶割当譜を使用できます。これは、これを管理する譜集です。
Rust算譜は、この目的のために[jemalloc][jemalloc]を使用します。

[jemalloc]: http://www.canonware.com/jemalloc/

とにかく、例に戻ってください。
この記憶は原上にあるので、ボックスを割り当てる機能よりも長く生き続けることができます。
しかし、この場合、そうではありません。
[^moving]機能が終了すると、`main()`山積み枠を解放する必要があります。
`Box<T>`しかし、その袖のトリックを持っている[Drop][drop]。
`Drop` for `Box`の実装は、作成時に割り当てられた記憶域の割り当てを解除します。
すばらしいです！　
`x`がなくなると、最初に原に割り当てられた記憶が解放されます。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--1 |-->1 |<!--y |-->y |<!--42 |-->42 |
|<!--0 |-->0 |<!--x |-->x |<!--??????-->??????<!--|-->|

[drop]: drop.html
 [^moving]: We%20can%20make%20the%20memory%20live%20longer%20by%20transferring%20ownership,

ときには「箱から出る」と呼ばれることもあります。
もっと複雑な例については後で説明します。


山積み枠が消えて、記憶がすべて解放されます。

# 議論と借用入れ

山と原の基本的な例がありますが、機能の引数や借用はどうでしょうか？　
ここに小さなRust算譜があります。

```rust
fn foo(i: &i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &x;

    foo(y);
}
```

`main()`に入ると、記憶は次のようになります。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--1 |-->1 |<!--y |-->y |<!--→ 0 |-->→0 |
|<!--0 |-->0 |<!--x |-->x |<!--5 |-->5 |

`x`は普通の古い`5`であり、`y`は`x`への参照です。
したがって、その値は`x`が存在する記憶位置です。この場合は`0`です。

`y`を引数として渡すと、`foo()`を呼び出すとどうなりますか？　

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!-----------|------|--------|-->---------| ------| --------|
|<!--3 |-->3 |<!--z |-->z |<!--42 |-->42 |
|<!--2 |-->2 |<!--i |-->私|<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--y |-->y |<!--→ 0 |-->→0 |
|<!--0 |-->0 |<!--x |-->x |<!--5 |-->5 |

山積み枠はローカル束縛のためだけでなく、引数のためにもあります。
したがって、この場合には、両方持っている必要があります`i`、引数、および`z`、ローカル変数束縛。
`i`は引数`y`コピーです。
`y`の値は`0`、 `i`もそうです。

これは、変数を借用しても記憶を解放しない理由の1つです。参照の値は記憶位置への指し手です。
根底にある記憶を取り除けば、うまくいくことはありません。

# 複雑な例

さて、この複雑な算譜を段階的に進めてみましょう。

```rust
fn foo(x: &i32) {
    let y = 10;
    let z = &y;

    baz(z);
    bar(x, z);
}

fn bar(a: &i32, b: &i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &d;

    baz(e);
}

fn baz(f: &i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &h;

    foo(j);
}
```

最初に、`main()`を呼び出します。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

`j`、 `i`、 `h`記憶を割り当てます。
`i`は原上にあり、値を指しています。

次に、`main()`最後に`foo()`が呼び出されます。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

`x`、 `y`、 `z`スペースが割り当てられます。
引数`x`は、`j`と同じ値を持ちます。これは、渡されたものです`j`が`h`指しているので、`0`番地への指し手です。

次に、`foo()`は`z`を渡して`baz()` `foo()`呼び出します。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--7 |-->7 |<!--g |-->g |<!--100 |-->100 |
|<!--6 |-->6 |<!--f |-->f |<!--→ 4 |-->→4 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

`f`と`g`記憶を割り当てました。
`baz()`は非常に短いので、終了したら山積み枠を取り除きます。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

次に、`foo()`は`bar()`を`x`と`z`で呼び出し`bar()`。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--10 |-->10 |<!--e |-->e |<!--→ 9 |-->→9 |
|<!--9 |-->9 |<!--d |-->d |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--8 |-->8 |<!--c |-->c |<!--5 |-->5 |
|<!--7 |-->7 |<!--b |-->b |<!--→ 4 |-->→4 |
|<!--6 |-->6 |<!--a |-->|<!--→ 0 |-->→0 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

原に別の値を割り当てることになりますので、（2  __30__ ） -1から1を引く必要があります`1,073,741,822`よりも書く方が簡単です。
いずれにしても、いつものように変数を設定します。

`bar()`最後で、`baz()`呼び出します。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--12 |-->12 |<!--g |-->g |<!--100 |-->100 |
|<!--11 |-->11 |<!--f |-->f |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--10 |-->10 |<!--e |-->e |<!--→ 9 |-->→9 |
|<!--9 |-->9 |<!--d |-->d |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--8 |-->8 |<!--c |-->c |<!--5 |-->5 |
|<!--7 |-->7 |<!--b |-->b |<!--→ 4 |-->→4 |
|<!--6 |-->6 |<!--a |-->|<!--→ 0 |-->→0 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

これで、一番深いところにいる！　
すごい！　
これまでに続いてきたことをお祝いします。

`baz()`が終わったら、`f`と`g`を取り除きます。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--(2  __30__ ) -2 |-->（2  __30__ ） -2 |<!--|-->|<!--5 |-->5 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--10 |-->10 |<!--e |-->e |<!--→ 9 |-->→9 |
|<!--9 |-->9 |<!--d |-->d |<!--→ (2  __30__ ) -2 |-->→（2  __30__ ） -2 |
|<!--8 |-->8 |<!--c |-->c |<!--5 |-->5 |
|<!--7 |-->7 |<!--b |-->b |<!--→ 4 |-->→4 |
|<!--6 |-->6 |<!--a |-->|<!--→ 0 |-->→0 |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

次に、`bar()`から戻り`bar()`。
`d`は`Box<T>`であるので、それが指しているものも解放します。（2  __30__ ） -2。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--5 |-->5 |<!--z |-->z |<!--→ 4 |-->→4 |
|<!--4 |-->4 |<!--y |-->y |<!--10 |-->10 |
|<!--3 |-->3 |<!--x |-->x |<!--→ 0 |-->→0 |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

その後、`foo()`は次のように返します。

|<!--Address |-->番地|<!--Name |-->名前|<!--Value |-->値|
|<!------------------------|------|------------------------|-->----------------------| ------| ------------------------|
|<!--(2  __30__ ) -1 |-->（2  __30__ ） -1 |<!--|-->|<!--20 |-->20 |
|<!--... |-->... |<!--... |-->... |<!--... |-->... |
|<!--2 |-->2 |<!--j |-->j |<!--→ 0 |-->→0 |
|<!--1 |-->1 |<!--i |-->私|<!--→ (2  __30__ ) -1 |-->→（2  __30__ ） -1 |
|<!--0 |-->0 |<!--h |-->h |<!--3 |-->3 |

最後に、`main()`を実行し、残りの部分を消去します。
`i`が`Drop`ペダルであるとき、それは原の最後をも後始末します。

# 他の言語は何をしていますか？　

ごみ集め部を持つほとんどの言語は、自動的に原割り当てします。
これは、すべての値が囲まれていることを意味します。
これが行われる理由はいくつかありますが、このチュートリアルの対象外です。
時間の100％に当てはまらない可能性のある最適化もいくつかあります。
むしろ山とに頼るよりも`Drop`原とごみ集め部のお得な情報ではなく、記憶を後始末します。

# どちらを使いますか？　

だから、山が速くて管理が簡単なら、なぜ原が必要なのでしょうか？　
大きな理由は、山割り当てだけでは、格納庫を再利用するための「先入れ先出し（LIFO）」意味論しかないということです。
原割り当ては厳密に一般的です。格納庫を任意の順序で貯留庫から取得して貯留庫に戻すことができますが、複雑なコストがかかります。

一般に、山割り当てを優先する必要があります。したがって、Rustは自動的に山を割り当てます。
山のLIFO模型は基本レベルで簡単です。
これには2つの大きな影響があります。実行時効率と意味的な影響。

## 実行時効率

山のための記憶域の管理は簡単です。機械は、いわゆる "山指し手"という単一の値を増分または減分します。
原割り当て記憶は任意の地点で解放され、原割り当て記憶域の各段落は任意のサイズにすることができるため、記憶・マネージャーは一般に、再使用のために記憶を識別するのがはるかに難しくなります。

この話題を詳しく説明したい場合は、[このホワイトペーパー][wilson]を参考にしてください。

[wilson]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688

## 意味的な影響

山割り当ては、Rust言語そのもの、つまり開発者の心的模型に影響を与えます。
LIFO意味論は、Rust言語が自動記憶管理をどのように処理するかを制御するものです。
一意に所有されている原割り当てボックスの割り当て解除でさえ、この章で説明する山ベースのLIFO意味論によって駆動できます。
非LIFO意味論の柔軟性（すなわち、表現力）は、一般に製譜器が記憶を解放すべき製譜時に自動的に推論することができないことを意味します。
動的な約束事に依存する必要があります。潜在的には、言語自体の外部から、割り当て解除を実行する必要があります（`Rc<T>`と`Arc<T>`で使用される参照カウントがこれの1つの例です）。

極端な場合、原割り当ての増加した表現力は、重要な実行時サポート（ごみ集め部の形式など）または重要な演譜師努力（検証を提供しない明示的記憶管理呼び出しの形式）のいずれかを犠牲にして発生しますRust製譜器によって）。
