# 安全でない

Rustの主な魅力は、行動に対する強力な静的保証です。
しかし、安全性チェックは本質的に保守的です。実際には安全なプログラムがいくつかありますが、コンパイラはこれが正しいことを確認できません。
この種のプログラムを書くためには、コンパイラに制限を緩和するよう伝える必要があります。
このため、Rustにはキーワードがあり、`unsafe`。
`unsafe`コードを使用すると、通常のコードより制限が少なくなります。

構文を見てみましょう。その後、セマンティクスについて説明します。
`unsafe`は4つのコンテキストで使用されます。
最初の方法は、関数を安全でないものとしてマークすることです。

```rust
unsafe fn danger_will_robinson() {
#    // Scary stuff...
    // 恐ろしいもの...
}
```

[FFI][ffi]から呼び出されるすべての関数は、たとえば`unsafe`でないとマークする必要があります。
`unsafe`の2番目の使用は`unsafe`なブロックです：

[ffi]: ffi.html

```rust
unsafe {
#    // Scary stuff...
    // 恐ろしいもの...
}
```

3番目は危険な形質です。

```rust
unsafe trait Scary { }
```

そして第四は、のためにある`impl`これらの特性のいずれかをementing：

```rust
# unsafe trait Scary { }
unsafe impl Scary for i32 {}
```

大きな問題を引き起こすバグがある可能性のあるコードを明示的に記述できることが重要です。
Rustプログラムのセグメンテーションが失敗した場合、原因が`unsafe`とマークされたものに関連しているかどうかを確認できます。

# 「安全」とはどういう意味ですか？

安全な、錆のコンテキストでは、何も危険なことをしないという意味です。
おそらくあなたのコードでは望ましくないかもしれないが、危険で _は_ ないことが明らかな特定の動作があることを知っておくことも重要です。

* デッドロック
* メモリまたは他のリソースのリーク
* デストラクタを呼び出さずに終了する
* 整数オーバーフロー

錆は、あらゆる種類のソフトウェア問題を防ぐことはできません。
バグのコードはRustに書かれ、書かれます。
これらのことは素晴らしいことではありませんが、特に`unsafe`ないとは認められません。

さらに、以下はすべてRustの未定義の動作であり、`unsafe`コードを記述している場合でも避けなければなりません。

* データレース
* NULL /ダングリングしていない生ポインタを参照解除する
* [undef][undef]（初期化されていない）メモリの読み取り
* 生ポインタで[ポインタエイリアシングルール][aliasing]を破る。
* `&mut T` `&T`に`UnsafeCell<U>`が含まれている場合を除いて`&mut T`と`&T`はLLVMのスコープ付き[noalias][noalias]モデルに従います。
   安全でないコードがこれらのエイリアシングの保証に違反してはいけません。
* UnsafeCellを使用しない不変の値/参照の`UnsafeCell<U>`
* コンパイラ組み込み関数を使用して未定義のビヘイビアを呼び出す：
  * オブジェクトの境界の外側で、`std::ptr::offset`（ `offset`組み込み）を使用して索引付けします。ただし、許可される最後の1バイトを例外とします。
  * オーバーラップバッファに`std::ptr::copy_nonoverlapping_memory`（ `memcpy32` / `memcpy64`組み込み関数）を使用する
* プライベートフィールド/ローカルでもプリミティブ型の値が無効です：
  * NULL /ダングリング参照またはボックス
  * `bool`内の`false`（0）または`true`（1）以外の`bool`
  * 型定義に含まれていない`enum`型の判別式
  * 値`char`サロゲート以上である`char::MAX`
  * `str`非UTF-8バイトシーケンス
* 外国のコードから錆に巻き戻すか、または錆から外国のコードに巻き戻す。

[noalias]: http://llvm.org/docs/LangRef.html#noalias
 [undef]: http://llvm.org/docs/LangRef.html#undefined-values
 [aliasing]: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules


# 安全でない超大国

安全でない機能と安全でないブロックの両方で、Rustは通常はできない3つのことをさせます。
ただ3つ。
どうぞ：

1. [静的な可変変数に][static]アクセスまたは更新し[ます][static]。
2. 生のポインタを参照しない。
3. 安全でない関数を呼び出します。
    これが最も強力な能力です。

それでおしまい。
`unsafe`はないことが重要です。たとえば、「貸し出しチェッカーをオフにする」などです。
いくつかのランダムな錆のコードに`unsafe`を追加しても、セマンティクスは変わらず、何も受け入れられません。
しかし、それはあなたがルールのいくつかを破ることを書くことが _でき_ ます。

外部（非Rust）インターフェースへのバインディングを記述する際には、`unsafe`キーワードが発生します。
ライブラリが提供するメソッドについて、安全でネイティブなRustインターフェースを書くことをお勧めします。

リストされている基本的な3つの能力を順番に説明しましょう。

## `static mut`へのアクセスまたは更新

Rustには ' `static mut` 'という機能があり、変更可能なグローバル状態が可能です。
そうすることで、データの競合が発生する可能性があり、本質的に安全ではありません。
詳細については、本の[static][static]セクションを参照してください。

[static]: const-and-static.html#static

## 未処理のポインタを参照解除する

生ポインタを使用すると、任意のポインタ演算を実行でき、さまざまなメモリの安全性とセキュリティの問題を引き起こす可能性があります。
いくつかの意味では、任意のポインタを逆参照する能力は、あなたができる最も危険なものの1つです。
生ポインタの詳細について[は、本のセクションを][rawpointers]参照し[て][rawpointers]ください。

[rawpointers]: raw-pointers.html

## 安全でない関数を呼び出す

この最後の機能は、両方の側面で動作し`unsafe`：あなたはマークされた関数のみを呼び出すことができます`unsafe`危険なブロックの内側から。

この能力は強力で多様です。
Rustは[compiler intrinsics][intrinsics]関数の一部を安全でない関数として公開し、安全でない関数の一部はセーフティチェックをバイパスし、安全性を保証します。

もう一度やり直してみましょう：安全でないブロックや関数で任意のことをする _ことができ_ ても、あなた _が_ すべきことではありません。
コンパイラはあなたが不変量を保持しているかのように動作しますので、注意してください！

[intrinsics]: ../../unstable-book/language-features/intrinsics.html
