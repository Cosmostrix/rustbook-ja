# 安全でない

Rustの主な魅力は、行動に対する強力な静的保証です。
しかし、安全性チェックは本質的に保守的です。実際には安全な算譜がいくつかありますが、製譜器はこれが正しいことを確認できません。
この種の算譜を書くためには、製譜器に制限を緩和するよう伝える必要があります。
このため、Rustには予約語があり、`unsafe`。
`unsafe`譜面を使用すると、通常の譜面より制限が少なくなります。

構文を見てみましょう。その後、意味論について説明します。
`unsafe`は4つの文脈で使用されます。
最初の方法は、機能を安全でないものとしてマークすることです。

```rust
unsafe fn danger_will_robinson() {
#    // Scary stuff...
    // 恐ろしいもの...
}
```

[FFI][ffi]から呼び出されるすべての機能は、たとえば`unsafe`でないとマークする必要があります。
`unsafe`の2番目の使用は`unsafe`な段落です。

[ffi]: ffi.html

```rust
unsafe {
#    // Scary stuff...
    // 恐ろしいもの...
}
```

3番目は危険な特性です。

```rust
unsafe trait Scary { }
```

そして第四は、のためにある`impl`これらの特性のいずれかをementing。

```rust
# unsafe trait Scary { }
unsafe impl Scary for i32 {}
```

大きな問題を引き起こすバグがある可能性のある譜面を明示的に記述できることが重要です。
Rust算譜のセグメンテーションが失敗した場合、原因が`unsafe`とマークされたものに関連しているかどうかを確認できます。

# 「安全」とはどういう意味でしょうか？　

安全な、Rustの文脈では、何も危険なことをしないという意味です。
おそらくあなたの譜面では望ましくないかもしれないが、危険で _は_ ないことが明らかな特定の動作があることを知っておくことも重要です。

* デッドロック
* 記憶または他の資源のリーク
* 破棄子を呼び出さずに終了する
* 整数オーバーフロー

Rustは、あらゆる種類の譜体問題を防ぐことはできません。
バグの譜面はRustに書かれ、書かれます。
これらのことは素晴らしいことではありませんが、特に`unsafe`ないとは認められません。

さらに、以下はすべてRustの未定義の動作であり、`unsafe`譜面を記述している場合でも避けなければなりません。

* データレース
* NULL /行方不明のしていない生指し手を参照解除する
* [undef][undef]（初期化されていない）記憶域の読み取り
* 生指し手で[指し手別名付与ルール][aliasing]を破ます。
* `&mut T` `&T`に`UnsafeCell<U>`が含まれている場合を除いて`&mut T`と`&T`はLLVMの有効範囲付き[noalias][noalias]模型に従います。
   安全でない譜面がこれらの別名付与の保証に違反してはいけません。
* UnsafeCellを使用しない不変の値/参照の`UnsafeCell<U>`
* 製譜器組み込み機能を使用して未定義のビヘイビアを呼び出す。
  * 対象の縛りの外側で、`std::ptr::offset`（ `offset`組み込み）を使用して索引付けします。ただし、許可される最後の1バイトを例外とします。
  * オーバーラップバッファに`std::ptr::copy_nonoverlapping_memory`（ `memcpy32` / `memcpy64`組み込み機能）を使用する
* 内部用欄/ローカルでも基本型の値が無効です。
  * NULL /行方不明の参照またはボックス
  * `bool`内の`false`（0）または`true`（1）以外の`bool`
  * 型定義に含まれていない`enum`型の判別式
  * 値`char`サロゲート以上である`char::MAX`
  * `str`非UTF-8バイトシーケンス
* 外部の譜面からRustに巻き戻すか、またはRustから外部の譜面に巻き戻す。

[noalias]: http://llvm.org/docs/LangRef.html#noalias
 [undef]: http://llvm.org/docs/LangRef.html#undefined-values
 [aliasing]: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules


# 安全でない超大国

安全でない機能と安全でない段落の両方で、Rustは通常はできない3つのことをさせます。
ただ3つ。
どうぞ。

1. [静的な可変変数に][static]アクセスまたは更新し[ます][static]。
2. 生の指し手を参照しない。
3. 安全でない機能を呼び出します。
    これが最も強力な能力です。

それでおしまい。
`unsafe`はないことが重要です。たとえば、「貸し出し検査器をオフにする」などです。
適当なRustの譜面に`unsafe`を追加しても、意味論は変わらず、何も受け入れられません。
しかし、それはあなたがルールのいくつかを破ることを書くことが _でき_ ます。

外部（非Rust）接点への束縛を記述する際には、`unsafe`予約語が発生します。
譜集が提供する操作法について、安全でネイティブなRust接点を書くことをお勧めします。

リストされている基本的な3つの能力を順番に説明しましょう。

## `static mut`へのアクセスまたは更新

Rustには ' `static mut` 'という機能があり、変更可能な全体状態が可能です。
そうすることで、データの競合が発生する可能性があり、本質的に安全ではありません。
詳細については、本の[static][static]章を参照してください。

[static]: const-and-static.html#static

## 未処理の指し手を参照解除する

生指し手を使用すると、任意の指し手演算を実行でき、さまざまな記憶域の安全性とセキュリティの問題を引き起こす可能性があります。
いくつかの意味では、任意の指し手を逆参照する能力は、あなたができる最も危険なものの1つです。
生指し手の詳細について[は、本の章を][rawpointers]参照し[て][rawpointers]ください。

[rawpointers]: raw-pointers.html

## 安全でない機能を呼び出す

この最後の機能は、両方の側面で動作し`unsafe`。あなたはマークされた機能のみを呼び出すことができます`unsafe`危険な段落の内側から。

この能力は強力で多様です。
Rustは[compiler intrinsics][intrinsics]機能の一部を安全でない機能として公開し、安全でない機能の一部はセーフティチェックをバイパスし、安全性を保証します。

もう一度やり直してみましょう。安全でない段落や機能で任意のことをする _ことができ_ ても、あなた _が_ すべきことではありません。
製譜器はあなたが不変量を保持しているかのように動作しますので、注意してください！　

[intrinsics]: ../../unstable-book/language-features/intrinsics.html
