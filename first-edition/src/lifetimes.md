# 生涯

これは、Rustの所有システムを提示する3つのセクションの最後です。
これは、Rustの最も顕著で魅力的な機能の1つで、Rustの開発者はかなり知り合いになるはずです。
所有権とは、Rustが最大の目標であるメモリの安全性を達成する方法です。
いくつかの異なる概念があり、それぞれ独自の章があります。

* [ownership][ownership]、キーコンセプト
* [borrowing][borrowing]、およびそれらの関連するフィーチャ '参照'
* あなたが今読んでいる生涯

これら3つの章は関連しており、順番に説明されています。
所有権システムを完全に理解するには、3つすべてが必要です。

[ownership]: ownership.html
 [borrowing]: references-and-borrowing.html


# メタ

詳細を知る前に、オーナーシップシステムに関する2つの重要な注意事項。

錆は安全性とスピードに焦点を当てています。
これは、多くの「ゼロコスト抽象化」によってこれらの目標を達成します。つまり、Rustでは抽象化のコストをできるだけ少なくして機能させることを意味します。
所有権システムは、ゼロコスト抽象化の主要な例です。
このガイド _で説明する_ すべての分析は _、コンパイル時に行われます_ 。
これらの機能のランタイムコストを支払うことはありません。

しかし、このシステムには一定のコストがあります：学習曲線。
Rustの新しいユーザーの多くは、Rustコンパイラが作成者が有効だと思うプログラムをコンパイルすることを拒否する「borrow checkerとの戦い」と呼ばれることを経験しています。
これは、所有者がどのように動作するかについてのプログラマーの精神モデルが、Rustが実装する実際のルールと一致しないためによく発生します。
最初は似たようなことを経験するでしょう。
ただし、経験豊かなRustデベロッパーは、所有システムのルールを一定期間使用すると、借りチェッカーとの競争が少なくなることを報告しています。

そのことを念頭に置いて、生涯について学びましょう。

# 生涯

他の人が所有しているリソースへの参照を貸し出すことは複雑になる可能性があります。
たとえば、次の一連の操作を想像してみてください。

1. 私はある種のリソースへのハンドルを取得します。
2. 私はあなたにリソースへの参照を貸します。
3. 私はあなたがまだあなたの参照を持っている間、私はリソースで完了し、それを割り当てを解除することを決定します。
4. あなたはリソースを使用することに決めました。

ええとああ！
参照が無効なリソースを指しています。
リソースがメモリの場合、これはダングリングポインタまたは 'フリー後の使用'と呼ばれます。
このような状況の小さな例は次のようになります。

```rust,ignore
#//let r;              // Introduce reference: `r`.
let r;              // 参照を導入する： `r`。
{
#//    let i = 1;      // Introduce scoped value: `i`.
    let i = 1;      // スコープ値を導入する： `i`。
#//    r = &i;         // Store reference of `i` in `r`.
    r = &i;         //  `r`の`i`参照を格納する。
#//}                   // `i` goes out of scope and is dropped.
}                   //  `i`は範囲外に出て落ちる。

#//println!("{}", r);  // `r` still refers to `i`.
println!("{}", r);  //  `r`まだ`i`指します。
```

この問題を解決するには、ステップ3の後にステップ4が起こらないようにする必要があります。
上の小さな例では、Rustコンパイラは関数内のさまざまな値の存続期間を見ることができるため、問題を報告することができます。

参照によって引数を取る関数があるとき、状況はより複雑になります。
次の例を考えてみましょう。

```rust,ignore
fn skip_prefix(line: &str, prefix: &str) -> &str {
#    // ...
    // ...
#   line
}

let line = "lang:en=Hello World!";
let lang = "en";

let v;
{
#//    let p = format!("lang:{}=", lang);  // -+ `p` comes into scope.
    let p = format!("lang:{}=", lang);  //  -+ `p`がスコープに入ります。
#//    v = skip_prefix(line, p.as_str());  //  |
    v = skip_prefix(line, p.as_str());  //  |
#//}                                       // -+ `p` goes out of scope.
}                                       //  -+ `p`は範囲外になります。
println!("{}", v);
```

ここでは、機能してい`skip_prefix` 2つの取り`&str`パラメータとして参照を単一返し`&str`参照を。
私たちはそれを`line`と`p`への参照を渡すことで呼びます：生涯の異なる2つの変数。
`println!`の行の安全性は、`skip_prefix`関数によって返された参照が静止している`line`または既にドロップされた`p`文字列を参照するかどうかによって決まります。

上記のあいまいさのために、Rustはサンプルコードのコンパイルを拒否します。
それをコンパイルするには、コンパイラに参照の存続期間についてもっと詳しく伝える必要があります。
これは、関数宣言で明示的な存続期間を設定することによって行うことができます。

```rust
fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {
#    // ...
    // ...
#   line
}
```

今のところ構文に深く進まずに変更を調べてみましょう。後でそれを説明します。
最初の変更はメソッド名の後に`<'a, 'b>`を追加することでした。
：これは、二つの寿命パラメータ紹介`'a`と`'b`。
次に、関数シグネチャ内の各参照は、`&`後にライフタイム名を追加することで、1つの存続時間パラメータに関連付けられました。
これは、異なる参照間の存続期間がどのように関係しているかをコンパイラに伝えます。

その結果、コンパイラーは、`skip_prefix`の戻り値が`line`パラメーターと同じ有効期間であることを推測することができます。これにより、`p`が元の例の範囲外になった後でも`v`参照を安全に使用できるようになります。

コンパイラは`skip_prefix`戻り値の使用を検証できるだけでなく、実装が関数宣言によって確立されたコントラクトに確実に従うようにすることもできます。
これは、特に[本の後半で][traits]紹介される特性を実装する場合に便利です。

**注意**生涯の注釈は _説明的_ ではなく、 _規範_   _的_ であることを理解することが重要です。
これは、参照が有効である期間は、アノテーションではなくコードによって決定されることを意味します。
しかし、アノテーションは、コンパイラが参照の有効性をチェックするのに使用するライフタイムに関する情報を提供します。
コンパイラは単純なケースではアノテーションなしで行うことができますが、複雑なシナリオではプログラマのサポートが必要です。

[traits]: traits.html

# 構文

`'a`は生涯a'を読む。
技術的には、すべてのリファレンスにはそれに関連する寿命がありますが、コンパイラでは一般的なケースでそれらを省略することができます（つまり、[「ライフタイム・エリート」][lifetime-elision]は省略します）。
それに着く前に、明示的な生涯を使った簡単な例を見てみましょう。

[lifetime-elision]: #lifetime-elision

```rust,ignore
fn bar<'a>(...)
```

以前は[関数の構文][functions]について少し話をしましたが、関数の名前の後に`<>`記述しませんでした。
関数は、`<>` sの間に 'generic parameters'を持つことができます。そのうちの生涯は1種類です。
この[本の後半では、][generics]他の種類のジェネリックについて議論しますが、今のところ、生涯の側面に焦点を当てましょう。

[functions]: functions.html
 [generics]: generics.html


私たちは、`<>`を使用して私たちの生涯を宣言します。
これは、と言っている`bar`、1つの寿命を持っています`'a`。
ライフタイムの異なる2つの参照パラメータがある場合は、次のようになります。


```rust,ignore
fn bar<'a, 'b>(...)
```

次にパラメータリストでは、命名したライフタイムを使用します。

```rust,ignore
...(x: &'a i32)
```

`&mut`リファレンスが必要な場合は、次のようにします。

```rust,ignore
...(x: &'a mut i32)
```

あなたが`&mut i32`と`&'a mut i32`を比較する`&mut i32`、それらは同じです。それは、生涯`'a` `&` `mut i32`間に`mut i32`です。
私たちは、読み`&mut i32` 「への変更可能な参照として`i32` 」と`&'a mut i32`への変更可能な参照として」 `i32`寿命を持ちます`'a` 』。

# `struct`

また、参照を含む[`struct`][structs]作業する場合は、明示的な存続期間が必要です。

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
#//    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.
    let y = &5; // これは`let _y = 5; let y = &_y;`と同じ`let _y = 5; let y = &_y;`。
    let f = Foo { x: y };

    println!("{}", f.x);
}
```

[structs]: structs.html

ご覧のように、`struct`は寿命も持つことができます。
関数と同様に、

```rust
struct Foo<'a> {
# x: &'a i32,
# }
```

生涯を宣言し、

```rust
# struct Foo<'a> {
x: &'a i32,
# }
```

それを使用します。
ではなぜここに生涯が必要なのでしょうか？
`Foo`への参照が含まれている`i32`への参照を失効させることができないようにする必要があります。

## `impl`ブロック

`Foo`メソッドを実装しましょう：

```rust
struct Foo<'a> {
    x: &'a i32,
}

impl<'a> Foo<'a> {
    fn x(&self) -> &'a i32 { self.x }
}

fn main() {
#//    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.
    let y = &5; // これは`let _y = 5; let y = &_y;`と同じ`let _y = 5; let y = &_y;`。
    let f = Foo { x: y };

    println!("x is: {}", f.x());
}
```

ご覧のように、`impl`ラインで`Foo`生存期間を宣言する必要があります。
私たちは繰り返し`'a`：機能上のように、二回`impl<'a>`生涯定義`'a`および`Foo<'a>`それを使用しています。

## 複数の生涯

複数の参照がある場合は、同じ生涯を複数回使用できます。

```rust
fn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {
#    x
# }
```

これは、`x`と`y`両方が同じスコープに対して生存しており、戻り値もそのスコープに対して有効であることを示しています。
`x`と`y`ライフタイムが異なるようにするには、複数のライフタイムパラメータを使用できます。

```rust
fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
#    x
# }
```

この例では、`x`と`y`有効スコープは異なりますが、戻り値の有効期間は`x`と同じです。

## スコープで考える

生涯について考える方法は、参照が有効である範囲を視覚化することです。
例えば：

```rust
fn main() {
#//    let y = &5;     // -+ `y` comes into scope.
#                    //  |
    let y = &5;     //  -+ `y`がスコープに入ります。|
#    // Stuff...     //  |
    // スタッフ... // |
#                    //  |
                    //  |
#//}                   // -+ `y` goes out of scope.
}                   //  -+ `y`は範囲外になります。
```

私たちの`Foo`追加する：

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
#//    let y = &5;           // -+ `y` comes into scope.
    let y = &5;           //  -+ `y`がスコープに入ります。
#//    let f = Foo { x: y }; // -+ `f` comes into scope.
#                          //  |
    let f = Foo { x: y }; //  -+ `f`がスコープに入ります。|
#    // Stuff...           //  |
    // スタッフ... // |
#                          //  |
                          //  |
#//}                         // -+ `f` and `y` go out of scope.
}                         //  -+ `f`と`y`は範囲外になります。
```

私たちの`f`は`y`の範囲内に住んでいるので、すべてが動作します。
もしそうでなければ？
このコードは機能しません：

```rust,ignore
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
#//    let x;                    // -+ `x` comes into scope.
#                              //  |
    let x;                    //  -+ `x`がスコープに入ります。|
#//    {                         //  |
    {                         //  |
#//        let y = &5;           // ---+ `y` comes into scope.
        let y = &5;           //  ---+ `y`がスコープに入ります。
#//        let f = Foo { x: y }; // ---+ `f` comes into scope.
        let f = Foo { x: y }; //  ---+ `f`がスコープに入ります。
#//        x = &f.x;             //  | | This causes an error.
        x = &f.x;             //  | |これにより、エラーが発生します。
#//    }                         // ---+ `f` and y go out of scope.
#                              //  |
    }                         //  ---+ `f`とyは範囲外になります。|
#//    println!("{}", x);        //  |
    println!("{}", x);        //  |
#//}                             // -+ `x` goes out of scope.
}                             //  -+ `x`は範囲外になります。
```

すごい！
ここからわかるように、`f`と`y`のスコープは`x`のスコープよりも小さくなっています。
しかし、`x = &f.x`を実行すると、`x`は範囲外に出てくるものへの参照になります。

名前付きのライフタイムは、これらのスコープに名前を付ける方法です。
何かに名前を付けることは、それについて話すことができるようになるための第一歩です。

## '静的

'static'という名前の生涯は特別な生涯です。
それは何かがプログラム全体の生存期間を持つことを伝えます。
ほとんどのRustプログラマーは、文字列を扱うときに最初に`'static`に出くわします：

```rust
let x: &'static str = "Hello, world.";
```

参照が常に生きているので、文字列リテラルの型は`&'static str`です。それらは最終バイナリのデータセグメントに焼き付けられます。
もう1つの例はグローバルです。

```rust
static FOO: i32 = 5;
let x: &'static i32 = &FOO;
```

これは、バイナリのデータセグメントに`i32`を追加し、`x`はそのバイナリの参照です。

## ライフタイムエリート

Rustは、関数の本体で強力なローカル型推論をサポートしますが、意図的に項目シグネチャの型についての推論を実行しません。
しかし人間工学的な理由から、生涯を判断する際には、「ライフタイムエリージョン」と呼ばれる非常に制限された二次推論アルゴリズムが適用されます。
ライフタイムエリージョンは、単に簡単に記憶でき、明白な3つのルールを使用して寿命パラメータを推定することにのみ関係する。
これは、生涯エリジョンが、アイテムの署名を書き込むための略語として機能し、実際のタイプが完全なローカル推論として適用される場合は隠さないことを意味します。

ライフタイムエリージョンについて言えば、*入力寿命*と*出力寿命*という用語を使用し*ます*。
*入力寿命*は、関数のパラメータに関連付けられた有効期間であり、*出力有効期間*は、関数の戻り値に関連付けられた有効期間です。
たとえば、この関数の入力有効期間は次のとおりです。

```rust,ignore
fn foo<'a>(bar: &'a str)
```

これは出力寿命を持っています：

```rust,ignore
fn foo<'a>() -> &'a str
```

これは、両方の位置で生涯を持っています：

```rust,ignore
fn foo<'a>(bar: &'a str) -> &'a str
```

ここに3つのルールがあります：

* 関数の引数の中で失われた各寿命は、別個の寿命パラメータになります。

* 厳密に1つの入力ライフタイムが存在する場合、そのライフタイムは、その関数の戻り値のすべての寿命が省略されたものに割り当てられます。

* そこに複数の入力寿命がありますが、それらのいずれかである場合`&self`または`&mut self`の寿命`self`すべて省略さ出力寿命に割り当てられています。

それ以外の場合は、出力ライフタイムを削除するのはエラーです。

### 例

生存期間がない関数のいくつかの例を次に示します。
私たちは、失われた生涯のそれぞれの例をその拡張された形と組み合わせました。

```rust,ignore
#//fn print(s: &str); // elided
fn print(s: &str); // 逃げた
#//fn print<'a>(s: &'a str); // expanded
fn print<'a>(s: &'a str); // 拡張された

#//fn debug(lvl: u32, s: &str); // elided
fn debug(lvl: u32, s: &str); // 逃げた
#//fn debug<'a>(lvl: u32, s: &'a str); // expanded
fn debug<'a>(lvl: u32, s: &'a str); // 拡張された
```

上記の例では、`lvl`は参照（`&`）ではないため、ライフタイムは必要ありません。
参照に関連するもの（参照を含む`struct`など）のみが寿命を必要とします。

```rust,ignore
#//fn substr(s: &str, until: u32) -> &str; // elided
fn substr(s: &str, until: u32) -> &str; // 逃げた
#//fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded
fn substr<'a>(s: &'a str, until: u32) -> &'a str; // 拡張された

#//fn get_str() -> &str; // ILLEGAL, no inputs
fn get_str() -> &str; // 不当な、入力がない

#//fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs
fn frob(s: &str, t: &str) -> &str; // 不合理な、2つの入力
#//fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is ambiguous
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; //  Expanded：出力の寿命があいまいです

#//fn get_mut(&mut self) -> &mut T; // elided
fn get_mut(&mut self) -> &mut T; // 逃げた
#//fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded
fn get_mut<'a>(&'a mut self) -> &'a mut T; // 拡張された

#//fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // elided
fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // 逃げた
#//fn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded
fn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // 拡張された

#//fn new(buf: &mut [u8]) -> BufWriter; // elided
fn new(buf: &mut [u8]) -> BufWriter; // 逃げた
#//fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // expanded
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // 拡張された
```
