# 寿命

これは、Rustの所有権体系を提示する3つの章の最後です。
これは、Rustの最も顕著で魅力的な機能の1つで、Rustの開発者はかなり知り合いになるはずです。
所有権とは、Rustが最大の目標である記憶域の安全性を達成する方法です。
いくつかの異なる概念があり、それぞれ独自の章があります。

* [ownership][ownership]、主な概念
* [borrowing][borrowing]、およびそれらの関連する特徴 '参照'
* あなたが今読んでいる寿命

これら3つの章は関連しており、順番に説明されています。
所有権システムを完全に理解するには、3つすべてが必要です。

[ownership]: ownership.html
 [borrowing]: references-and-borrowing.html


# メタ

詳細を知る前に、所有権システムに関する2つの重要な注意事項。

Rustは安全性とスピードに焦点を当てています。
これは、多くの「ゼロコスト抽象化」によってこれらの目標を達成します。つまり、Rustでは抽象化のコストをできるだけ少なくして機能させることを意味します。
所有権システムは、ゼロコスト抽象化の主要な例です。
このガイド _で説明する_ すべての分析は _、製譜時に行われます_ 。
これらの機能の実行時コストを支払うことはありません。

しかし、このシステムには一定のコストがあります。学習曲線。
Rustの新しいユーザーの多くは、Rust製譜器が作成者が有効だと思う算譜を製譜することを拒否する「borrow checkerとの戦い」と呼ばれることを経験しています。
これは、所有者がどのように動作するかについての演譜師の心的模型が、Rustが実装する実際のルールと一致しないためによく発生します。
最初は似たようなことを経験するでしょう。
ただし、経験豊かなRust開発者は、所有権体系のルールを一定期間使用すると、借用検査器との競争が少なくなることを報告しています。

そのことを念頭に置いて、寿命について学びましょう。

# 寿命

他の人が所有している資源への参照を貸し出すことは複雑になる可能性があります。
たとえば、次の一連の操作を想像してみてください。

1. 私はある種の資源への手綱を取得します。
2. 私はあなたに資源への参照を貸します。
3. 私はあなたがまだあなたの参照を持っている間、私は資源で完了し、それを割り当てを解除することを決定します。
4. あなたは資源を使用することに決めました。

そんなはずでは！　
参照が無効な資源を指しています。
資源が記憶域の場合、これは行方不明の指し手または '開放後使用'と呼ばれます。
このような状況の小さな例は次のようになります。

```rust,ignore
#//let r;              // Introduce reference: `r`.
let r;              // 参照を導入する。 `r`。
{
#//    let i = 1;      // Introduce scoped value: `i`.
    let i = 1;      // 有効範囲値を導入する。 `i`。
#//    r = &i;         // Store reference of `i` in `r`.
    r = &i;         //  `r`の`i`参照を格納します。
#//}                   // `i` goes out of scope and is dropped.
}                   //  `i`は範囲外に出て落ちます。

#//println!("{}", r);  // `r` still refers to `i`.
println!("{}", r);  //  `r`まだ`i`指します。
```

この問題を解決するには、ステップ3の後にステップ4が起こらないようにする必要があります。
上の小さな例では、Rust製譜器は機能内のさまざまな値の存続期間を見ることができるため、問題を報告することができます。

参照によって引数を取る機能があるとき、状況はより複雑になります。
次の例を考えてみましょう。

```rust,ignore
fn skip_prefix(line: &str, prefix: &str) -> &str {
#    // ...
    // ...
#   line
}

let line = "lang:en=Hello World!";
let lang = "en";

let v;
{
#//    let p = format!("lang:{}=", lang);  // -+ `p` comes into scope.
    let p = format!("lang:{}=", lang);  //  -+ `p`が有効範囲に入ります。
#//    v = skip_prefix(line, p.as_str());  //  |
    v = skip_prefix(line, p.as_str());  //  |
#//}                                       // -+ `p` goes out of scope.
}                                       //  -+ `p`は範囲外になります。
println!("{}", v);
```

ここでは、機能してい`skip_prefix` 2つの取り`&str`パラメータとして参照を単一返し`&str`参照を。
それを`line`と`p`への参照を渡すことで呼びます。寿命の異なる2つの変数。
`println!`の行の安全性は、`skip_prefix`機能によって返された参照が静止している`line`または既に脱落した`p`文字列を参照するかどうかによって決まります。

上記のあいまいさのために、Rustは譜面例の製譜を拒否します。
それを製譜するには、製譜器に参照の存続期間についてもっと詳しく伝える必要があります。
これは、機能宣言で明示的な存続期間を設定することによって行うことができます。

```rust
fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {
#    // ...
    // ...
#   line
}
```

今のところ構文に深く進まずに変更を調べてみましょう。後でそれを説明します。
最初の変更は操作法名の後に`<'a, 'b>`を追加することでした。
。これは、二つの寿命パラメータ導入`'a`と`'b`。
次に、機能型指示内の各参照は、`&`後に寿命名を追加することで、1つの存続時間パラメータに関連付けられました。
これは、異なる参照間の存続期間がどのように関係しているかを製譜器に伝えます。

その結果、製譜器ーは、`skip_prefix`の戻り値が`line`パラメーターと同じ有効期間であることを推測することができます。これにより、`p`が元の例の範囲外になった後でも`v`参照を安全に使用できるようになります。

製譜器は`skip_prefix`戻り値の使用を検証できるだけでなく、実装が機能宣言によって確立された約束事に確実に従うようにすることもできます。
これは、特に[本の後半で][traits]導入される特性を実装する場合に便利です。

**注意**寿命の注釈は _説明的_ ではなく、 _規範_   _的_ であることを理解することが重要です。
これは、参照が有効である期間は、注釈ではなく譜面によって決定されることを意味します。
しかし、注釈は、製譜器が参照の有効性をチェックするのに使用する寿命に関する情報を提供します。
製譜器は単純なケースでは注釈なしで行うことができますが、複雑な場合では演譜師のサポートが必要です。

[traits]: traits.html

# 構文

`'a`は寿命a'を読む。
技術的には、すべての参照にはそれに関連する寿命がありますが、製譜器では一般的なケースでそれらを省略することができます（つまり、[「寿命省略」][lifetime-elision]は省略します）。
それに着く前に、明示的な寿命を使った簡単な例を見てみましょう。

[lifetime-elision]: #lifetime-elision

```rust,ignore
fn bar<'a>(...)
```

以前は[機能の構文][functions]について少し話をしましたが、機能の名前の後に`<>`記述しませんでした。
機能は、`<>` sの間に '総称パラメーター'を持つことができます。そのうちの寿命は1種類です。
この[本の後半では、][generics]他の種類の総称化について議論しますが、今のところ、寿命の側面に焦点を当てましょう。

[functions]: functions.html
 [generics]: generics.html


`<>`を使用して寿命を宣言します。
これは、と言っている`bar`、1つの寿命を持っています`'a`。
寿命の異なる2つの参照パラメータがある場合は、次のようになります。


```rust,ignore
fn bar<'a, 'b>(...)
```

次にパラメータリストでは、命名した寿命を使用します。

```rust,ignore
...(x: &'a i32)
```

`&mut`参照が必要な場合は、次のようにします。

```rust,ignore
...(x: &'a mut i32)
```

あなたが`&mut i32`と`&'a mut i32`を比較する`&mut i32`、それらは同じです。それは、寿命`'a` `&` `mut i32`間に`mut i32`です。
読み`&mut i32` 「への変更可能な参照として`i32` 」と`&'a mut i32`への変更可能な参照として」 `i32`寿命を持ちます`'a` 』。

# `struct`

また、参照を含む[`struct`][structs]作業する場合は、明示的な存続期間が必要です。

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
#//    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.
    let y = &5; // これは`let _y = 5; let y = &_y;`と同じ`let _y = 5; let y = &_y;`。
    let f = Foo { x: y };

    println!("{}", f.x);
}
```

[structs]: structs.html

ご覧のように、`struct`は寿命も持つことができます。
機能と同様に、

```rust
struct Foo<'a> {
# x: &'a i32,
# }
```

寿命を宣言し、

```rust
# struct Foo<'a> {
x: &'a i32,
# }
```

それを使用します。
ではなぜここに寿命が必要なのでしょうか？　
`Foo`への参照が含まれている`i32`への参照を失効させることができないようにする必要があります。

## `impl`段落

`Foo`操作法を実装しましょう。

```rust
struct Foo<'a> {
    x: &'a i32,
}

impl<'a> Foo<'a> {
    fn x(&self) -> &'a i32 { self.x }
}

fn main() {
#//    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.
    let y = &5; // これは`let _y = 5; let y = &_y;`と同じ`let _y = 5; let y = &_y;`。
    let f = Foo { x: y };

    println!("x is: {}", f.x());
}
```

ご覧のように、`impl`行で`Foo`寿命を宣言する必要があります。
繰り返し`'a`。機能上のように、二回`impl<'a>`寿命定義`'a`および`Foo<'a>`それを使用しています。

## 複数の寿命

複数の参照がある場合は、同じ寿命を複数回使用できます。

```rust
fn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {
#    x
# }
```

これは、`x`と`y`両方が同じ有効範囲に対して生存しており、戻り値もその有効範囲に対して有効であることを示しています。
`x`と`y`寿命が異なるようにするには、複数の寿命パラメータを使用できます。

```rust
fn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
#    x
# }
```

この例では、`x`と`y`有効範囲は異なりますが、戻り値の有効期間は`x`と同じです。

## 有効範囲で考える

寿命について考える方法は、参照が有効である範囲を視覚化することです。
例えば。

```rust
fn main() {
#//    let y = &5;     // -+ `y` comes into scope.
#                    //  |
    let y = &5;     //  -+ `y`が有効範囲に入ります。|
#    // Stuff...     //  |
    // 何かする // |
#                    //  |
                    //  |
#//}                   // -+ `y` goes out of scope.
}                   //  -+ `y`は範囲外になります。
```

`Foo`追加する。

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
#//    let y = &5;           // -+ `y` comes into scope.
    let y = &5;           //  -+ `y`が有効範囲に入ります。
#//    let f = Foo { x: y }; // -+ `f` comes into scope.
#                          //  |
    let f = Foo { x: y }; //  -+ `f`が有効範囲に入ります。|
#    // Stuff...           //  |
    // 何かする // |
#                          //  |
                          //  |
#//}                         // -+ `f` and `y` go out of scope.
}                         //  -+ `f`と`y`は範囲外になります。
```

`f`は`y`の範囲内に存在しているので、すべてが動作します。
もしそうでなければ？　
この譜面は機能しません。

```rust,ignore
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
#//    let x;                    // -+ `x` comes into scope.
#                              //  |
    let x;                    //  -+ `x`が有効範囲に入ります。|
#//    {                         //  |
    {                         //  |
#//        let y = &5;           // ---+ `y` comes into scope.
        let y = &5;           //  ---+ `y`が有効範囲に入ります。
#//        let f = Foo { x: y }; // ---+ `f` comes into scope.
        let f = Foo { x: y }; //  ---+ `f`が有効範囲に入ります。
#//        x = &f.x;             //  | | This causes an error.
        x = &f.x;             //  | |これにより、誤りが発生します。
#//    }                         // ---+ `f` and y go out of scope.
#                              //  |
    }                         //  ---+ `f`とyは範囲外になります。|
#//    println!("{}", x);        //  |
    println!("{}", x);        //  |
#//}                             // -+ `x` goes out of scope.
}                             //  -+ `x`は範囲外になります。
```

すごい！　
ここからわかるように、`f`と`y`の有効範囲は`x`の有効範囲よりも小さくなっています。
しかし、`x = &f.x`を実行すると、`x`は範囲外に出てくるものへの参照になります。

名前付きの寿命は、これらの有効範囲に名前を付ける方法です。
何かに名前を付けることは、それについて話すことができるようになるための第一歩です。

## '静的

'static'という名前の寿命は特別な寿命です。
それは何かが算譜全体の寿命を持つことを伝えます。
ほとんどのRust演譜師は、文字列を扱うときに最初に`'static`に出くわします。

```rust
let x: &'static str = "Hello, world.";
```

参照が常に生きているので、文字列直書きの型は`&'static str`です。それらは最終二進譜のデータセグメントに焼き付けられます。
もう1つの例は全体です。

```rust
static FOO: i32 = 5;
let x: &'static i32 = &FOO;
```

これは、二進譜のデータセグメントに`i32`を追加し、`x`はその二進譜の参照です。

## 寿命省略

Rustは、機能の本体で強力なローカル型推論をサポートしますが、意図的に項目型指示の型についての推論を実行しません。
しかし使い勝手の理由から、寿命を判断する際には、「寿命省略」と呼ばれる非常に制限された二次推論計算手続きが適用されます。
寿命省略は、単に簡単に記憶でき、明白な3つのルールを使用して寿命パラメータを推定することにのみ関係します。
これは、寿命省略が、項目の署名を書き込むための略語として機能し、実際の型が完全なローカル推論として適用される場合は隠さないことを意味します。

寿命省略について言えば、*入力寿命*と*出力寿命*という用語を使用し*ます*。
*入力寿命*は、機能のパラメータに関連付けられた有効期間であり、*出力有効期間*は、機能の戻り値に関連付けられた有効期間です。
たとえば、この機能の入力有効期間は次のとおりです。

```rust,ignore
fn foo<'a>(bar: &'a str)
```

これは出力寿命を持っています。

```rust,ignore
fn foo<'a>() -> &'a str
```

これは、両方の位置で寿命を持っています。

```rust,ignore
fn foo<'a>(bar: &'a str) -> &'a str
```

ここに3つのルールがあります。

* 機能の引数の中で失われた各寿命は、別個の寿命パラメータになります。

* 厳密に1つの入力寿命が存在する場合、その寿命は、その機能の戻り値のすべての寿命が省略されたものに割り当てられます。

* そこに複数の入力寿命がありますが、それらのいずれかである場合`&self`または`&mut self`の寿命`self`すべて省略さ出力寿命に割り当てられています。

それ以外の場合は、出力寿命を削除するのは誤りです。

### 例

寿命がない機能のいくつかの例を次に示します。
失われた寿命のそれぞれの例をその延長された形と組み合わせました。

```rust,ignore
#//fn print(s: &str); // elided
fn print(s: &str); // 逃げた
#//fn print<'a>(s: &'a str); // expanded
fn print<'a>(s: &'a str); // 延長された

#//fn debug(lvl: u32, s: &str); // elided
fn debug(lvl: u32, s: &str); // 逃げた
#//fn debug<'a>(lvl: u32, s: &'a str); // expanded
fn debug<'a>(lvl: u32, s: &'a str); // 延長された
```

上記の例では、`lvl`は参照（`&`）ではないため、寿命は必要ありません。
参照に関連するもの（参照を含む`struct`など）のみが寿命を必要とします。

```rust,ignore
#//fn substr(s: &str, until: u32) -> &str; // elided
fn substr(s: &str, until: u32) -> &str; // 逃げた
#//fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded
fn substr<'a>(s: &'a str, until: u32) -> &'a str; // 延長された

#//fn get_str() -> &str; // ILLEGAL, no inputs
fn get_str() -> &str; // 不適当、入力がない

#//fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs
fn frob(s: &str, t: &str) -> &str; // 筋が通らない、2つの入力
#//fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is ambiguous
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; //  Expanded。出力の寿命があいまいです

#//fn get_mut(&mut self) -> &mut T; // elided
fn get_mut(&mut self) -> &mut T; // 逃げた
#//fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded
fn get_mut<'a>(&'a mut self) -> &'a mut T; // 延長された

#//fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // elided
fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // 逃げた
#//fn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded
fn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // 延長された

#//fn new(buf: &mut [u8]) -> BufWriter; // elided
fn new(buf: &mut [u8]) -> BufWriter; // 逃げた
#//fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // expanded
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // 延長された
```
