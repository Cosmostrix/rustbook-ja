# 生ポインタ

Rustには、標準ライブラリにいくつかの異なるスマートポインタタイプがありますが、特別なものには2つのタイプがあります。
Rustの安全性の大部分はコンパイル時のチェックに由来しますが、生ポインタにはそのような保証は[unsafe][unsafe]、使用するのが[unsafe][unsafe]ではあり[unsafe][unsafe]。

`*const T`と`*mut T`は、Rustでは「生ポインタ」と呼ばれます。
場合によっては、ある種の図書館を書くときに何らかの理由でRustの安全保証を回避する必要があります。
この場合、生のポインタを使用してライブラリを実装し、ユーザに安全なインタフェースを公開することができます。
例えば、`*`ポインタはエイリアス化が許され、共有所有権型やスレッドセーフな共有メモリ型（`Rc<T>`と`Arc<T>`型はどちらも完全にRustで実装されています）を書くために使用できます。

ここでは、他のポインタ型とは異なる生ポインタについて覚えておくべきことがいくつかあります。
彼ら：

- 有効なメモリを指すことが保証されておらず、NULLでないことも保証されていません（`Box`と`&`両方と異なります）。
- `Box`と違って自動クリーンアップがないので、手動でリソースを管理する必要があります。
- プレーン、古いデータ、つまり、彼らは再びとは異なり、所有権を移動しないでくださいある`Box`ので、錆コンパイラは、後の使用の自由のようなバグを防ぐことはできません、。
- `&`とは異なり、生存期間の形が不足しているため、コンパイラはポインタをぶら下げることを理由に考えることはできません。
   そして
- `*const T`介して直接許可されていない突然変異以外のエイリアシングまたは可変性についての保証はない。

# 基本

生のポインタを作成することは完全に安全です：

```rust
let x = 5;
let raw = &x as *const i32;

let mut y = 10;
let raw_mut = &mut y as *mut i32;
```

ただし、逆参照はありません。
これは動作しません：

```rust,ignore
let x = 5;
let raw = &x as *const i32;

println!("raw points at {}", *raw);
```

それはこのエラーを与える：

```text
error: dereference of raw pointer requires unsafe function or block [E0133]
     println!("raw points at {}", *raw);
                                  ^~~~
```

未処理のポインタを間接参照すると、間違った場所を指していないという責任を負うことになります。
したがって、あなたは`unsafe`ことが必要です：

```rust
let x = 5;
let raw = &x as *const i32;

let points_at = unsafe { *raw };

println!("raw points at {}", points_at);
```

生ポインタに関するその他の操作については[、APIのマニュアルを][rawapi]参照し[て][rawapi]ください。

[unsafe]: unsafe.html
 [rawapi]: ../../std/primitive.pointer.html


# FFI

生ポインタはFFIにとって便利です：Rustの`*const T`と`*mut T`はそれぞれCの`const T*`と`T*`に似ています。
この使用の詳細については、[FFIの章を][ffi]参照してください。

[ffi]: ffi.html

# 参照と生ポインタ

実行時には、生ポインタ`*`と同じデータを指す参照は同じ表現をしています。
実際、`&T`リファレンスは、安全なコードの`*const T`生のポインタに暗黙的に強制します。また、`mut`バリアントも同様です（両方の変換は`value as *const T`と`value as *mut T`明示的に実行できます）。

`*const`から参照`&`に反対方向に行くことは安全ではありません。
`&T`は常に有効なので、少なくとも生ポインタ`*const T`はタイプ`T`有効なインスタンスを指していなければなりません。
さらに、結果として生じるポインタは、参照のエイリアシングおよび変更可能性の法則を満たさなければならない。
コンパイラーは、これらのプロパティーがどのような参照にも当てはまりますが、それらのプロパティーはどのように作成されるかにかかわらず、未処理のポインターからの変換ではそれらが保持されていると主張しています。
プログラマ*は*これを保証し*なければなりませ*ん。

変換に推奨される方法は次のとおりです。

```rust
#// Explicit cast:
// 明示的なキャスト：
let i: u32 = 1;
let p_imm: *const u32 = &i as *const u32;

#// Implicit coercion:
// 暗黙の強制：
let mut m: u32 = 2;
let p_mut: *mut u32 = &mut m;

unsafe {
    let ref_imm: &u32 = &*p_imm;
    let ref_mut: &mut u32 = &mut *p_mut;
}
```

`&*x`逆参照スタイルは、`transmute`を使用するよりも優先されます。
後者は必要以上に強力であり、操作の制限が厳しくなると誤った使い方が難しくなります。
例えば、`x`はポインタである必要があります（`transmute`とは異なります）。
