# 生指し手

Rustには、標準譜集にいくつかの異なるスマート指し手型がありますが、特別なものには2つの型があります。
Rustの安全性の大部分は製譜時のチェックに由来しますが、生指し手にはそのような保証は[unsafe][unsafe]、使用するのが[unsafe][unsafe]ではあり[unsafe][unsafe]。

`*const T`と`*mut T`は、Rustでは「生指し手」と呼ばれます。
場合によっては、ある種の譜集を書くときに何らかの理由でRustの安全保証を回避する必要があります。
この場合、生の指し手を使用して譜集を実装し、ユーザに安全な接点を公開することができます。
例えば、`*`指し手は別名化が許され、共有所有権型や走脈セーフな共有記憶型（`Rc<T>`と`Arc<T>`型はどちらも完全にRustで実装されています）を書くために使用できます。

ここでは、他の指し手型とは異なる生指し手について覚えておくべきことがいくつかあります。
彼ら。

- 有効な記憶を指すことが保証されておらず、NULLでないことも保証されていません（`Box`と`&`両方と異なります）。
- `Box`と違って自動後始末がないので、手動で資源を管理する必要があります。
- そのまま、古いデータ、つまり、それらは再びとは異なり、所有権を移動しないでくださいある`Box`ので、Rust製譜器は、後の使用の自由のようなバグを防ぐことはできません、。
- `&`とは異なり、寿命の形が不足しているため、製譜器は指し手をぶら下げることを理由に考えることはできません。
   そして
- `*const T`介して直接許可されていない変更以外の別名付与または可変性についての保証はない。

# 基本

生の指し手を作成することは完全に安全です。

```rust
let x = 5;
let raw = &x as *const i32;

let mut y = 10;
let raw_mut = &mut y as *mut i32;
```

ただし、逆参照はありません。
これは動作しません。

```rust,ignore
let x = 5;
let raw = &x as *const i32;

println!("raw points at {}", *raw);
```

それはこの誤りを与える。

```text
error: dereference of raw pointer requires unsafe function or block [E0133]
     println!("raw points at {}", *raw);
                                  ^~~~
```

未処理の指し手を間接参照すると、間違った場所を指していないという責任を負うことになります。
したがって、あなたは`unsafe`ことが必要です。

```rust
let x = 5;
let raw = &x as *const i32;

let points_at = unsafe { *raw };

println!("raw points at {}", points_at);
```

生指し手に関するその他の操作については[、APIの説明書を][rawapi]参照し[て][rawapi]ください。

[unsafe]: unsafe.html
 [rawapi]: ../../std/primitive.pointer.html


# FFI

生指し手はFFIにとって便利です。Rustの`*const T`と`*mut T`はそれぞれCの`const T*`と`T*`に似ています。
この使用の詳細については、[FFIの章を][ffi]参照してください。

[ffi]: ffi.html

# 参照と生指し手

実行時には、生指し手`*`と同じデータを指す参照は同じ式をしています。
実際、`&T`参照は、安全な譜面の`*const T`生の指し手に暗黙的に強制型変換します。また、`mut`場合値も同様です（両方の変換は`value as *const T`と`value as *mut T`明示的に実行できます）。

`*const`から参照`&`に反対方向に行くことは安全ではありません。
`&T`は常に有効なので、少なくとも生指し手`*const T`は型`T`有効な実例を指していなければなりません。
さらに、結果として生じる指し手は、参照の別名付与および変更可能性の法則を満たさなければならない。
製譜器ーは、これらのプロパティーがどのような参照にも当てはまりますが、それらのプロパティーはどのように作成されるかにかかわらず、未処理の指し手ーからの変換ではそれらが保持されていると主張しています。
演譜師*は*これを保証し*なければなりませ*ん。

変換に推奨される方法は次のとおりです。

```rust
#// Explicit cast:
// 明示的なキャスト。
let i: u32 = 1;
let p_imm: *const u32 = &i as *const u32;

#// Implicit coercion:
// 暗黙の強制型変換。
let mut m: u32 = 2;
let p_mut: *mut u32 = &mut m;

unsafe {
    let ref_imm: &u32 = &*p_imm;
    let ref_mut: &mut u32 = &mut *p_mut;
}
```

`&*x`逆参照スタイルは、`transmute`を使用するよりも優先されます。
後者は必要以上に強力であり、操作の制限が厳しくなると誤った使い方が難しくなります。
例えば、`x`は指し手である必要があります（`transmute`とは異なります）。
