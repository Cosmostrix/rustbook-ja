# プリミティブ型

Rust言語には、「プリミティブ」と見なされる多くのタイプがあります。
これは、それらが言語に組み込まれていることを意味します。
錆は、標準ライブラリがこれらのものの上に構築された多くの有用な型を提供するようにも構成されていますが、これらは最も基本的なものです。

# ブール

錆には`bool`という名前の`bool`型が組み込まれています。
`true`と`false` 2つの値があり`false`。

```rust
let x = true;

let y: bool = false;
```

ブール値の一般的な使用は[条件付きの`if`です][if]。

[if]: if.html

`bool`の詳細[は、標準ライブラリのドキュメントを参照してください][bool]。

[bool]: ../../std/primitive.bool.html

# `char`
`char`型は、単一のUnicodeスカラー値を表します。
1つのチックで`char`を作成することができます：（`'`）

```rust
let x = 'x';
let two_hearts = '💕';
```

他の言語とは異なり、これはRustの`char`が1バイトではなく4バイトであることを意味します。

`char`の他のドキュメント[は標準ライブラリのドキュメントにあります][char]。

[char]: ../../std/primitive.char.html

# 数値型

Rustは、符号付きおよび符号なし、固定および可変、浮動小数点および整数のいくつかのカテゴリでさまざまな数値型を持っています。

これらのタイプは、カテゴリとサイズの2つの部分で構成されています。
たとえば、`u16`は16ビットのサイズを持つ符号なし型です。
より多くのビットを使用すると、より大きな数を持つことができます。

数値リテラルが型の推論を引き起こさない場合は、デフォルトで次のようになります。

```rust
#//let x = 42; // `x` has type `i32`.
let x = 42; //  `x`はタイプ`i32`です。

#//let y = 1.0; // `y` has type `f64`.
let y = 1.0; //  `y`は`f64`型です。
```

さまざまな数値型のリストがあり、標準ライブラリのドキュメントへのリンクがあります。

* [i8](../../std/primitive.i8.html)
* [i16](../../std/primitive.i16.html)
* [i32](../../std/primitive.i32.html)
* [i64](../../std/primitive.i64.html)
* [u8](../../std/primitive.u8.html)
* [u16](../../std/primitive.u16.html)
* [u32](../../std/primitive.u32.html)
* [u64](../../std/primitive.u64.html)
* [isize](../../std/primitive.isize.html)
* [usize](../../std/primitive.usize.html)
* [f32](../../std/primitive.f32.html)
* [f64](../../std/primitive.f64.html)

カテゴリ別に見てみましょう：

## 署名付きおよび署名なし

整数型には、符号付きと符号なしの2種類があります。
違いを理解するために、4ビットのサイズの数値を考えてみましょう。
符号付きの4ビット数は、`-8`から`+7`までの数値を格納できます。
符号付き数値は「2の補数表現」を使用します。
符号なしの4ビット数は、ネガを格納する必要がないため、`0` `+15`値を格納できます。

符号なしタイプはそのカテゴリに`u`を使用し、符号付きタイプは`i`使用します。
`i`は整数である。
したがって、`u8`は8ビットの符号なしの数値で、`i8`は8ビットの符号付き数値です。

## 固定サイズのタイプ

固定長タイプは、その表現に特定のビット数を持ちます。
有効ビットサイズは、`8`、 `16`、 `32`、及び`64`。
したがって、`u32`は符号なし32ビット整数で、`i64`は符号付き64ビット整数です。

## 可変サイズの型

Rustは、その特定のサイズが基礎となるマシンアーキテクチャに依存するタイプも提供します。
それらの範囲は任意のコレクションのサイズを表現するのに十分なので、これらのタイプはカテゴリとして 'サイズ'を持ちます。
彼らは、署名されたものと無署名のものがあります。`isize`、 `usize`と`usize` 2種類があります。

## 浮動小数点型

錆には、`f32`と`f64` 2つの浮動小数点型もあります。
これらは、IEEE-754の単精度および倍精度の数値に対応します。

# 配列

多くのプログラミング言語と同様に、Rustは一連の事柄を表現するリスト型を持っています。
最も基本的なのは、同じタイプの要素の固定サイズのリストである*配列*です。
デフォルトでは、配列は不変です。

```rust
#//let a = [1, 2, 3]; // a: [i32; 3]
let a = [1, 2, 3]; //  a： [i32; 3]
#//let mut m = [1, 2, 3]; // m: [i32; 3]
let mut m = [1, 2, 3]; //  m： [i32; 3]
```

配列には`[T; N]`
`[T; N]`。
[ジェネリックスのセクションで、][generics]この`T`表記について[説明し][generics]ます。
`N`は、配列の長さのコンパイル時定数です。

配列の各要素を同じ値に初期化するための省略表現があります。
この例では`a`各要素は`0`に初期化され`0`。

```rust
#//let a = [0; 20]; // a: [i32; 20]
let a = [0; 20]; //  a： [i32; 20]
```

`a.len()`配列`a`要素数を得ることができます：

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
```

*添字表記*を使用して、配列の特定の要素にアクセスできます。

```rust
#//let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]
let names = ["Graydon", "Brian", "Niko"]; // 名前： [&str; 3]

println!("The second name is: {}", names[1]);
```

ほとんどのプログラミング言語と同様に、添え字はゼロから始まります。したがって、最初の名前は`names[0]`で、2番目の名前は`names[1]`です。
上記の例では`The second name is: Brian`です。
配列にない添字を使用しようとすると、エラーが発生します。配列アクセスは実行時に境界チェックされます。
このような誤ったアクセスは、他のシステムプログラミング言語の多くのバグの原因です。

`array`のドキュメントについて[は、標準ライブラリのドキュメントを参照してください][array]。

[array]: ../../std/primitive.array.html

# スライス

「スライス」は、別のデータ構造への参照（または「参照」）です。
これらは、コピーせずにアレイの一部に安全かつ効率的にアクセスできるようにするのに便利です。
たとえば、メモリに読み込まれたファイルの1行だけを参照することができます。
本来、スライスは直接作成されるのではなく、既存の変数バインディングから作成されます。
スライスは定義された長さを持ち、可変または不変にすることができます。

内部的には、スライスはデータの先頭と長さのポインタとして表されます。

## スライス構文

`&`と`[]`組み合わせを使用して、さまざまなものからスライスを作成できます。
`&`はスライスが[references]に似ていることを示します。これについては後で詳しく説明します。
範囲を持つ`[]`はスライスの長さを定義します：

```rust
let a = [0, 1, 2, 3, 4];
#//let complete = &a[..]; // A slice containing all of the elements in `a`.
let complete = &a[..]; // 内のすべての要素を含むスライス。`a`
#//let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.
let middle = &a[1..4]; // スライス：要素のみ`a` `1`、 `2`、および`3`。
```

スライスには`&[T]`タイプがあります。
私たちは、そのことについて話しましょう`T`私たちがカバーしたときに[generics][generics]。

[generics]: generics.html

スライスに関するその他のドキュメント[は、標準ライブラリのドキュメントにあります][slice]。

[slice]: ../../std/primitive.slice.html

# `str`
Rustの`str`型は、最も基本的な文字列型です。
[unsized型][dst]として、それ自体はそれほど有用ではありませんが、`&str`ように参照の後に置くと便利になり`&str`。
[Strings][strings]や[references]をカバーするときはさらに詳しく説明し[references]。

[dst]: unsized-types.html
 [strings]: strings.html
 [references]: references-and-borrowing.html


`str`に関するその他のドキュメント[は、標準ライブラリのドキュメントを参照してください][str]。

[str]: ../../std/primitive.str.html

# タプル

タプルは、固定サイズの順序付きリストです。
このような：

```rust
let x = (1, "hello");
```

括弧とカンマがこの2つの長さのタプルを形成します。
同じコードがありますが、注釈付きの型があります：

```rust
let x: (i32, &str) = (1, "hello");
```

ご覧のように、タプルの型はタプルのように見えますが、各位置は値ではなく型名を持ちます。
慎重な読者は、タプルは異種であることにも気付くでしょう：私たちはこのタプルに`i32`と`&str`を持ってい`&str`。
システムプログラミング言語では、文字列は他の言語よりも少し複雑です。
今のところ、*文字列スライス*として`&str`を読んでください。私たちはもっと早く学びます。

1つのタプルが同じタイプと[arity]を持つ場合、そのタプルを別のタプルに割り当てることができ[arity]。
タプルは同じ長さのときに同じアリティを持ちます。

[arity]: glossary.html#arity

```rust
#//let mut x = (1, 2); // x: (i32, i32)
let mut x = (1, 2); //  x：（i32、i32）
#//let y = (2, 3); // y: (i32, i32)
let y = (2, 3); //  y：（i32、i32）

x = y;
```

タプル内のフィールドには、非構造化*レットを*介してアクセスできます。
ここに例があります：

```rust
let (x, y, z) = (1, 2, 3);

println!("x is {}", x);
```

覚えておいてください[before][let]私はの左側たとき`let`文はバインディングを割り当てるよりも強力でしたか？
ここにいるのです。
`let`の左側にパターンを置くことができ、右側に一致する場合は、複数のバインディングを一度に割り当てることができます。
この場合は、`let` 「destructures」またはタプルを「壊す」、および3つのバインディングにビットを割り当てます。

[let]: variable-bindings.html

このパターンは非常に強力で、後で繰り返すことにします。

単一要素のタプルを括弧でくくられた値からコンマで区別できます。

```rust
#//(0,); // A single-element tuple.
(0,); // 単一要素タプル。
#//(0); // A zero in parentheses.
(0); // カッコ内は0です。
```

## タプルインデックス

また、インデックス構文でタプルのフィールドにアクセスすることもできます：


```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

配列のインデックスと同じように、それはゼロから始まりますが、配列のインデックスとは異なり、それが使用しています`.`
、むしろ`[]` s。

タプルに関するその他のドキュメント[は、標準ライブラリのドキュメントにあります][tuple]。

[tuple]: ../../std/primitive.tuple.html

# 機能

関数にも型があります！
彼らはこのように見えます：

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i32) -> i32 = foo;
```

この場合、`x`取る関数に「関数ポインタ」で`i32`戻る`i32`。
