# 基本型

Rust言語には、「基本型」と見なされる多くの型があります。
これは、それらが言語に組み込まれていることを意味します。
Rustは、標準譜集がこれらのものの上に構築された多くの有用な型を提供するようにも構成されていますが、これらは最も基本的なものです。

# ブール

Rustには`bool`という名前の`bool`型が組み込まれています。
`true`と`false` 2つの値があり`false`。

```rust
let x = true;

let y: bool = false;
```

真偽値の一般的な使用は[条件付きの`if`です][if]。

[if]: if.html

`bool`の詳細[は、標準譜集の開発資料を参照してください][bool]。

[bool]: ../../std/primitive.bool.html

# `char`
`char`型は、単一のUnicodeスカラー値を表します。
1つのチックで`char`を作成することができます。（`'`）

```rust
let x = 'x';
let two_hearts = '💕';
```

他の言語とは異なり、これはRustの`char`が1バイトではなく4バイトであることを意味します。

`char`の他の開発資料[は標準譜集の開発資料にあります][char]。

[char]: ../../std/primitive.char.html

# 数値型

Rustは、符号付きおよび符号なし、固定および可変、浮動小数点および整数のいくつかの分類でさまざまな数値型を持っています。

これらの型は、分類とサイズの2つの部分で構成されています。
たとえば、`u16`は16ビットのサイズを持つ符号なし型です。
より多くのビットを使用すると、より大きな数を持つことができます。

数値直書きが型の推論を引き起こさない場合は、自動的に次のようになります。

```rust
#//let x = 42; // `x` has type `i32`.
let x = 42; //  `x`は型`i32`です。

#//let y = 1.0; // `y` has type `f64`.
let y = 1.0; //  `y`は`f64`型です。
```

さまざまな数値型のリストがあり、標準譜集の開発資料へのリンクがあります。

* [i8](../../std/primitive.i8.html)
* [i16](../../std/primitive.i16.html)
* [i32](../../std/primitive.i32.html)
* [i64](../../std/primitive.i64.html)
* [u8](../../std/primitive.u8.html)
* [u16](../../std/primitive.u16.html)
* [u32](../../std/primitive.u32.html)
* [u64](../../std/primitive.u64.html)
* [isize](../../std/primitive.isize.html)
* [usize](../../std/primitive.usize.html)
* [f32](../../std/primitive.f32.html)
* [f64](../../std/primitive.f64.html)

分類別に見てみましょう。

## 署名付きおよび署名なし

整数型には、符号付きと符号なしの2種類があります。
違いを理解するために、4ビットのサイズの数値を考えてみましょう。
符号付きの4ビット数は、`-8`から`+7`までの数値を格納できます。
符号付き数値は「2の補数式」を使用します。
符号なしの4ビット数は、ネガを格納する必要がないため、`0` `+15`値を格納できます。

符号なし型はその分類に`u`を使用し、符号付き型は`i`使用します。
`i`は整数であます。
したがって、`u8`は8ビットの符号なしの数値で、`i8`は8ビットの符号付き数値です。

## 固定サイズの型

固定長型は、その式に特定のビット数を持ちます。
有効ビットサイズは、`8`、 `16`、 `32`、及び`64`。
したがって、`u32`は符号なし32ビット整数で、`i64`は符号付き64ビット整数です。

## 可変サイズの型

Rustは、その特定のサイズが基礎となる機械アーキテクチャに依存する型も提供します。
それらの範囲は任意の集まりのサイズを式するのに十分なので、これらの型は分類として 'サイズ'を持ちます。
それらは、符号つきものと符号なしものがあります。`isize`、 `usize`と`usize` 2種類があります。

## 浮動小数点数型

Rustには、`f32`と`f64` 2つの浮動小数点数型もあります。
これらは、IEEE-754の単精度および倍精度の数値に対応します。

# 配列

多くの演譜言語と同様に、Rustは一連の事柄を式するリスト型を持っています。
最も基本的なのは、同じ型の要素の固定サイズのリストである*配列*です。
自動的には、配列は不変です。

```rust
#//let a = [1, 2, 3]; // a: [i32; 3]
let a = [1, 2, 3]; //  a。 [i32; 3]
#//let mut m = [1, 2, 3]; // m: [i32; 3]
let mut m = [1, 2, 3]; //  m。 [i32; 3]
```

配列には`[T; N]`
`[T; N]`。
[総称化の章で、][generics]この`T`表記について[説明し][generics]ます。
`N`は、配列の長さの製譜時定数です。

配列の各要素を同じ値に初期化するための省略式があります。
この例では`a`各要素は`0`に初期化され`0`。

```rust
#//let a = [0; 20]; // a: [i32; 20]
let a = [0; 20]; //  a。 [i32; 20]
```

`a.len()`配列`a`要素数を得ることができます。

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
```

*添字表記*を使用して、配列の特定の要素にアクセスできます。

```rust
#//let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]
let names = ["Graydon", "Brian", "Niko"]; // 名前。 [&str; 3]

println!("The second name is: {}", names[1]);
```

ほとんどの演譜言語と同様に、添え字はゼロから始まります。したがって、最初の名前は`names[0]`で、2番目の名前は`names[1]`です。
上記の例では`The second name is: Brian`です。
配列にない添字を使用しようとすると、誤りが発生します。配列アクセスは実行時に境界チェックされます。
このような誤ったアクセスは、他のシステム演譜言語の多くのバグの原因です。

`array`の開発資料について[は、標準譜集の開発資料を参照してください][array]。

[array]: ../../std/primitive.array.html

# スライス

「スライス」は、別のデータ構造への参照（または「参照」）です。
これらは、コピーせずに配列の一部に安全かつ効率的にアクセスできるようにするのに便利です。
たとえば、記憶に読み込まれたファイルの1行だけを参照することができます。
本来、スライスは直接作成されるのではなく、既存の変数束縛から作成されます。
スライスは定義された長さを持ち、可変または不変にすることができます。

内部的には、スライスはデータの先頭と長さの指し手として表されます。

## スライス構文

`&`と`[]`組み合わせを使用して、さまざまなものからスライスを作成できます。
`&`はスライスが[references]に似ていることを示します。これについては後で詳しく説明します。
範囲を持つ`[]`はスライスの長さを定義します。

```rust
let a = [0, 1, 2, 3, 4];
#//let complete = &a[..]; // A slice containing all of the elements in `a`.
let complete = &a[..]; // 内のすべての要素を含むスライス。`a`
#//let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.
let middle = &a[1..4]; // スライス。要素のみ`a` `1`、 `2`、および`3`。
```

スライスには`&[T]`型があります。
そのことについて話しましょう`T`カバーしたときに[generics][generics]。

[generics]: generics.html

スライスに関するその他の開発資料[は、標準譜集の開発資料にあります][slice]。

[slice]: ../../std/primitive.slice.html

# `str`
Rustの`str`型は、最も基本的な文字列型です。
[unsized型][dst]として、それ自体はそれほど有用ではありませんが、`&str`ように参照の後に置くと便利になり`&str`。
[Strings][strings]や[references]をカバーするときはさらに詳しく説明し[references]。

[dst]: unsized-types.html
 [strings]: strings.html
 [references]: references-and-borrowing.html


`str`に関するその他の開発資料[は、標準譜集の開発資料を参照してください][str]。

[str]: ../../std/primitive.str.html

# 組

組は、固定サイズの順序付きリストです。
このような。

```rust
let x = (1, "hello");
```

かっことカンマがこの2つの長さの組を形成します。
同じ譜面がありますが、注釈付きの型があります。

```rust
let x: (i32, &str) = (1, "hello");
```

ご覧のように、組の型は組のように見えますが、各位置は値ではなく型名を持ちます。
慎重な読者は、組は異種であることにも気付くでしょう。この組に`i32`と`&str`を持ってい`&str`。
システム演譜言語では、文字列は他の言語よりも少し複雑です。
今のところ、*文字列スライス*として`&str`を読んでください。もっと早く学びます。

1つの組が同じ型と[arity]を持つ場合、その組を別の組に割り当てることができ[arity]。
組は同じ長さのときに同じ項数を持ちます。

[arity]: glossary.html#arity

```rust
#//let mut x = (1, 2); // x: (i32, i32)
let mut x = (1, 2); //  x。（i32、i32）
#//let y = (2, 3); // y: (i32, i32)
let y = (2, 3); //  y。（i32、i32）

x = y;
```

組内の欄には、非構造化*レットを*介してアクセスできます。
ここに例があります。

```rust
let (x, y, z) = (1, 2, 3);

println!("x is {}", x);
```

覚えておいてください[before][let]私はの左側たとき`let`文は束縛を割り当てるよりも強力でしたか？　
ここにいるのです。
`let`の左側にパターンを置くことができ、右側に一致する場合は、複数の束縛を一度に割り当てることができます。
この場合は、`let` 「destructures」または組を「壊す」、および3つの束縛にビットを割り当てます。

[let]: variable-bindings.html

このパターンは非常に強力で、後で繰り返すことにします。

単一要素の組をかっこでくくられた値からコンマで区別できます。

```rust
#//(0,); // A single-element tuple.
(0,); // 単一要素組。
#//(0); // A zero in parentheses.
(0); // カッコ内は0です。
```

## 組添字

また、添字構文で組の欄にアクセスすることもできます。


```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

配列の添字と同じように、それはゼロから始まりますが、配列の添字とは異なり、それが使用しています`.`
、むしろ`[]` s。

組に関するその他の開発資料[は、標準譜集の開発資料にあります][tuple]。

[tuple]: ../../std/primitive.tuple.html

# 機能

機能にも型があります！　
それらはこのように見えます。

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i32) -> i32 = foo;
```

この場合、`x`取る機能に「機能指し手」で`i32`戻る`i32`。
