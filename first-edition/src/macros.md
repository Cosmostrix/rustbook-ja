# マクロ

今では、Rustが譜面を抽象化し再利用するために提供する多くの道具について学びました。
これらの譜面再利用の単位は、豊富な意味構造を持っています。
たとえば、機能は型型指示を持ち、型パラメータは特性縛りを持ち、多重定義機能は特定の特性に属していなければなりません。

この構造は、Rustのコア抽象化が強力な製譜時の正しさチェックを持つことを意味します。
しかし、これは柔軟性の低下の代償を払っています。
繰り返される譜面のパターンを視覚的に特定すると、そのパターンをRustの意味論の中で総称化機能、特性、またはその他のものとして式することは困難または面倒です。

マクロを使用すると、構文レベルで抽象化することができます。
マクロ呼び出しは、"拡張された"構文形式の略です。
この展開は製譜の初期、静的チェックの前に行われます。
その結果、マクロは、Rustのコア抽象化では不可能な、多くの譜面再利用パターンを捕獲できます。

欠点は、マクロベースの譜面を理解するのが難しいということです。なぜなら組み込み規則が少なくて済むからです。
通常の機能と同様に、適切に動作するマクロは実装の理解なしに使用できます。
ただし、正常に動作するマクロを設計するのは難しい場合があります。
さらに、マクロ譜面の製譜器誤りは、開発者が使用するソースレベルの形式ではなく、展開された譜面の問題を記述するため、解釈が難しくなります。

これらの欠点は、マクロを「最後の手段」の何かにしています。
それはマクロが悪いと言っているわけではありません。
それらは時には本当に簡潔で、よく抽象化された譜面のために必要なので、それらはRustの一部です。
この相殺取引を念頭に置いてください。

# マクロを定義する

任意の数の要素を持つ[vector][vector]を初期化するために使用される`vec!`マクロを見たことがあります。

[vector]: vectors.html

```rust
let x: Vec<u32> = vec![1, 2, 3];
# assert_eq!(x, [1, 2, 3]);
```

任意の数の引数を取るので、これは普通の機能とすることはできません。
しかし、それを構文上の簡略式として想像することができます

```rust
let x: Vec<u32> = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
# assert_eq!(x, [1, 2, 3]);
```

この略式を、マクロを使って実装することができます。 [^actual]

[^actual]: The%20actual%20definition%20of%20%60vec!%60%20in%20libcollections%20differs%20from%20the
効率性と再利用性の理由からここに示したものです。

```rust
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
# fn main() {
#     assert_eq!(vec![1,2,3], [1, 2, 3]);
# }
```

うわー、それは新しい構文の多くです！　
それを分解しましょう。

```rust,ignore
macro_rules! vec { ... }
```

これは、`fn vec`が`vec`という名前の機能を定義するのと同じように、`vec`という名前のマクロを定義していることを示しています。
散文では、非公式に感嘆符でマクロの名前を書いています。例えば`vec!`。
感嘆符は、呼び出し構文の一部であり、マクロを通常の機能と区別するのに役立ちます。

## 照合

マクロは、模式照合のケースである一連のルールによって定義されます。
上記のとおり、

```rust,ignore
( $( $x:expr ),* ) => { ... };
```

これは`match`式のようなものですが、製譜時にRust構文ツリーで一致します。
セミコロンは、最後の（ここでは、唯一の）ケースでは選択肢です。
`=>`左側の「パターン」は「マッチャー」と呼ばれます。
これらは、言語内に[their own little grammar]持っ[their own little grammar]います。

[their own little grammar]: ../../reference/macros.html

正規式`$x:expr`は任意のRust式にマッチし、その構文木を 'metavariable' `$x`に束縛します。
識別子`expr`は '断片指定子'です。
完全な可能性がこの章の後半に列挙されています。
マッチャーを`$(...),*`囲むと、0個以上の式がカンマで区切られます。

特別なマッチャーの構文とは別に、マッチャーに表示される任意のRust字句は正確に一致しなければなりません。
例えば、

```rust,ignore
macro_rules! foo {
    (x => $e:expr) => (println!("mode X: {}", $e));
    (y => $e:expr) => (println!("mode Y: {}", $e));
}

fn main() {
    foo!(y => 3);
}
```

印字する

```text
mode Y: 3
```

と

```rust,ignore
foo!(z => 3);
```

製譜器誤りが発生する

```text
error: no rules expected the token `z`
```

## 拡張

マクロルールの右側は、ほとんどの場合、普通のRust構文です。
しかし、マッチャーによって捕捉された構文のビットでスプライスすることができます。
元の例から。

```rust,ignore
$(
    temp_vec.push($x);
)*
```

一致した各式`$x`は、マクロ展開で単一の`push`文を生成します。
展開の繰り返しは、マッチャーの繰り返しで「ロックステップ」に進みます（詳細はこちら）。

`$x`はすでに式にマッチすると宣言されているので、繰り返しはしません`:expr`右側は`:expr`です。
また、繰り返し演算子の一部としてコンマを区切ることもありません。
代わりに、繰り返し段落内にセミコロンを終端します。

もう1つの詳細。 `vec!`マクロには、右側に*2*組のカッコがあります。
それらはしばしば以下のように組み合わされます。

```rust,ignore
macro_rules! foo {
    () => {{
        ...
    }}
}
```

外側の中カッコは、`macro_rules!`構文の`macro_rules!`。
実際には、代わりに`()`または`[]`使用できます。
それらは単に右側全体を区切ります。

内かっこは拡張構文の一部です。
`vec!`マクロは式の文脈で使用されることを覚えておいてください。
`let` -bindingsを含む複数の文で式を書くには、段落を使います。
あなたのマクロが単一の式に展開されている場合、この追加の中かっこは必要ありません。

マクロが式を生成する*と宣言*したことはありません。
実際、これは式としてマクロを使用するまで決定されません。
注意して、いくつかの文脈で拡張が機能するマクロを書くことができます。
たとえば、データ型の省略形は、式またはパターンのいずれかとして有効です。

## 繰り返し

繰り返し演算子は、2つの主要な規則に従います。

1. `$(...)*`は、反復の1つの「層」を通ります。その層に含まれる`$name`のすべてについて、ロックステップで
2. それぞれの`$name`は、少なくとも一致した`$(...)*` s以下でなければなりません。
    それ以上の場合は、必要に応じて複製されます。

このバロックマクロは、外部繰り返しレベルからの変数の重複を示しています。

```rust
macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) => {
        &[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
```

それはマッチャーの構文の大部分です。
これらの例では、`$(...)*`使用してい`$(...)*`これは、「0以上の」一致です。
あるいは、「1つ以上の」一致に対して`$(...)+`を書くことができます。
両方の書式には、区切り文字が選択肢で含まれています。区切り文字には、`+`または`*`以外の字句を使用できます

このシステムは、「 [Macro-by-Example](https://www.cs.indiana.edu/ftp/techreports/TR206.pdf) 」（PDFリンク）に基づいています。

# 同名定義の混同回避

他の言語は、単純な文言置換を使用してマクロを実装するため、さまざまな問題が発生します。
たとえば、このC算譜は、予想される`25`代わりに`13`を出力します。

```text
#define FIVE_TIMES(x) 5 * x

int main() {
    printf("%d\n", FIVE_TIMES(2 + 3));
    return 0;
}
```

展開後、`5 * 2 + 3`となり、乗算は加算より優先されます。
Cマクロをたくさん使ったことがあるなら、おそらくこの問題を回避するための標準的な書き方と、5つまたは6つの他のものを知っているでしょう。
Rustでは、心配する必要はありません。

```rust
macro_rules! five_times {
    ($x:expr) => (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
```

メタ変数`$x`は単一の式ノードとして解析され、置換後も構文木にその場所を保持します。

マクロシステムにおけるもう一つの共通の問題は、「変数捕獲」です。
以下は、複数の文を含む段落を使用するCマクロです。

```text
#define LOG(msg) do { \
    int state = get_log_state(); \
    if (state > 0) { \
        printf("log(%d): %s\n", state, msg); \
    } \
} while (0)
```

ひどく間違っている単純な使用例があります。

```text
const char *state = "reticulating splines";
LOG(state);
```

これは

```text
const char *state = "reticulating splines";
do {
    int state = get_log_state();
    if (state > 0) {
        printf("log(%d): %s\n", state, state);
    }
} while (0);
```

`state`という名前の2番目の変数は、最初の変数を遮蔽します。
これは、print文が両方を参照する必要があるため、問題です。

同等のRustマクロは、望ましい動作をします。

```rust
# fn get_log_state() -> i32 { 3 }
macro_rules! log {
    ($msg:expr) => {{
        let state: i32 = get_log_state();
        if state > 0 {
            println!("log({}): {}", state, $msg);
        }
    }};
}

fn main() {
    let state: &str = "reticulating splines";
    log!(state);
}
```

これは、Rustが[hygienic macro system]持っているために[hygienic macro system]ます。
それぞれのマクロ展開は別々の「構文文脈」で行われ、各変数にはその構文文脈がタグ付けされています。
変数かのようです`state`内部の`main`変数と異なる「色」塗られている`state`マクロ内で、そのためそれらは競合しません。

[hygienic macro system]: https://en.wikipedia.org/wiki/Hygienic_macro

これはまた、呼び出し位置で新しい束縛を導入するマクロの機能を制限します。
次のような譜面は機能しません。

```rust,ignore
macro_rules! foo {
    () => (let x = 3;);
}

fn main() {
    foo!();
    println!("{}", x);
}
```

代わりに、変数名を呼び出しに渡す必要があります。そのため、正しい構文文脈でタグ付けされます。

```rust
macro_rules! foo {
    ($v:ident) => (let $v = 3;);
}

fn main() {
    foo!(x);
    println!("{}", x);
}
```

`let`束縛とループラベルは保持`let`ますが、[items][items]は保持されません。
したがって、次の譜面は製譜されます。

```rust
macro_rules! foo {
    () => (fn x() { });
}

fn main() {
    foo!();
    x();
}
```

[items]: ../../reference/items.html

# 再帰マクロ

マクロの展開には、同じマクロの呼び出しを拡張するなど、より多くのマクロ呼び出しを含めることができます。
これらの再帰マクロは、ツリー構造の入力を処理するのに便利です。

```rust
# #![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) => (());

    ($w:expr, $e:tt) => (write!($w, "{}", $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{
        write!($w, "<{}>", stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, "</{}>", stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
#//#   // FIXME(#21826)
#   //  FIXME（＃21826）
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&mut out,
        html[
            head[title["Macros guide"]]
            body[h1["Macros are the best!"]]
        ]);

    assert_eq!(out,
        "<html><head><title>Macros guide</title></head>\
         <body><h1>Macros are the best!</h1></body></html>");
}
```

# マクロ譜面の虫取り

マクロを展開した結果を見るには、`rustc --pretty expanded`実行します。
出力は通い箱全体を表しているので、元の製譜よりも優れた誤りメッセージを生成する`rustc`フィードバックすることもできます。
同じ名前の複数の変数（構文文脈は異なる）が同じ有効範囲内で動作している場合、--`--pretty expanded`出力は異なる意味を持つことに注意してください。
この場合、--`--pretty expanded,hygiene`は構文文脈について教えてくれます。

`rustc`は、マクロ虫取りに役立つ2つの構文拡張を提供します。
今のところ、それらは不安定であり、機能ゲートが必要です。

* `log_syntax!(...)`は製譜時に引数を標準出力に出力し、何も展開しません。

* `trace_macros!(true)`は、マクロが展開されるたびに製譜器のメッセージを有効にします。
   後で展開時に`trace_macros!(false)`使用してオフにします。

# 構文上の要件

Rust譜面に展開されていないマクロが含まれていても、完全な[構文ツリー][ast]として解析できます。
このプロパティは、譜面を処理する書房やその他の道具に非常に便利です。
また、Rustのマクロシステムの設計にはいくつかの影響があります。

[ast]: glossary.html#abstract-syntax-tree

1つの結果として、Rustは、マクロの呼び出しを解析するときに、マクロが

* ゼロ個以上の項目、
* ゼロ個以上の操作法、
* 式、
* 文、または
* パターン。

段落内でのマクロ呼び出しは、複数の項目や式/文を表す可能性があります。
Rustはこのあいまいさを解決するために単純なルールを使用します。
項目を表すマクロ呼び出しは、

* 中かっこで区切られたもの、例えば`foo! { ... }`、または
* セミコロンで終わる、例えば`foo!(...);`

拡張前解析の別の結果は、マクロ呼び出しが有効なRust字句で構成されていなければならないということです。
さらに、かっこ、角かっこ、および中かっこは、マクロ呼び出し内で対応させる必要があります。
たとえば、`foo!([)`は禁止されています。
これにより、Rustはマクロの呼び出しがどこで終了するかを知ることができます。

より正式には、マクロ呼び出し本体は一連の '字句ツリー'でなければなりません。
字句ツリーは再帰的に

* matching `()`、 `[]`、または`{}`で囲まれた一連の字句ツリー、または
* 他の単一の字句。

マッチャー内では、各メタ変数には、それが一致する構文形式を識別する「断片指定子」があります。

* `ident`。識別子。
   例。 `x`;
   `foo`。
* `path`。修飾された名前。
   例。 `T::SpecialA`。
* `expr`。式。
   例。 `2 + 2`;
   `if true { 1 } else { 2 }`;
   `f(42)`。
* `ty`。型。
   例。 `i32`;
   `Vec<(char, String)>`;
   `&T`。
* `pat`。パターン。
   例。 `Some(t)`;
   `(17, 'a')`;
   `_`。
* `stmt`。単一の文。
   例。 `let x = 3`。
* `block`。中かっこで区切られた一連の文と選択肢で式。
   例。 `{ log(error, "hi"); return 12; }`
`{ log(error, "hi"); return 12; }` `{ log(error, "hi"); return 12; }`。
* `item`。 [item][item]。
   例。 `fn foo() { }`;
`struct Bar;` 。
* `meta`。属性にある「メタ項目」。
   例。 `cfg(target_os = "windows")`。
* `tt`。単一の字句ツリー。

メタ変数の後の次の字句に関する追加の規則があります。

* `expr`および`stmt`変数の後には、`=> , ;` `stmt`
* `ty`と`path`変数の後には、`=> , = | ; : > [ { as where`
`=> , = | ; : > [ { as where`
* `pat`変数の後には、次のいずれかが続くことがあります。`=> , = | if in`
`=> , = | if in`
* 他の変数には任意の字句を続けることができます。

これらのルールは、Rustの構文が既存のマクロを壊さずに進化するための柔軟性を提供します。

マクロシステムは解析のあいまいさをまったく扱っていません。
たとえば、文法`$($i:ident)* $e:expr`は、構文解析に失敗します。なぜなら、構文解析算譜は`$i`解析と`$e`解析のどちらかを選択する必要があるからです。
特有の字句を前に置くように呼び出し構文を変更することで、問題を解決できます。
この場合、`$(I $i:ident)* E $e:expr`書くことができます。

[item]: ../../reference/items.html

# 有効範囲決定とマクロの輸入/輸出

マクロは名前解決の前に、製譜の初期段階で展開されます。
1つの欠点は、言語の他の構文と比較して、マクロの有効範囲が異なることです。

マクロの定義と拡張の両方は、通い箱のソースの深さ優先、字句順探索で行われます。
そのため、役区有効範囲で定義されたマクロは、後続の子`mod`項目の本体を含む同じ役区内の後続の譜面から見えます。
別の役区で定義されているマクロを使用する場合は、マクロを使用する*前に* `macro_use`属性を使用する必要があります。
マクロは役区`macros`定義されており、役区`client`内で使用したいとしましょう。
これは必須の役区定義順序です。

```rust
#[macro_use]
mod macros;
mod client;
```

逆の順序で製譜に失敗します。

```rust
mod client;
#[macro_use]
mod macros;
```

```bash
error: cannot find macro `my_macro!` in this scope
```

単一の`fn`本体内に定義されたマクロ、または役区有効範囲ではない他の場所にあるマクロは、その項目内でのみ表示されます。

役区がある場合は`macro_use`属性を、そのマクロは、子の後に親役区にも表示されている`mod`の項目。
親にも`macro_use`場合、マクロは親の`mod`項目の後に祖父母で表示されます。

`macro_use`属性は、`extern crate` `macro_use`にも表示されます。
この文脈では、外部通い箱から読み込みされるマクロを制御します。

```rust,ignore
#[macro_use(foo, bar)]
extern crate baz;
```

属性に`#[macro_use]`と指定した場合、すべてのマクロが読み込みされます。
`#[macro_use]`属性がない場合、マクロは読み込みされません。
`#[macro_export]`属性で定義されたマクロだけが読み込まれます。

通い箱のマクロを出力にリンクせずに読み込むには`#[no_link]`も使用します。

例。

```rust
macro_rules! m1 { () => (()) }

#// Visible here: `m1`.
// ここに表示されます。 `m1`。

mod foo {
#    // Visible here: `m1`.
    // ここに表示されます。 `m1`。

    #[macro_export]
    macro_rules! m2 { () => (()) }

#    // Visible here: `m1`, `m2`.
    // ここに表示されます。 `m1`、 `m2`。
}

#// Visible here: `m1`.
// ここに表示されます。 `m1`。

macro_rules! m3 { () => (()) }

#// Visible here: `m1`, `m3`.
// ここに表示されます。 `m1`、 `m3`。

#[macro_use]
mod bar {
#    // Visible here: `m1`, `m3`.
    // ここに表示されます。 `m1`、 `m3`。

    macro_rules! m4 { () => (()) }

#    // Visible here: `m1`, `m3`, `m4`.
    // ここに表示されます。 `m1`、 `m3`、 `m4`。
}

#// Visible here: `m1`, `m3`, `m4`.
// ここに表示されます。 `m1`、 `m3`、 `m4`。
# fn main() { }
```

この譜集に`#[macro_use] extern crate`が読み込みされると、`m2`だけが輸入されます。

Rust Referenceには、[マクロ関連の属性のリストがあります](../../reference/attributes.html#macro-related-attributes)。

# 変数`$crate`

マクロが複数の通い箱で使用される場合、さらに難しい問題が発生します。
`mylib`定義すると言う

```rust
pub fn increment(x: u32) -> u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) => ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) => ( ::mylib::increment($x) )
}
# fn main() { }
```

`inc_a`内でのみ動作します`mylib`ながら、`inc_b`唯一の譜集ーの外に動作します。
さらに、ユーザーが別の名前で`mylib`を輸入すると、`inc_b`が壊れます。

Rustは、（まだ）箱の参照のための同名定義の混同回避システムを持っていませんが、この問題の簡単な回避策を提供しています。
`foo`という名前の通い箱から輸入されたマクロ内で、特別なマクロ変数`$crate`は`::foo`展開されます。
対照的に、マクロが定義され、同じ枠で使用されると、`$crate`は何も展開しません。
これは、

```rust
#[macro_export]
macro_rules! inc {
    ($x:expr) => ( $crate::increment($x) )
}
# fn main() { }
```

譜集の内部と外部の両方で動作する単一のマクロを定義します。
機能名は`::increment`または`::mylib::increment`展開され`::mylib::increment`。

このシステムをシンプルで正確に保つために、`#[macro_use] extern crate ...`はあなたの通い箱のルートにのみ表示され、`mod`では表示されません。

# 深い終わり

入門の章では再帰マクロについて述べましたが、それは完全な話を与えませんでした。
再帰マクロは別の理由で便利です。再帰呼び出しのたびに、マクロの引数に模式照合する別の機会が与えられます。

極端な例として、Rustのマクロシステム内で[Bitwise Cyclic Tag](https://esolangs.org/wiki/Bitwise_Cyclic_Tag)オートマトンを実装することは、ほとんどお勧めできませんが、可能です。

```rust
macro_rules! bct {
#    // cmd 0:  d ... => ...
    //  cmd 0。d... =>...
    (0, $($ps:tt),* ; $_d:tt)
        => (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        => (bct!($($ps),*, 0 ; $($ds),*));

#    // cmd 1p:  1 ... => 1 ... p
    //  cmd 1p。1... => 1... p
    (1, $p:tt, $($ps:tt),* ; 1)
        => (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

#    // cmd 1p:  0 ... => 0 ...
    //  cmd 1p。0... => 0...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        => (bct!($($ps),*, 1, $p ; $($ds),*));

#    // Halt on empty data string:
    // 空のデータ文字列で停止。
    ( $($ps:tt),* ; )
        => (());
}
```

練習問題。マクロを使用して、上記の`bct!`マクロの定義における重複を減らします。

# 一般的なマクロ

Rust譜面で表示される一般的なマクロをいくつか導入します。

## パニック！　

このマクロは、現在の走脈にパニックを引き起こします。
あなたはそれにパニックにメッセージを与えることができます。

```rust,should_panic
panic!("oh no!");
```

## vec！　

`vec!`マクロは本の中で使われているので、すでに見たことがあります。
`Vec<T>`を簡単に作成します。

```rust
let v = vec![1, 2, 3, 4, 5];
```

繰り返し値を持つベクトルを作成することもできます。
たとえば、100個のゼロ。

```rust
let v = vec![0; 100];
```

## アサート！　
これらの2つのマクロはテストで使用されます。
`assert!`は真偽値を取ます。
`assert_eq!`は2つの値をとり、それらが等しいかどうかをチェックします。
`true`パス、`false` `panic!`。
このような。

```rust,should_panic
#// A-ok!
// いいよ！　

assert!(true);
assert_eq!(5, 3 + 2);

#// Nope :(
// いいえ:(

assert!(5 < 3);
assert_eq!(5, 3);
```

## 試してみて！　

誤り処理のために`try!`が使用されています。
`Result<T, E>`返すことができ、`Ok<T>`の場合は`T`を`return`、それが`Err(E)`場合はsを`return`ます。
このような。

```rust,no_run
use std::fs::File;

fn foo() -> std::io::Result<()> {
    let f = try!(File::create("foo.txt"));

    Ok(())
}
```

これはこれを行うよりもきれいです。

```rust,no_run
use std::fs::File;

fn foo() -> std::io::Result<()> {
    let f = File::create("foo.txt");

    let f = match f {
        Ok(t) => t,
        Err(e) => return Err(e),
    };

    Ok(())
}
```

## 到達不能！　

このマクロは、譜面を決して実行しないと思うときに使用されます。

```rust
if false {
    unreachable!();
}
```

時には、製譜器はあなたが決して実行することのない別の分岐を持つようにするかもしれません。
このような場合は、このマクロを使用してください。間違ってしまうと、そのマクロについて`panic!`ことがあります。

```rust
let x: Option<i32> = None;

match x {
    Some(_) => unreachable!(),
    None => println!("I know x is None!"),
}
```

## 実装されていない！　

`unimplemented!`されていないマクロは、機能の型チェックをしようとしているときに使用することができます。また、機能本体の書き出しを心配する必要もありません。
この状況の1つの例は、一度に1つずつ取り組む必要のある、複数の必須操作法を持つ特性を実装することです。
作成する準備が整うまで、他のものを`unimplemented!`れていないものとして定義します。
