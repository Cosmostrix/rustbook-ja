## `Box<T>`を使用して原のデータをポイントする

最も単純なスマート<ruby>指し手<rt>ポインタ</rt></ruby>は*ボックスで*、その型は`Box<T>`と書かれています。
ボックスを使用すると、<ruby>山<rt>スタック</rt></ruby>ではなく原にデータを格納できます。
<ruby>山<rt>スタック</rt></ruby>に残っているのは、原データへの<ruby>指し手<rt>ポインタ</rt></ruby>です。
<ruby>山<rt>スタック</rt></ruby>と原の違いを確認するには、第4章を参照してください。

ボックスには、<ruby>山<rt>スタック</rt></ruby>上ではなく原上にデータを格納する以外に、パフォーマンスのオーバーヘッドはありません。
しかし、それらは多くの余分な能力も持っていません。
次のような状況で最も頻繁に使用します。

* <ruby>製譜<rt>コンパイル</rt></ruby>時にサイズを知ることができない型を持っていて、正確なサイズを必要とする文脈でその型の値を使用したい場合
* 大量のデータを所有していて、所有権を譲渡したいが、そうしたときにデータがコピーされないようにする場合
* 値を所有したいと思うときには、それは特定の型ではなく特定の<ruby>特性<rt>トレイト</rt></ruby>を実装する型です

「再帰型をボックスで有効にする」章の最初の状況を示します。
2番目のケースでは、データが<ruby>山<rt>スタック</rt></ruby>にコピーされるため、大量のデータの所有権を移譲するのに時間がかかることがあります。
このような状況でパフォーマンスを向上させるために、大量のデータを原上のボックスに格納することができます。
次に、参照するデータは原上の1か所にとどまりますが、少量の<ruby>指し手<rt>ポインタ</rt></ruby>データだけが<ruby>山<rt>スタック</rt></ruby>にコピーされます。
3番目のケースは*<ruby>特性<rt>トレイト</rt></ruby>対象*として知られており、第17章では、その話題だけを<ruby>対象<rt>オブジェクト</rt></ruby>とした「さまざまな型の値を可能にする<ruby>特性<rt>トレイト</rt></ruby>対象の使用」の章全体を示しています。
ここで学んだことは、第17章で再び適用されます！　

### `Box<T>`を使用して原にデータを格納する

`Box<T>`この使用例について説明する前に、構文と、`Box<T>`格納された値とやり取りする方法について説明します。

リスト15-1は、ボックスを使用して原に`i32`値を格納する方法を示しています。

<span class="filename">ファイル名。src/main.rs</span>

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

<span class="caption">リスト15-1。ボックスを使って原に<code>i32</code>値を格納する</span>

変数`b`は、原に割り当てられた値`5`をポイントする`Box`の値を持つように定義します。
この<ruby>算譜<rt>プログラム</rt></ruby>は`b = 5`ます。
この場合、このデータが<ruby>山<rt>スタック</rt></ruby>上にあった場合と同様に、ボックス内のデータにアクセスすることができます。
所有している値と同じように、ボックスが範囲外になると、`b`が`main`の最後になると、割り当てが解除されます。
割り振り解除は、（<ruby>山<rt>スタック</rt></ruby>に格納されている）ボックスとそれが指している（原に格納されている）データに対して発生します。

原上に単一の値を置くことはあまり有用ではないので、このように頻繁にボックスを使用することはありません。
自動的に格納されている<ruby>山<rt>スタック</rt></ruby>上の単一の`i32`ような値を持つことは、大部分の状況でより適切です。
<ruby>通い箱<rt>クレート</rt></ruby>がなければ、許可されない型をボックスで定義することができます。

### ボックスによる再帰型の有効化

<ruby>製譜<rt>コンパイル</rt></ruby>時に、Rustは型がどれくらいのスペースを占めるかを知る必要があります。
<ruby>製譜<rt>コンパイル</rt></ruby>時にサイズを知ることのできない1つの型は*再帰*型です。値はその型の一部として同じ型の別の値を持つことができます。
この値のネストは理論的に無限に続く可能性があるので、Rustは再帰型の値が必要とする空間の量を知らない。
ただし、ボックスのサイズは既知であるため、再帰型定義にボックスを挿入すると、再帰型を持つことができます。

再帰型の例として、関数型<ruby>演譜<rt>プログラミング</rt></ruby>言語で一般的なデータ型である*consリストを*調べてみましょう。
定義するconsリストの型は、再帰を除いて単純です。
したがって、この例の概念は、再帰型を含むより複雑な状況になるたびに役立ちます。

#### 短所リストの詳細

*consリスト*は、Lisp<ruby>演譜<rt>プログラミング</rt></ruby>言語とその方言に由来するデータ構造です。
Lispでは、`cons`機能（「構築機能」の略）は、通常は単一の値ともう1つのペアである2つの引数から新しいペアを構築します。
ペアを含むこれらのペアはリストを形成します。

cons機能の概念はより一般的な機能<ruby>演譜<rt>プログラミング</rt></ruby>の専門用語になりました。「to cons *x* to *y* 」は、要素*x*をこの新しいコンテナの先頭に置き、コンテナ*yを*続けて新しいコンテナ<ruby>実例<rt>インスタンス</rt></ruby>を作成することを非公式に意味します。

コンスリストの各項目には、現在の項目の値と次の項目の2つの要素が含まれています。
リストの最後の項目には、次の項目なしで`Nil`という値のみが含まれます。
consリストは、`cons`機能を再帰的に呼び出すことによって生成されます。
再帰の基底を表す正規名は`Nil`です。
これは、第6章の "null"または "nil"の概念と同じではないことに注意してください。これは無効または欠損値です。

関数型<ruby>演譜<rt>プログラミング</rt></ruby>言語ではconsリストを頻繁に使用しますが、consリストはRustの一般的なデータ構造ではありません。
ほとんどの場合、Rustに項目のリストがある場合は、`Vec<T>`を使用する方が適しています。
他のより複雑な再帰的データ型*は*様々な状況で有用ですが、consリストから始めて、ボックスがどのように再帰的データ型をあまり気をそらさずに定義できるかを調べることができます。

<ruby>譜面<rt>コード</rt></ruby>リスト15-2はconsリストのenum定義を含んでいます。
この<ruby>譜面<rt>コード</rt></ruby>は、`List`型が既知のサイズを持っていないので、まだ<ruby>製譜<rt>コンパイル</rt></ruby>されないことに注意してください。

<span class="filename">ファイル名。src/main.rs</span>

```rust,ignore
enum List {
    Cons(i32, List),
    Nil,
}
```

<span class="caption">リスト15-2。 <code>i32</code>値のコンス・リスト・データ構造を表すためのenumを定義する最初の試み</span>

> > 注。この例では、`i32`値のみを保持するconsリストを実装しています。
> > 第10章で説明したように、総称化を使って実装することで、任意の型の値を格納できるコンスリスト型を定義することができました。

`List`型を使用してリスト`1, 2, 3`を格納すると、リスト15-3の<ruby>譜面<rt>コード</rt></ruby>のようになります。

<span class="filename">ファイル名。src/main.rs</span>

```rust,ignore
use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

<span class="caption">リスト15-3。 <code>List</code> enumを使ってリスト<code>1, 2, 3</code>を格納する</span>

最初の`Cons`値は`1`と別の`List`値を保持します。
この`List`値は、`2`と別の`List`値を保持する別の`Cons`値です。
この`List`値は1つの以上である`Cons`保持している値`3`し、`List`最後にある値、`Nil`、リストの終わりを非再帰的<ruby>場合値<rt>バリアント</rt></ruby>。

リスト15-3の<ruby>譜面<rt>コード</rt></ruby>を<ruby>製譜<rt>コンパイル</rt></ruby>しようとすると、<ruby>譜面<rt>コード</rt></ruby>リスト15-4に示す<ruby>誤り<rt>エラー</rt></ruby>が発生します。

```text
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

<span class="caption">リスト15-4。再帰的なenumを定義しようとしたときに発生する誤り</span>

この<ruby>誤り<rt>エラー</rt></ruby>は、この型が「無限のサイズを持つ」ことを示しています。その理由は、再帰的な<ruby>場合値<rt>バリアント</rt></ruby>で`List`を定義したことです。
その結果、Rustは`List`値を格納するために必要なスペースを把握することができません。
なぜこの<ruby>誤り<rt>エラー</rt></ruby>が発生するのかを解説しましょう。
まず、Rustが非再帰型の値を格納するために必要なスペースを決定する方法を見てみましょう。

#### 非再帰型のサイズの計算

リスト6-2で定義した`Message` enumを思い出してみましょう。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

`Message`値に割り当てるスペースを決定するために、Rustはそれぞれの<ruby>場合値<rt>バリアント</rt></ruby>を調べて、どの<ruby>場合値<rt>バリアント</rt></ruby>が最も多くのスペースを必要としているかを確認します。
Rustは、`Message::Quit`はスペースが必要ないと判断し、`Message::Move`は2つの`i32`値を格納するのに十分なスペースを必要とします。
1つの<ruby>場合値<rt>バリアント</rt></ruby>しか使用されないため、`Message`値に必要なスペースの最大値は、その<ruby>場合値<rt>バリアント</rt></ruby>の最大サイズを格納するために必要なスペースです。

Rustがリスト15-2の`List` enumのような再帰型にどれだけのスペースが必要かを判断しようとするときに何が起きるかと対照的に考えてください。
<ruby>製譜器<rt>コンパイラー</rt></ruby>は`Cons`型を見ることから始まります`i32`型は、型`i32`の値と`List`型の値を保持します。
したがって、`Cons`は、`i32`のサイズに`List`サイズを加えたものに等しい量のスペースが必要です。
`List`型が必要とする記憶量を調べるために、<ruby>製譜器<rt>コンパイラー</rt></ruby>は`Cons`型から始まる<ruby>場合値<rt>バリアント</rt></ruby>を調べます。
`Cons`変形は、図15-1に示すように、型`i32`の値と型`List`値を保持し、この過程は無限に続きます。

<img src="img/trpl15-01.svg" alt="無限コンスリスト" class="center" />
<span class="caption">図15-1。無限<code>Cons</code>場合値からなる無限<code>List</code></span>

#### `Box<T>`を使用して既知サイズの再帰型を取得する

Rustは、再帰的に定義された型にどれだけの領域を割り当てるか分からないため、<ruby>製譜器<rt>コンパイラー</rt></ruby>はリスト15-4の<ruby>誤り<rt>エラー</rt></ruby>を返します。
しかし、<ruby>誤り<rt>エラー</rt></ruby>には、この有益な提案が含まれています。

```text
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

この提案では、「間接指定」とは、値を直接格納する代わりに、値への<ruby>指し手<rt>ポインタ</rt></ruby>を間接的に格納するようにデータ構造を変更することを意味します。

`Box<T>`は<ruby>指し手<rt>ポインタ</rt></ruby>なので、Rustは`Box<T>`必要なスペースを常に知っています。<ruby>指し手<rt>ポインタ</rt></ruby>ーのサイズは<ruby>指し手<rt>ポインタ</rt></ruby>ーのデータ量に基づいて変化しません。
つまり、別の`List`値の代わりに`Cons`<ruby>場合値<rt>バリアント</rt></ruby>の中に`Box<T>`置くことができます。
`Box<T>`は、`Cons`<ruby>場合値<rt>バリアント</rt></ruby>内ではなく、原上にある次の`List`値を指します。
概念的には、他のリストを「保持」したリストで作成されたリストはまだありますが、この実装は、相互に内包されているのではなく、隣り合わせに配置されているようになりました。

リスト15-2の`List` enumの定義と、リスト15-3の`List`の使い方をリスト15-5の<ruby>譜面<rt>コード</rt></ruby>に変更することができます。これは<ruby>製譜<rt>コンパイル</rt></ruby>されます。

<span class="filename">ファイル名。src/main.rs</span>

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

<span class="caption">定義。15-5リスト<code>List</code>使用しています<code>Box&lt;T&gt;</code>既知のサイズを持つためには</span>

`Cons`<ruby>場合値<rt>バリアント</rt></ruby>は、サイズが必要になります`i32`ボックスの<ruby>指し手<rt>ポインタ</rt></ruby>データを保存するために、プラスのスペースを。
`Nil`<ruby>場合値<rt>バリアント</rt></ruby>には値が格納されないため、`Cons`<ruby>場合値<rt>バリアント</rt></ruby>よりもスペースが少なくて済みます。
`List`値は、`i32`のサイズにボックスの<ruby>指し手<rt>ポインタ</rt></ruby>データのサイズを加えた値になります。
ボックスを使うことで、無限の再帰的チェーンが壊れているので、<ruby>製譜器<rt>コンパイラー</rt></ruby>は`List`値を格納するのに必要なサイズを知ることができます。
図15-2に`Cons`変形例を示します。

<img src="img/trpl15-02.svg" alt="有限コンスリスト" class="center" />
<span class="caption">図15-2。 <code>Cons</code>が<code>Box</code>保持しているため無限大ではない<code>List</code></span>

ボックスはインダイレクションと原割り当てのみを提供します。
他のスマート<ruby>指し手<rt>ポインタ</rt></ruby>の種類と同じような特殊な機能はありません。
これらの特殊機能にはパフォーマンス上のオーバーヘッドはありません。したがって、間接指定が必要な唯一の機能であるコンスリストのような場合に便利です。
第17章のボックスの使用例ももっと見ていきます。

`Box<T>`型はスマート<ruby>指し手<rt>ポインタ</rt></ruby>です`Deref`型を実装しているため、`Box<T>`値を参照のように扱うことができます。
`Box<T>`値が<ruby>有効範囲<rt>スコープ</rt></ruby>外になると、`Drop`<ruby>特性<rt>トレイト</rt></ruby>の実装のために、ボックスが指している原データも同様に後始末されます。
これらの2つの<ruby>特性<rt>トレイト</rt></ruby>をより詳細に調べてみましょう。
これらの2つの<ruby>特性<rt>トレイト</rt></ruby>は、この章の後半で説明する他のスマート<ruby>指し手<rt>ポインタ</rt></ruby>型によって提供される機能にとってさらに重要になります。
