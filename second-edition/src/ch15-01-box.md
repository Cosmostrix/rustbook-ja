## `Box<T>`を使用して原のデータをポイントする

最も単純なスマート指し手は*ボックスで*、その型は`Box<T>`と書かれています。
ボックスを使用すると、山ではなく原にデータを格納できます。
山に残っているのは、原データへの指し手です。
山と原の違いを確認するには、第4章を参照してください。

ボックスには、山上ではなく原上にデータを格納する以外に、パフォーマンスのオーバーヘッドはありません。
しかし、それらは多くの余分な能力も持っていません。
次のような状況で最も頻繁に使用します。

* 製譜時にサイズを知ることができない型を持っていて、正確なサイズを必要とする文脈でその型の値を使用したい場合
* 大量のデータを所有していて、所有権を譲渡したいが、そうしたときにデータがコピーされないようにする場合
* 値を所有したいと思うときには、それは特定の型ではなく特定の特性を実装する型です

「再帰型をボックスで有効にする」章の最初の状況を示します。
2番目のケースでは、データが山にコピーされるため、大量のデータの所有権を移譲するのに時間がかかることがあります。
このような状況でパフォーマンスを向上させるために、大量のデータを原上のボックスに格納することができます。
次に、参照するデータは原上の1か所にとどまりますが、少量の指し手データだけが山にコピーされます。
3番目のケースは*特性対象*として知られており、第17章では、その話題だけを対象とした「さまざまな型の値を可能にする特性対象の使用」の章全体を示しています。
ここで学んだことは、第17章で再び適用されます！　

### `Box<T>`を使用して原にデータを格納する

`Box<T>`この使用例について説明する前に、構文と、`Box<T>`格納された値とやり取りする方法について説明します。

リスト15-1は、ボックスを使用して原に`i32`値を格納する方法を示しています。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

<span class="caption">リスト15-1。ボックスを使って原に<code>i32</code>値を格納する</span>

変数`b`は、原に割り当てられた値`5`をポイントする`Box`の値を持つように定義します。
この算譜は`b = 5`ます。
この場合、このデータが山上にあった場合と同様に、ボックス内のデータにアクセスすることができます。
所有している値と同じように、ボックスが範囲外になると、`b`が`main`の最後になると、割り当てが解除されます。
割り振り解除は、（山に格納されている）ボックスとそれが指している（原に格納されている）データに対して発生します。

原上に単一の値を置くことはあまり有用ではないので、このように頻繁にボックスを使用することはありません。
自動的に格納されている山上の単一の`i32`ような値を持つことは、大部分の状況でより適切です。
通い箱がなければ、許可されない型をボックスで定義することができます。

### ボックスによる再帰型の有効化

製譜時に、Rustは型がどれくらいのスペースを占めるかを知る必要があります。
製譜時にサイズを知ることのできない1つの型は*再帰*型です。値はその型の一部として同じ型の別の値を持つことができます。
この値のネストは理論的に無限に続く可能性があるので、Rustは再帰型の値が必要とする空間の量を知らない。
ただし、ボックスのサイズは既知であるため、再帰型定義にボックスを挿入すると、再帰型を持つことができます。

再帰型の例として、関数型演譜言語で一般的なデータ型である*consリストを*調べてみましょう。
定義するconsリストの型は、再帰を除いて単純です。
したがって、この例の概念は、再帰型を含むより複雑な状況になるたびに役立ちます。

#### 短所リストの詳細

*consリスト*は、Lisp演譜言語とその方言に由来するデータ構造です。
Lispでは、`cons`機能（「構築機能」の略）は、通常は単一の値ともう1つのペアである2つの引数から新しいペアを構築します。
ペアを含むこれらのペアはリストを形成します。

cons機能の概念はより一般的な機能演譜の専門用語になりました。「to cons *x* to *y* 」は、要素*x*をこの新しいコンテナの先頭に置き、コンテナ*yを*続けて新しいコンテナ実例を作成することを非公式に意味します。

コンスリストの各項目には、現在の項目の値と次の項目の2つの要素が含まれています。
リストの最後の項目には、次の項目なしで`Nil`という値のみが含まれます。
consリストは、`cons`機能を再帰的に呼び出すことによって生成されます。
再帰の基底を表す正規名は`Nil`です。
これは、第6章の "null"または "nil"の概念と同じではないことに注意してください。これは無効または欠損値です。

関数型演譜言語ではconsリストを頻繁に使用しますが、consリストはRustの一般的なデータ構造ではありません。
ほとんどの場合、Rustに項目のリストがある場合は、`Vec<T>`を使用する方が適しています。
他のより複雑な再帰的データ型*は*様々な状況で有用ですが、consリストから始めて、ボックスがどのように再帰的データ型をあまり気をそらさずに定義できるかを調べることができます。

譜面リスト15-2はconsリストのenum定義を含んでいます。
この譜面は、`List`型が既知のサイズを持っていないので、まだ製譜されないことに注意してください。

<span class="filename">ファイル名。src / main.rs</span>

```rust,ignore
enum List {
    Cons(i32, List),
    Nil,
}
```

<span class="caption">リスト15-2。 <code>i32</code>値のコンス・リスト・データ構造を表すためのenumを定義する最初の試み</span>

> > 注。この例では、`i32`値のみを保持するconsリストを実装しています。
> > 第10章で説明したように、総称化を使って実装することで、任意の型の値を格納できるコンスリスト型を定義することができました。

`List`型を使用してリスト`1, 2, 3`を格納すると、リスト15-3の譜面のようになります。

<span class="filename">ファイル名。src / main.rs</span>

```rust,ignore
use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

<span class="caption">リスト15-3。 <code>List</code> enumを使ってリスト<code>1, 2, 3</code>を格納する</span>

最初の`Cons`値は`1`と別の`List`値を保持します。
この`List`値は、`2`と別の`List`値を保持する別の`Cons`値です。
この`List`値は1つの以上である`Cons`保持している値`3`し、`List`最後にある値、`Nil`、リストの終わりを非再帰的変種。

リスト15-3の譜面を製譜しようとすると、譜面リスト15-4に示す誤りが発生します。

```text
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

<span class="caption">リスト15-4。再帰的なenumを定義しようとしたときに発生する誤り</span>

この誤りは、この型が「無限のサイズを持つ」ことを示しています。その理由は、再帰的な場合値で`List`を定義したことです。
その結果、Rustは`List`値を格納するために必要なスペースを把握することができません。
なぜこの誤りが発生するのかを解説しましょう。
まず、Rustが非再帰型の値を格納するために必要なスペースを決定する方法を見てみましょう。

#### 非再帰型のサイズの計算

リスト6-2で定義した`Message` enumを思い出してみましょう。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

`Message`値に割り当てるスペースを決定するために、Rustはそれぞれの場合値を調べて、どの場合値が最も多くのスペースを必要としているかを確認します。
Rustは、`Message::Quit`はスペースが必要ないと判断し、`Message::Move`は2つの`i32`値を格納するのに十分なスペースを必要とします。
1つの場合値しか使用されないため、`Message`値に必要なスペースの最大値は、その場合値の最大サイズを格納するために必要なスペースです。

Rustがリスト15-2の`List` enumのような再帰型にどれだけのスペースが必要かを判断しようとするときに何が起きるかと対照的に考えてください。
製譜器は`Cons`型を見ることから始まります`i32`型は、型`i32`の値と`List`型の値を保持します。
したがって、`Cons`は、`i32`のサイズに`List`サイズを加えたものに等しい量のスペースが必要です。
`List`型が必要とする記憶量を調べるために、製譜器は`Cons`型から始まる場合値を調べます。
`Cons`変形は、図15-1に示すように、型`i32`の値と型`List`値を保持し、この過程は無限に続きます。

<img src="img/trpl15-01.svg" alt="無限コンスリスト" class="center" />
<span class="caption">図15-1。無限<code>Cons</code>場合値からなる無限<code>List</code></span>

#### `Box<T>`を使用して既知サイズの再帰型を取得する

Rustは、再帰的に定義された型にどれだけの領域を割り当てるか分からないため、製譜器はリスト15-4の誤りを返します。
しかし、誤りには、この有益な提案が含まれています。

```text
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

この提案では、「間接指定」とは、値を直接格納する代わりに、値への指し手を間接的に格納するようにデータ構造を変更することを意味します。

`Box<T>`は指し手なので、Rustは`Box<T>`必要なスペースを常に知っています。指し手ーのサイズは指し手ーのデータ量に基づいて変化しません。
つまり、別の`List`値の代わりに`Cons`場合値の中に`Box<T>`置くことができます。
`Box<T>`は、`Cons`場合値内ではなく、原上にある次の`List`値を指します。
概念的には、他のリストを「保持」したリストで作成されたリストはまだありますが、この実装は、相互に内包されているのではなく、隣り合わせに配置されているようになりました。

リスト15-2の`List` enumの定義と、リスト15-3の`List`の使い方をリスト15-5の譜面に変更することができます。これは製譜されます。

<span class="filename">ファイル名。src / main.rs</span>

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

<span class="caption">定義。15-5リスト<code>List</code>使用しています<code>Box&lt;T&gt;</code>既知のサイズを持つためには</span>

`Cons`場合値は、サイズが必要になります`i32`ボックスの指し手データを保存するために、プラスのスペースを。
`Nil`場合値には値が格納されないため、`Cons`場合値よりもスペースが少なくて済みます。
`List`値は、`i32`のサイズにボックスの指し手データのサイズを加えた値になります。
ボックスを使うことで、無限の再帰的チェーンが壊れているので、製譜器は`List`値を格納するのに必要なサイズを知ることができます。
図15-2に`Cons`変形例を示します。

<img src="img/trpl15-02.svg" alt="有限コンスリスト" class="center" />
<span class="caption">図15-2。 <code>Cons</code>が<code>Box</code>保持しているため無限大ではない<code>List</code></span>

ボックスはインダイレクションと原割り当てのみを提供します。
他のスマート指し手の種類と同じような特殊な機能はありません。
これらの特殊機能にはパフォーマンス上のオーバーヘッドはありません。したがって、間接指定が必要な唯一の機能であるコンスリストのような場合に便利です。
第17章のボックスの使用例ももっと見ていきます。

`Box<T>`型はスマート指し手です`Deref`型を実装しているため、`Box<T>`値を参照のように扱うことができます。
`Box<T>`値が有効範囲外になると、`Drop`特性の実装のために、ボックスが指している原データも同様に後始末されます。
これらの2つの特性をより詳細に調べてみましょう。
これらの2つの特性は、この章の後半で説明する他のスマート指し手型によって提供される機能にとってさらに重要になります。
