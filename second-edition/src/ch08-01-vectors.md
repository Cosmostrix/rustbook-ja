## ベクトルによる値のリストの格納

最初に`Vec<T>`集まりの種類は`Vec<T>`で、*ベクトル*とも呼ばれます。
ベクトルを使用すると、複数の値を1つのデータ構造体に格納して、すべての値を互いに隣り合う記憶に格納することができます。
ベクトルには同じ型の値しか格納できません。
ファイル内の文言行やショッピングカート内の項目の価格など、項目のリストがある場合に便利です。

### 新しいベクターの作成

新しい空ベクトルを作成するには、リスト8-1に示すように`Vec::new`機能を呼び出すことができます。

```rust
let v: Vec<i32> = Vec::new();
```

<span class="caption">リスト8-1。型<code>i32</code>値を保持する新しい空のベクトルの作成</span>

型注釈をここに追加したことに注意してください。
このベクトルに値を挿入しないため、Rustは格納する要素の種類を知らない。
これは重要な地点です。
ベクトルは総称化を使用して実装されます。
第10章で独自の型で総称化を使用する方法について説明します。今のところ、標準譜集によって提供される`Vec<T>`型は任意の型を保持でき、特定の型が特定の型を保持する場合、型は角かっこで囲んで指定します。
リスト8-1では、Rust言った`Vec<T>`で`v`の要素を保持する`i32`型を。

もっと現実的な譜面では、Rustは一度値を挿入すると保存したい値の型を推論することができるので、この型の注釈を行う必要はほとんどありません。
初期値を持つ`Vec<T>`を作成する方が一般的`vec!`.Rustは便宜上`vec!`マクロを提供します。
マクロは、与えた値を保持する新しいベクトルを作成します。
8-2のリストに新しい作成`Vec<i32>`の値を保持`1`、 `2`、および`3`。

```rust
let v = vec![1, 2, 3];
```

<span class="caption">リスト8-2。値を含む新しいベクトルを作成する</span>

最初の`i32`値を与えたので、Rustは`v`の型が`Vec<i32>`であると推測でき、型注釈は必要ありません。
次に、ベクトルを変更する方法を見ていきます。

### ベクターの更新

ベクトルを作成して要素を追加するには、リスト8-3に示すように`push`操作法を使用します。

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

<span class="caption">リスト8-3。 <code>push</code>操作法を使ってベクトルに値を追加する</span>

変数と同様に、値を変更できるようにするには、第3章で説明した`mut`予約語を使用してmutableを変更可能にする必要があります。内部に配置する数字はすべて`i32`型で、Rustは`Vec<i32>`注釈は必要ありません。

### ベクターを削除するとその要素が削除される

他の`struct`と同様に、リスト8-4に示すように、ベクトルが範囲外になると解放されます。

```rust
{
    let v = vec![1, 2, 3, 4];

#    // do stuff with v
    //  vと一緒にやる

#//} // <- v goes out of scope and is freed here
} //  < -vは範囲外になり、ここで解放されます
```

<span class="caption">リスト8-4。ベクトルとその要素がどこに脱落したかを示す</span>

ベクタが削除されると、その内容もすべて削除されます。つまり、保持している整数は後始末されます。
これは簡単な点のように思えるかもしれませんが、ベクトルの要素への参照を導入するときに少し複雑になることがあります。
次はそれに取り組んでみましょう！　

### ベクトルの要素を読む

ベクトルを作成、更新、破棄する方法を知ったので、内容を読む方法を知っておくことは、次の良いステップです。
ベクトルに格納された値を参照するには、2つの方法があります。
例では、わかりやすくするために、これらの機能から返される値の型に注釈を付けました。

譜面リスト8-5に、添字構文または`get`操作法を使用してベクトルの値にアクセスする両方の操作法を示します。

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
let third: Option<&i32> = v.get(2);
```

<span class="caption">譜面リスト8-5。索引付け構文または<code>get</code>操作法を使用してベクトル内の項目にアクセスする</span>

ここで2つの詳細を注意してください。
最初に、添字値`2`を使用して3番目の要素を取得します。ベクトルはゼロから始まる番号で添字付けされます。
次に、3番目の要素を取得する2つの方法は、`&`と`[]`を使用して参照を与えたり、添字として引数を渡した`get`操作法を使用して、`Option<&T>`を与えます。

Rustには要素を参照する2つの方法がありますので、ベクトルが要素を持たない添字値を使用しようとしたときに算譜がどのように動作するかを選択できます。
例として、リスト8-6に示すように、算譜が5つの要素を保持し、次に添字100の要素にアクセスしようとするベクトルを持つ場合、算譜が何をするかを見てみましょう。

```rust,should_panic
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

<span class="caption">リスト8-6。5つの要素を含むベクトルの添字100の要素にアクセスしようとする</span>

この譜面を実行すると、存在しない要素を参照するため、最初の`[]`操作法は算譜にパニックを引き起こします。
この操作法は、ベクトルの最後を過ぎた要素にアクセスしようとすると算譜が異常終了するようにしたいときに最適です。

`get`操作法がベクトルの外側にある添字を渡すと、パニックを起こさずに`None`を返します。
通常の状況下で時々起こるベクタの範囲を超えた要素にアクセスする場合は、この操作法を使用します。
あなたの譜面には、第6章で説明したように、`Some(&element)`または`None`いずれかを扱うロジックがあります。たとえば、数字を入力した人が索引を作成している可能性があります。
誤って大きすぎる数値を入力し、算譜が`None`値を取得した場合、現在のベクトルにある項目の数をユーザーに通知し、有効な値を入力する別の機会を与えることができます。
これは、型ミスのために算譜を異常終了させるよりもユーザーフレンドリーになります！　

算譜に有効な参照がある場合、借用検査器は所有権と借用の規則（第4章で説明）を強制型変換して、この参照とベクトルの内容への他の参照が有効であることを保証します。
変更可能な不変の参照を同じ有効範囲内に持つことはできないというルールを思い出してください。
このルールはリスト8-7に当てはまります。ここでは、ベクトルの最初の要素への不変参照を保持し、最後に要素を追加しようとしますが、これはうまくいきません。

```rust,ignore
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);
```

<span class="caption">リスト8-7。項目への参照を保持しながらベクターに要素を追加しようとする</span>

この譜面を製譜すると、この誤りが発生します。

```text
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 -->
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^ mutable borrow occurs here
7 |
8 | }
  | - immutable borrow ends here
```

譜面リスト8-7の譜面は、うまくいくように見えるかもしれません。なぜ、最初の要素への参照は、ベクトルの最後に何が変わるかを気にする必要がありますか？　
この誤りはベクトルの仕組みに起因しています。ベクトルの最後に新しい要素を追加すると、新しい記憶を割り当て、古い要素を新しい空間にコピーする必要があります。ベクトルが現在どこにあるか。
その場合、最初の要素への参照は解放された記憶を指しています。
借用ルールは、算譜がその状況で終わるのを防ぎます。

> > 注。 `Vec<T>`型の実装の詳細については、https://doc.rust-lang.org/stable/nomicon/vec.htmlの「The Rustonomicon」を参照してください。

### ベクトルの値を反復する

ベクトルの各要素に順番にアクセスしたい場合は、添字を使用して一度に1つずつアクセスするのではなく、すべての要素を繰り返し処理できます。
リスト8-8は`for`ループを使って、`i32`値のベクトルの各要素への不変参照を取得して出力する方法を示しています。

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
```

<span class="caption">リスト8-8。 <code>for</code>ループを使って要素を反復処理することにより、ベクトルの各要素を出力する</span>

また、すべての要素を変更するために、変更可能なベクトル内の各要素への可変参照を反復処理することもできます。
リスト8-9の`for`ループは各要素に`50`を追加します。

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

<span class="caption">リスト8-9。ベクトル内の要素への可変参照の反復</span>

変更可能な参照が参照する値を変更するには、逆参照演算子（`*`）を使用して`+=`演算子を使用する前に`i`の値を取得する必要があります。

### 列挙型を使用して複数の型を格納する

この章の冒頭では、ベクトルには同じ型の値しか格納できないと述べました。
これは不便なことがあります。
異なる型の項目のリストを格納する必要があることは間違いありません。
幸いにも、列挙型の変種は同じ列挙型で定義されているので、異なる型の要素をベクトルに格納する必要があるときは、列挙型を定義して使用することができます。

たとえば、行の一部の列に整数、浮動小数点数、および一部の文字列が含まれているスプレッドシートの行から値を取得するとします。
場合値が異なる値の型を保持する列挙型を定義できます。次に、すべての列挙型が同じ型とみなされます。列挙型の型とみなされます。
その列挙型を保持するベクトルを作成し、最終的には異なる型を保持することができます。
リスト8-10でこれを実証しました。

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

<span class="caption">リスト8-10。1つのベクトルに異なる型の値を格納するための<code>enum</code>型の定義</span>

Rustは、製譜時にどの型がベクタに含まれるかを知る必要があるため、各要素を格納するために原上の記憶域の量が正確に分かります。
2番目の利点は、このベクトルでどのような型が許可されているかを明示できることです。
Rustがベクタの型を保持できる場合、ベクタの要素に対して実行される操作で1つ以上の型が誤りを引き起こす可能性があります。
列挙型と`match`式を使用すると、第6章で説明するように、Rustは製譜時に可能なすべてのケースが処理されることを保証します。

算譜を書くときに、算譜が実行時にベクトルに格納される型の完全な型がわからない場合、enum技法は機能しません。
代わりに、第17章で説明する特性対象を使用することができます。

ベクトルを使用する最も一般的な方法のいくつかについて説明したので、標準譜集で`Vec<T>`定義されている多くの便利な操作法のAPI開発資料を確認してください。
たとえば、`push`に加えて、`pop`操作法は最後の要素を削除して返します。
次の集まり型に移りましょう。 `String`！　
