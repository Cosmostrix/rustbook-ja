## `panic!`か、`panic!`

だから`panic!`を呼び出すべき時と、`Result`を返すべき時を決める方法は？　
譜面がパニックすると、回復する方法はありません。
復旧の可能性があるかどうかに関わらず、誤り状況については`panic!`呼び出すことができますが、状況を回復できない譜面を呼び出す譜面に代わって決定を下しています。
`Result`値を返すことを選択した場合、呼び出し譜面選択肢の決定を行うのではなく、その譜面選択肢を指定します。
呼び出し元の譜面は、その状況に応じて適切だ方法で回復しようとすることを選択することができ、またはそれはそれを決めることができました`Err`それが呼び出すことができるように、この場合の値は、回復不能な`panic!`し、回復不能一つに、回復可能な誤りをオンにします。
したがって、失敗する可能性のある機能を定義するときは、`Result`返すのが適切な黙用の選択です。

まれな状況では、`Result`を返す代わりにパニックする譜面を記述する方が適切です。
サンプル、プロト型譜面、テストでなぜパニックになるのが適切かを調べてみましょう。
そして、製譜器が失敗は不可能だが、人間として考えることができない状況について話し合う。
この章では、譜集譜面をパニックするかどうかを決定する方法に関する一般的なガイド行を示します。

### 例、プロト型譜面、およびテスト

いくつかの概念を説明するための例を書くときには、この例でも堅牢な誤り処理譜面を使用することで、この例をあまり明確にすることはできません。
例では、`unwrap`ようなパニックに陥る可能性のある操作法への呼び出しは、譜体で誤りを処理する方法の場所取りーとして意味され、譜面の残りの部分に基づいて異なる場合があることが理解されます。

同様に、`unwrap`と`expect`操作法はプロト型作成時に非常に便利です。誤りを処理する方法を決める準備が整う前に、
算譜をより堅牢にする準備ができたら、譜面に明瞭なマーカーが残っています。

テストで操作法呼び出しが失敗した場合、たとえその操作法がテスト中の機能ではなくても、テスト全体が失敗することが望まれます。
`panic!`とは、テストが失敗としてマークされる方法であるため、`unwrap`や`expect`呼び出す`expect`はまさに何が起こるべきかです。

### 製譜器より多くの情報を持っている場合

また、`Result`に`Ok`値があることを保証する他の論理があるときに`unwrap`を呼び出すのが適切ですが、論理は製譜器が理解できるものではありません。
まだ処理しなければならない`Result`値を持っています。あなたの特定の状況では論理的に不可能であるにもかかわらず、呼び出している操作はどれも、一般的には失敗する可能性があります。
`Err`場合値を使用しない譜面を手動で検査することで確実にできれば、`unwrap`を呼び出すことは完全に受け入れられます。
ここに例があります。

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1".parse().unwrap();
```

ハード譜面された文字列を解析することによって`IpAddr`実例を作成して`IpAddr`ます。
`127.0.0.1`が有効なIP番地であることがわかります。ここで`unwrap`を使用しても問題あり`unwrap`。
ただし、ハード譜面された有効な文字列を使用しても、`parse`操作法の戻り値の型は変更されません`Result`値が返されますが、製譜器は`Err`場合値が可能であるかのように`Result`を処理します。この文字列が常に有効なIP番地であることが分かります。
IP番地の文字列は、利用者から来たのではなく算譜にハード譜面されているため、故障の可能性を持って*いた*場合、間違いなく処理したいと思います`Result`代わりに、より堅牢な方法で。

### 誤り処理のガイド行

譜面が悪い状態になる可能性がある場合は、譜面パニックを起こすことをお勧めします。
この文脈では、無効な値、矛盾する値、欠損値が譜面に渡されたり、次のうちの1つ以上が発生した場合など、いくつかの前提条件、保証、契約、または不変条件が破られた*状態*が*悪い状態*です。

* 悪い状態は時々起こると*思われる*ものではありません。
* この時点以降の譜面は、この悪い状態にないことに依存する必要があります。
* この情報を使用する型で符号化する良い方法はありません。

誰かが譜面を呼び出し、意味をなさない値を渡した場合、最良の選択は`panic!`を呼び出して、開発中に修正できるように、譜面内のバグに譜集を使用している人に警告することです。
同様に、制御から外れている外部譜面を呼び出していて、修正する方法がない無効な状態を返す場合、`panic!`はしばしば適切です。

悪い状態になっても、譜面を書いても問題は起こりませんが、`panic!`通話をするのではなく、`Result`を返す方が適切`panic!`。
例としては、不正なデータが与えられた構文解析器ーや、レート制限を超えたことを示すステータスを返すHTTPリクエストなどがあります。
このような場合、`Result`を返してこれらの不良状態を上方に伝播させ、呼び出し譜面が問題の処理方法を決定できるようにすることで、失敗が予想される可能性があることを示す必要があります。
`panic!`を呼び出すことは、これらのケースを処理する最良の方法ではありません。

譜面が値に対して操作を実行するとき、譜面は値が有効であることを確認し、値が有効でない場合はパニックにする必要があります。
これは主に安全上の理由によるものです。無効なデータを操作しようとすると、譜面が脆弱性にさらされる可能性があります。
これは、標準譜集が縛り外の記憶アクセスを試みた場合に`panic!`を呼び出す主な理由です。現在のデータ構造に属していない記憶にアクセスしようとするのはセキュリティ上の一般的な問題です。
機能はしばしば*契約を結ぶ*。入力が特定の要件を満たしていれば、その動作は保証されます。
契約違反は常に呼び出し側のバグを示し、呼び出し譜面で明示的に処理しなければならない種類の誤りではないため、契約違反時にパニックが発生します。
実際、譜面を呼び出すための合理的な方法はありません。
呼び出す*演譜師*は譜面を修正する必要があります。
機能の契約、特に違反がパニックの原因となる場合は、機能のAPI開発資料で説明する必要があります。

しかし、すべての機能で多くの誤りチェックを行うと、冗長で迷惑になります。
幸いなことに、Rustの型算系（したがって製譜器が行う型チェック）を使用して、多くのチェックを行うことができます。
機能にパラメータとして特定の型がある場合は、製譜器が有効な値を持つことを既に確認していることを確認して、譜面の論理を進めることができます。
たとえば、`Option`ではなくTypeを持つ場合、算譜は*何も*持たずに*何か*を持つ*ことを*想定しています。
譜面では、`Some`と`None` 2つのケースを処理する必要はありません。値を確実に持つケースは1つだけです。
機能に何も渡そうとしない譜面は製譜されないので、実行時にその機能をチェックする必要はありません。
別の例では、パラメータが負でないことを保証する`u32`などの符号なし整数型を使用しています。

### 検証のための独自型の作成

Rustの型算系を使用して、有効な値をさらに確実に取得し、検証用の独自の型を作成する方法を考えてみましょう。
第2章の推測ゲームを思い出してください。この譜面では、1から100までの数字を推測するように利用者に求めました。その数字の間に利用者の推測があることを確認してから、
推測が肯定的であることを確認しました。
この場合、その結果は非常に悲惨ではありませんでした。「高すぎる」または「低すぎる」という結果は依然として正しいでしょう。
しかし、利用者が正当な推測に向かうのに役立ち、利用者が範囲外の数字を推測したときと、利用者がたとえば文字を入力したときとでは異なる動作をするのは便利です。

これを行う1つの方法は、負の数を可能にする`u32`代わりに`i32`ような推測を解析し、範囲内にある数のチェックを追加することです。

```rust,ignore
loop {
#    // --snip--
    //  --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
#    // --snip--
    //  --snip--
}
```

`if`式は、値が範囲外であるかどうかをチェックし、問題について利用者に通知し、呼び出し`continue`ループの次の反復を開始し`continue`、別の推測を要求します。
`if`式の後に、`guess`が1と100の間であることを知って、`guess`と秘密の数の比較を続行できます。

しかし、これは理想的な解決策ではありません。算譜が1〜100の値でしか動作しないことが絶対に重要で、この要件を持つ多くの機能を持っていれば、このようなチェックをすべての機能に持たせることは面倒ですパフォーマンス）。

その代わりに、新しい型を作成し、検証をどこにでも繰り返すのではなく、型の実例を作成する機能に入れることができます。
そうすれば、機能が新しい型を型指示に使用し、受け取った値を確実に使用することは安全です。
リスト9-9は、`new`機能が1から100の間の値を受け取った場合にのみ`Guess`実例を作成する`Guess`型を定義する1つの方法を示しています。

```rust
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }

    pub fn value(&self) -> u32 {
        self.value
    }
}
```

<span class="caption">リスト9-9。1と100の間の値だけを続ける<code>Guess</code>型</span>

まず、`u32`を保持する`value`という名前の欄を持つ`Guess`という名前のstructを定義します。
これが番号が格納される場所です。

次に`Guess` `new`という名前の関連する機能を実装し、`Guess`値の実例を作成します。
`new`機能は、`u32`型の`value`という名前の1つのパラメータを持ち、`Guess` `value`を返すように定義されています。
`new`機能の本体にある譜面は、`value`が1から100の間であることをテストし`value`。 `value`がこのテストに合格しない場合は、`panic!`呼び出しを行い、演譜師が呼び出した譜面を記述していることを警告しますこの範囲外の`value`で`Guess`を作成すると、`Guess::new`が依存している契約に違反するため、修正する必要があるバグです。
`Guess::new`がパニックに陥る可能性のある条件は、公開されているAPI開発資料で議論されるべきです。
可能性を示す文書の規則取り上げる`panic!`場合は、第14章で作成するAPI開発資料の`value`試験に合格しないと、新しい作成`Guess`その持つ`value`に設定し、欄`value`パラメータをと返し`Guess`。

次に、`self`を借用、他のパラメータを持たず、`u32`を返す`value`という名前の操作法を実装します。
この種の操作法は、*getter*と呼ばれることもあります。その目的は、欄からデータを取得して返すことです。
`Guess`構造体の`value`欄はprivateであるため、この公開操作法は必要です。
それはすることが重要です`value`欄は内部用でそう使用して譜面`Guess`構造体を設定することが許可されていない`value`直接。役区外の譜面が使用*する必要があります* `Guess::new`実例を作成する機能を`Guess`、それによってための方法はありません確実に、 `Guess`には、`Guess::new`機能の条件でチェックされていない`value`があります。

パラメータを持つ機能、または1から100の間の数値しか返さない機能は、`u32`ではなく、`Guess` `u32`か返すという型指示を宣言し、その本体で追加のチェックを行う必要はありません。

## 概要

Rustの誤り処理機能は、より堅牢な譜面を書くのに役立つように設計されています。
`panic!`マクロは、算譜が処理できない状態にあることを知らせ、無効または間違った値で処理するのではなく過程を停止するように指示します。
`Result` enumは、Rustの型算系を使用して、譜面が回復する方法で操作が失敗する可能性があることを示します。
`Result`を使用して譜面を呼び出す譜面に、潜在的な成功または失敗を処理する必要があることを伝えることができます。
使用して`panic!`と`Result`適切な状況では、避けられない問題に直面して譜面はより信頼性の高いようになります。

標準譜集が`Option`と`Result`列挙型で総称化を使用する便利な方法を見てきたので、総称化の仕組みと譜面での使用方法について説明します。
