## 付録C。導出可能な特性

本のさまざまな場所では、structまたはenum定義に適用できる`derive`属性について説明しました。
`derive`属性は、`derive`構文で注釈を付けた型で独自の黙用実装を持つ特性を実装する譜面を生成します。

この付録では、標準譜集ーのすべての特性を`derive`使用することができます。
各章の内容は次のとおりです。

* この特性を導く演算子と操作法が可能にするもの
* `derive`によって提供さ`derive`特性の実装が
* どのような特性を実装するのが型を意味するのか
* その特性を実現することを許されているか否かの条件
* 特性を必要とする操作の例

`derive`属性によって提供される動作と異なる動作が必要な場合は、手動で実装する方法の詳細について、各特性の標準譜集の説明書を参照してください。

標準譜集で定義された特性の残りの部分は、使用して、型に実装することはできません`derive`。
これらの特性は、賢明な黙用の動作を持たないため、達成しようとしていることに合った方法で実装する必要があります。

導出することができない特性の例は、エンド利用者の書式設定を処理する`Display`です。
エンド利用者に型を表示する適切な方法を常に検討する必要があります。
エンド利用者はどのような部分を見なければなりませんか？　
それらはどの部分に関連性があると思いますか？　
どのような形式のデータが最も関連性がありますか？　
Rust製譜器にはこの洞察がないため、適切な黙用の動作を提供することはできません。

この付録で提供特性誘導のリストは包括的ではありません。譜集が実装でき`derive`使用できる特性のリストを作り、自分の特性について`derive`真にオープンエンドで。
実装`derive`、付録Dで覆われている手続きマクロを使用することを含みます

### 演譜師出力の`Debug`

`Debug`特性は、書式文字列の虫取り書式を有効にします`:?`
`{}`場所取り内にあります。

`Debug`特性を使用すると、虫取り目的で型の実例を印字できます。したがって、あなたと他の型の演譜師は、算譜の実行中の特定の地点で実例を検査できます。

たとえば、`assert_eq!`マクロを使用する場合は、`Debug`特性が必要です。
このマクロは、等価アサーションが失敗した場合に引数として指定された実例の値を出力するので、2つの実例が同じでない理由を演譜師が確認できます。

### 等価比較のための`PartialEq`と`Eq`

`PartialEq`特性では、型の実例を比較して等しいかどうかをチェックし、`==`および`!=`演算子を使用できます。

`PartialEq`すると、`eq`操作法が実装されます。
structで`PartialEq`が導出されると、2つの実例は*すべての*欄が等しい場合にのみ等しくなり、欄が等しくない場合には実例が等しくなりません。
列挙型で導出すると、各場合値はそれ自体に等しく、他の場合値と等しくはありません。

`PartialEq`特性は、たとえば、`assert_eq!`マクロの使用で必要となります`assert_eq!`は、型の2つの実例を比較できるようにする必要があります。

`Eq`特性には操作法がありません。
その目的は、注釈付き型のすべての値に対して、その値がそれ自身と等しいことを通知することです。
`Eq`特性は`PartialEq`実装する型にのみ適用できますが、`PartialEq`を実装するすべての型が`Eq`を実装できるわけではありません。
これの1つの例は浮動小数点数型です。浮動小数点数の実装では、非数（`NaN`）値の2つの実例が互いに等しくないことが示されています。

場合の例`Eq`のキーのために必要とされている`HashMap<K, V>`ので`HashMap<K, V>` 2つのキーが同じであるかどうかを伝えることができます。

### `PartialOrd`と`Ord`

`PartialOrd`特性では、ソートの目的で型の実例を比較できます。
`PartialOrd`を実装する型は、`<`、 `>`、 `<=`、および`>=`演算子で使用できます。
あなただけ適用することができます`PartialOrd`も実装する型に特性を`PartialEq`。

`PartialOrd`すると`partial_cmp`操作法が実装され、`PartialOrd`された値が順序付けを生成しない場合は`None`になる`Option<Ordering>`が返されます。
順序を生成しない値の例は、その型のほとんどの値を比較できる場合でも、非数（`NaN`）の浮動小数点値です。
`partial_cmp`を任意の浮動小数点数と`NaN`浮動小数点数で呼び出すと、`None`が返されます。

structで導出すると、`PartialOrd`は、各欄の値を構造体定義に現れる順序で比較して2つの実例を比較します。
列挙型で導出すると、列挙型定義で前に宣言された列挙型の変形は、後で列挙する変形よりも小さいとみなされます。

`PartialOrd`特性は、たとえば、低い値と高い値で指定された範囲で乱数を生成する`rand` `gen_range`操作法の場合に必要です。

`Ord`特性は、注釈付き型の任意の2つの値に対して、有効な順序付けが存在することを知ることができます。
`Ord`特性は、有効な順序付けが常に可能であるため、`Option<Ordering>`ではなく`Ordering`を返す`cmp`操作法を実装します。
`PartialOrd`と`Eq`（ `PartialEq`と`Eq`は`PartialEq`が必要）を実装している型に対してのみ、`Ord`特性を適用することができます。
構造体と列挙型で導出すると、`cmp`は`PartialOrd`で`partial_cmp`の導出実装と同じように動作し`PartialOrd`。

`Ord`が必要な場合の例は、値のソート順に基づいてデータを格納するデータ構造である`BTreeSet<T>`に値を格納する場合です。

### 値を複製するための`Clone`と`Copy`

`Clone`特性を使用すると、明示的に値のディープコピーを作成できます。複製過程では、任意の譜面を実行して原データをコピーすることがあります。
詳細については、第4章の章。「クローン方法の変数とデータのインターアクト」を参照してください`Clone`。

`Clone`導出は、`clone`操作法を実装します。`clone`操作法は、型全体に実装された場合、その型の各部分で`clone`を呼び出します。
また、これは実装しなければならない型のすべての欄または値を意味`Clone`導出する`Clone`。

`Clone`が必要な場合の例は、スライス上で`to_vec`操作法を呼び出す場合です。
スライスには型実例が含まれていませんが、`to_vec`から返されたベクトルは実例を所有する必要があるため、`to_vec`は各項目の`clone`を呼び出します。
したがって、スライスに格納された型は`Clone`実装する必要があります。

`Copy`特性では、山に格納されたビットをコピーするだけで値を複製できます。
任意の譜面は必要ありません。
詳細については、第4章の章。「コピー山専用データ」を参照してください`Copy`。

`Copy`特性では、演譜師がそれらの操作法を多重定義したり、任意の譜面が実行されていないという前提に違反しないようにするための操作法は定義されていません。
そうすれば、すべての演譜師は値のコピーが非常に高速になると考えることができます。

パーツがすべて`Copy`実装するすべての型で`Copy`を導出させることができます。
あなただけ適用することができます`Copy`も実装する型に特性を`Clone`実装型ので、`Copy`の些細な実装がある`Clone`と同じ仕事を実行し`Copy`。

`Copy`特性はめったに必要ありません。
`Copy`を実装する型には最適化が用意されています。つまり、譜面をより簡潔にするために`clone`を呼び出す必要はありません。

`Copy`可能なことはすべて、`Clone`でも達成できますが、譜面は遅くなるか、場所で`clone`を使用する必要があります。

### 値を固定サイズの値にマッピングするための`Hash`

`Hash`特性を使用すると、任意のサイズの型の実例を取得し、その実例をハッシュ機能を使用して固定サイズの値にマップできます。
`Hash`導出すると、`hash`操作法が実装されます。
導出した`hash`操作法の実装は、型の各部分で`hash`を呼び出した結果を結合します。つまり、すべての欄または値が`Hash`を導出するために`Hash`実装する必要があります。

`Hash`が必要な場合の例は、データを効率的に格納するためにキーを`HashMap<K, V>`に格納する場合です。

### `Default`値の黙用

`Default`特性を使用すると、ある型の黙用値を作成できます。
`Default`導出すると`default`機能が実装され`default`。
導出した`default`機能の実装では、型の各部分で`default`機能が呼び出され`default`。つまり、型のすべての欄または値は`Default`を導出するために`Default.`実装する必要があります`Default.`

`Default::default`機能は、第5章の「構造体更新構文による他の実例からの実例の作成」で説明した構造体の更新構文と組み合わせて一般に使用されます。構造体のいくつかの欄をカスタマイズし、`..Default::default()`を使用して残りの欄の黙用値を設定します。

たとえば、`Option<T>`実例で`unwrap_or_default`操作法を使用する場合は、`Default`特性が必要です。
`Option<T>`が`None`場合、`unwrap_or_default`操作法は`Option<T>`格納された`T`型の`Default::default`結果を返し`Default::default`。
