# スマート指し手

*指し手*は、記憶内の番地を含む変数の一般概念です。
この番地は、他のそれ用のデータを参照するか、または「ポイントする」。
Rustの指し手の最も一般的な種類は、第4章で学んだ参照です。参照は`&`記号で示され、それらが示す値を借ります。
データを参照する以外に特別な機能はありません。
また、それらにはオーバーヘッドがなく、最も頻繁に使用する指し手のようなものです。

一方、*スマート指し手*は、指し手のように動作するだけでなく、追加のメタデータと機能を持つデータ構造です。
スマート指し手の概念はRustにとってユニークではない。スマート指し手はC ++で作成され、他の言語でも存在します。
Rustでは、標準譜集で定義されたさまざまなスマート指し手は、参照によって提供される機能を超えた機能を提供します。
この章で取り上げる1つの例は、*参照カウント*スマート指し手型です。
この指し手を使用すると、所有者の数を追跡し、所有者がいない場合はデータを後始末することによって、複数のデータ所有者を持つことができます。

所有権と借用の概念を使用するRustでは、参照とスマート指し手の追加の違いは、参照はデータを借りるだけの指し手であることです。
対照的に、多くの場合、スマート指し手はそれらが指すデータを*所有し*ています。

この本では、第8章の`String`や`Vec<T>`などのスマート指し手については、すでにスマート指し手とは呼ばれていませんでしたが、ここでは遭遇しました。
これらの型はどちらもスマート指し手としてカウントされます。これは、記憶を所有していて、操作できるようにするためです。
また、メタデータ（容量など）と追加の機能や保証（データが常に有効なUTF-8であることを保証する`String`など）もあります。

スマート指し手は、通常、構造体を使用して実装されます。
通常の構造体からスマート指し手を区別する特性は、スマート指し手が`Deref`および`Drop`特性を実装することです。
`Deref`特徴は、スマート指し手構造体の実例を参照のように振る舞うことができるように、参照やスマート指し手のどちらでも動作する譜面を書くことができます。
`Drop`特性を使用すると、スマート指し手の実例が有効範囲外になったときに実行される譜面をカスタマイズできます。
この章では、両方の特徴について説明し、それらがスマート指し手にとってなぜ重要であるかを説明します。

スマート指し手パターンがRustで頻繁に使用される一般的な設計パターンであることを考えると、この章では既存のスマート指し手はすべてカバーしません。
多くの譜集には独自のスマート指し手があり、自分で書くこともできます。
標準譜集で最も一般的なスマート指し手について説明します。

* 原上に値を割り当てるための`Box<T>`
* 複数の所有権を持つ参照カウント型の`Rc<T>`
* `Ref<T>`と`RefMut<T>`を介してアクセスし、`RefCell<T>`実行時の代わりに製譜時に借用ルールを施行型

さらに、不変型が内部値を変更するためのAPIを公開している*内部の可変*パターンについても説明します。
*参照円環*については、記憶域のリークやその防止方法についても説明します。

中に潜んでみましょう！　
