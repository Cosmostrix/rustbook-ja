## 高度な機能と閉包

最後に、機能指し手と機能閉包を含む機能と閉包に関するいくつかの高度な機能について説明します。

### 機能指し手

機能に閉包を渡す方法について話しました。
正規機能を機能に渡すこともできます。
この手法は、新しい閉包を定義するのではなく、すでに定義した機能を渡す場合に便利です。
機能指し手でこれを行うと、機能を他の機能の引数として使用できます。
機能は、`Fn`閉包の特性と混同しないように、`fn`（小文字のf）型を強制型変換します。
`fn`型は*機能指し手*と呼ばれ*ます*。
パラメータが機能指し手であることを指定する構文は、リスト19-35に示すように、閉包の構文に似ています。

<span class="filename">ファイル名。src/main.rs</span>

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
```

<span class="caption">リスト19-35。 <code>fn</code>型を使って機能指し手を引数として受け入れる</span>

この譜面`The answer is: 12`。
`do_twice`のパラメータ`f`は、型`i32` 1つのパラメータをとり、`i32`を返す`fn`あると指定します。
`do_twice`の本文で`f`を呼び出すことができます。
では`main`、機能名を渡すことができ`add_one`最初の引数として`do_twice`。

閉包とは異なり、`fn`は特性ではなく型なので、`Fn`特性の1つを特性縛りとして持つ総称型パラメータを宣言するのではなく、直接パラメータ型として`fn`を指定します。

機能指し手は、3つの閉包特性（`Fn`、 `FnMut`、および`FnOnce`）をすべて実装しているため、閉包が必要な機能の引数として機能指し手ーを渡すことができます。
総称型と閉包特性の1つを使用して機能を書くことが最善です。そのため、機能は機能または閉包を受け入れることができます。

閉包を持たない外部譜面との接点をとる場合は、`fn`だけを受け取り、閉包を受け入れない場合の例です。C機能は機能を引数として受け入れることができますが、Cには閉包はありません。

イン行で定義された閉包または名前付き機能を使用できる場所の例として、`map`使用を見てみましょう。
`map`機能を使用して数値のベクトルを文字列のベクトルにするには、次のように閉包を使用します。

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
```

あるいは、次のように閉包の代わりに機能を`map`の引数として指定することもできます。

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
```

`to_string`という名前の機能が複数存在するので、「先進的な特性」の章で前述した完全修飾構文を使用する必要があることに注意してください。
ここでは、`ToString`特性で定義された`to_string`機能を使用しています。標準譜集は、`Display`実装するすべての型に対して実装しています。

この作法を好む人もいれば、閉包を使う人もいます。
それらは同じ譜面に製譜されてしまいますので、どちらの作法でもより明確になります。

### 戻る閉包

閉包は特性によって表されます。つまり、閉包を直接返すことはできません。
ほとんどの場合、特性を返す必要がある場合は、その特性を実装する具象型を機能の戻り値として使用することができます。
しかし、閉包ではリターン可能な具体的な型がないため、これを行うことはできません。
たとえば、戻り値の型として機能指し手`fn`を使用することはできません。

次の譜面は閉包を直接返しますが、製譜されません。

```rust,ignore
fn returns_closure() -> Fn(i32) -> i32 {
    |x| x + 1
}
```

製譜器の誤りは次のとおりです。

```text
error[E0277]: the trait bound `std::ops::Fn(i32) -> i32 + 'static:
std::marker::Sized` is not satisfied
 -->
  |
1 | fn returns_closure() -> Fn(i32) -> i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -> i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -> i32 + 'static`
  = note: the return type of a function must have a statically known size
```

誤りは`Sized`特性を再度参照します！　
Rustは、閉包を保管するためにどれだけのスペースが必要かを知らない。
この問題を早期に解決する方法を見つけました。
特性対象を使うことができます。

```rust
fn returns_closure() -> Box<Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

この譜面はうまく製譜されます。
特性対象の詳細は、第17章の「異なる型の値を許容する特性対象の使用」を参照してください。

## 概要

すごい！　
今では道具ボックスにRustの機能がいくつかありますが、頻繁に使用することはありませんが、非常に特殊な状況で使用できることがわかります。
誤りメッセージの提案や他の人々の譜面に遭遇したときに、これらの概念や構文を認識できるように、いくつかの複雑な話題を導入しました。
この章を参考にして、ソリューションをご案内します。

次に、本で議論したことのすべてを実践し、もう1つの企画を行います。
