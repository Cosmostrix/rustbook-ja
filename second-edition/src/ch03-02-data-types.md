## データ型

Rustの各値は特定の*データ型のもので*、指定されているデータの種類をRustに知らせるので、そのデータの処理方法を知ることができます。
スカラーと複合体の2つのデータ型下位セットを見ていきます。

Rustは*静的型付き*言語であり、製譜時にすべての変数の型を知っている必要があることを覚えておいてください。
製譜器は、通常、値と使用方法に基づいて、使用する型を推論することができます。
第2章の「推測値と秘密番号の比較」の章で`parse`を使って`String`を数値型に変換したときなど、多くの型が可能な場合は、次のように型の注釈を追加する必要があります。

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

型注釈をここに追加しないと、Rustは次の誤りを表示します。これは、製譜器が使用したい型を知るために私たちからより多くの情報を必要とすることを意味します。

```text
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

他のデータ型には異なる型の注釈が表示されます。

### スカラ型

*スカラ*型は単一の値を表します。
Rustには、整数、浮動小数点数、真偽値、および文字の4つの主なスカラ型があります。
これらは他の演譜言語から認識されるかもしれません。
彼らがRustでどのように働いているかを考えてみましょう。

#### 整数型

*整数*は小数成分のない数値です。
第2章では、`u32`型の1つの整数型を使用しました。
この型宣言は、関連する値が、32ビットの空間を占める符号なし整数（符号付き整数型は、`u`代わりに`i`で始まる）でなければならないことを示します。
表3-1に、Rustの組み込み整数型を示します。
Signed列とUnsigned列の各場合値（たとえば`i16`）を使用して、整数値の型を宣言できます。

<span class="caption">表3-1。Rustの整数型</span>

|<!--Length-->長さ|<!--Signed-->符号つき|<!--Unsigned-->署名なし|
|--------|---------|----------|
|<!--8-bit-->8ビット|`i8`|`u8`|
|<!--16-bit-->16ビット|`i16`|`u16`|
|<!--32-bit-->32ビット|`i32`|`u32`|
|<!--64-bit-->64ビット|`i64`|`u64`|
|<!--arch-->アーチ|`isize`|`usize`|

各場合値は、符号付きまたは符号なしのいずれかであり、明示的なサイズを持ちます。
*符号付き*と*符号なし*は、その数値が負であるか正であるか、つまりその数値に符号が付いている必要がある（符号付きである）か、正であるかどうかだけで符号なしで表すことができるかどうかを示します（符号なし）。
それは紙に数字を書くようなものです。記号が重要なときはプラス記号またはマイナス記号で数字が表示されます。
しかし、数字が正であると仮定することは安全ですが、それは記号なしで示されます。
符号付き数値は、2の補数式を使用して格納されます（これが何であるかわからない場合は、オン行で検索できますが説明は本書の範囲外です）。

各符号付き場合値は -（2  __n-1__ ）から2  __n-1__  -1までの数を格納できます*.n*は場合値が使用するビット数です。
したがって、`i8`は -（2  __7__ ） `u8`  __7__  -1の数値を`u8`できます。符号なし変数には0〜2  __n__  -1の数値を格納できるので、`u8`  __8に__ は0〜2の数値を格納できます __8__  -1、これは0〜255です。

さらに、`isize`と`usize`種類は、算譜が実行されている計算機の種類によって異なります。64ビットアーキテクチャの場合は64ビット、32ビットアーキテクチャの場合は32ビットです。

表3-2に示すいずれかの形式で整数直書きを記述することができます。
バイト直書き以外のすべての数字直書きは、`57u8`などの型接尾辞、および`1_000`などの視覚的区切り文字としての`_`を許可することに注意してください。

<span class="caption">表3-2。Rustの整数直書き</span>

|<!--Number literals-->数直書き|<!--Example-->例|
|------------------|---------------|
|<!--Decimal-->小数|`98_222`|
|<!--Hex-->ヘキサ|`0xff`|
|<!--Octal-->オクタル|`0o77`|
|<!--Binary-->二進譜|`0b1111_0000`|
|<!--Byte (`u8` only)-->バイト（`u8`のみ）|`b'A'`|

だからどのような型の整数を使うべきか、どのように知っていますか？　
もしあなたが確信が持てないなら、Rustの黙用が一般的に良い選択肢であり、整数型は自動的に`i32`ます。この型は、64ビットシステムでさえ一般的に最も高速です。
`isize`または`usize`使用する主な状況は、何らかの集まりの添字を作成するときです。

#### 浮動小数点数型

Rustには、*小数点のある浮動小数点数の* 2つの基本型もあります。
Rustの浮動小数点数型は、それぞれ32ビットと64ビットの`f32`と`f64`です。
現代のCPUでは`f32`とほぼ同じ速度ですが、より精度が高いので、黙用の型は`f64`です。

実際の浮動小数点数を示す例です。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
#//    let x = 2.0; // f64
    let x = 2.0; //  f64

#//    let y: f32 = 3.0; // f32
    let y: f32 = 3.0; //  f32
}
```

浮動小数点数は、IEEE-754標準に従って表されます。
`f32`型は単精度浮動小数点数型で、`f64`型は倍精度です。

#### 数値演算

Rustは、加算、減算、乗算、除算、および剰余のすべての数値型に期待される基本的な数学演算をサポートしています。
次の譜面は、`let`文で各文をどのように使用するかを示しています。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
#    // addition
    // 添加
    let sum = 5 + 10;

#    // subtraction
    // 減算
    let difference = 95.5 - 4.3;

#    // multiplication
    // 乗算
    let product = 4 * 30;

#    // division
    // 分割
    let quotient = 56.7 / 32.2;

#    // remainder
    // 残余
    let remainder = 43 % 5;
}
```

これらの文の各式は、数学演算子を使用して単一の値に評価され、変数に束縛されます。
付録Bには、Rustが提供するすべての演算子のリストが含まれています。

#### ブール型

他のほとんどの演譜言語と同様に、Rustのブール型には、`true`と`false` 2つの値があり`false`。
RustのBoolean型は、`bool`を使用して指定します。
例えば。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let t = true;

#//    let f: bool = false; // with explicit type annotation
    let f: bool = false; // 明示的な型の注釈付き
}
```

真偽値を使用する主な方法は、`if`式などの条件式によるものです。
どのように取り上げる`if`の式は、「制御の流れ」の章でRustに働きます。

#### 文字の種類

これまでは数字だけで作業していましたが、Rustも手紙をサポートしています。
Rustの`char`型は、言語の最も基本的なアルファベット型です。次の譜面は、それを使用する方法の1つを示しています。
（`char`型は二重引用符を使用する文字列ではなく、一重引用符で指定されることに注意してください）。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```

Rustの`char`型はUnicode Scalar Valueを表しています。つまり、ASCII以外の多くの要素を表すことができます。
アクセント付きの手紙。
中国語、日本語、韓国語の文字。
絵文字;
ゼロ幅のスペースはすべてRustの有効な`char`値です。
Unicodeのスカラ値は、範囲`U+0000`に`U+D7FF`と`U+E000`に`U+10FFFF`込み。
しかし、「文字」は実際にはUnicodeの概念ではないため、人間の「文字」の直感は、`char`がRustの`char`と一致しないことがあります。
この話題については、第8章の「文字列」で詳しく説明します。

### 化合物型

*複合型*は、複数の値を1つの型にグループ化できます。
Rustには、組と配列の2つの基本的な複合型があります。

#### 組型

組は、さまざまな型のいくつかの値を1つの複合型にグループ化する一般的な方法です。

組は、カッコで区切った値のリストをコンマで区切って作成します。
組内の各位置は型を持ち、組内の異なる値の型は同じである必要はありません。
この例では、選択肢の注釈を追加しました。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

変数`tup`は、組が単一の複合要素とみなされるため、組全体に束縛されます。
組から個々の値を取得するには、模式照合を使用して次のように組値を破棄できます。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

この算譜は最初に組を作成し、それを変数`tup`ます。
`let`パターンを使用して`tup`をとり、`x`、 `y`、 `z` 3つの別々の変数に変換します。
それは三つの部分に単一の組を壊すので、これは、*非構造*と呼ばれています。
最後に、算譜は`y`の値`6.4`出力します。

模式照合による構造解除に加えて、ピリオド（`.`）とそれに続くアクセスする値の添字を使用して、組要素に直接アクセスすることができます。
例えば。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

この算譜は組`x`作成し、各要素の添字を使って新しい変数を作成します。
ほとんどの演譜言語と同様に、組の最初の添字は0です。

#### 配列型

複数の値の集まりを持つ別の方法は、*配列を使用する方法*です。
組とは異なり、配列のすべての要素は同じ型でなければなりません。
Rustの配列は他の言語の配列とは異なります。なぜなら、Rustの配列は固定長であるためです。宣言された配列は、サイズが拡大または縮小できません。

Rustでは、配列に入る値は角かっこで囲まれたコンマ区切りのリストとして書き出されます。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

配列は、原ではなく山にデータを割り当てたい場合に便利です（山と原については第4章で詳しく説明します）。または、常に固定数の要素を確保したい場合に便利です。
しかし、配列はベクトル型ほど柔軟ではありません。
ベクトルは標準譜集によって提供される同様の集まり型で、サイズの拡大または縮小*が*可能です。
配列やベクトルを使用するかどうかわからない場合は、おそらくベクトルを使用するべきです。
第8章では、ベクトルについて詳しく説明します。

ベクトルではなく配列を使用する場合の例は、年の月の名前を知る必要がある算譜にあります。
このような算譜では月を追加または削除する必要はほとんどありません。したがって、配列には常に12個の項目が含まれていることがわかっているので、配列を使用できます。

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

##### 配列要素へのアクセス

配列は、山に割り当てられた記憶域の単一のチャンクです。
次のように、添字を使用して配列の要素にアクセスできます。

<span class="filename">ファイル名。src / main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

この例では、`first`という名前の変数は配列のindex `[0]`値であるため、値`1`を取得します。
変数`second`は配列の添字`[1]`から値`2`を取得します。

##### 無効な配列要素へのアクセス

配列の最後を過ぎた配列の要素にアクセスしようとするとどうなりますか？　
例を以下の譜面に変更します。製譜は実行されますが、実行時に誤りが発生して終了します。

<span class="filename">ファイル名。src / main.rs</span>

```rust,ignore
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

`cargo run`を使用してこの譜面を`cargo run`すると、次の結果が得られます。

```text
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

製譜では誤りは発生しませんでしたが、算譜で*実行時*誤りが発生し、正常に終了しませんでした。
添字を使用して要素にアクセスしようとすると、指定した添字が配列の長さよりも小さいかどうかが確認されます。
添字が長さよりも長い場合、Rustは*パニック*になります。これは、算譜が誤りで終了したときにRustが使用する用語です。

これは、Rustの安全原則の最初の実例です。
多くの低レベル言語では、このようなチェックは行われず、間違った添字を指定すると無効な記憶にアクセスすることができます。
Rustは、記憶アクセスを許可し続ける代わりにすぐに終了することで、この種の誤りからあなたを守ります。
第9章では、Rustの誤り処理の詳細について説明します。
