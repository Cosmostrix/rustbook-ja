## 対象指向言語の特徴

演譜コミュニティには、言語が対象指向とみなされる必要がある機能についてのコンセンサスはない。
Rustは、OOPを含む多くの演譜パラダイムの影響を受けます。
たとえば、第13章の関数型演譜の機能を調べました.OOP言語は、対象、カプセル化、および継承といった特定の共通の特性を共有しています。
これらの特徴のそれぞれが何を意味し、Rustがそれをサポートしているかを見てみましょう。

### データと動作を含む対象

「 *Design Patterns。* Enoch Gamma、Richard Helm、Ralph Johnson、John Vlissides（Addison-Wesley Professional、1994）の*「再利用可能な対象指向譜体の要素* 」の本は、*The Gang of Fourという*本書では対象指向のカタログ設計パターン。
これはOOPを以下のように定義します。

> > 対象指向算譜は対象で構成されています。
> > *対象は*、データとそのデータで動作するプロシージャの両方をパッケージ化します。
> > この手順は、通常、*操作法*または*操作*と呼ばれ*ます*。

この定義を使用すると、Rustは対象指向です。構造体と列挙型はデータを持ち、`impl`段落は構造体と列挙型の操作法を提供します。
操作法を持つ構造体とenumは対象*と呼ばれ*ませんが、Gang of Fourの対象定義によれば、同じ機能を提供します。

### 実装の詳細を隠すカプセル化

一般的にOOPに関連するもう1つの側面は、対象の実装の詳細がその対象を使用する譜面にアクセスできないことを意味する*カプセル化*のアイデアです。
したがって、対象とやり取りする唯一の方法は、公開APIを使用することです。
対象を使用する譜面は、対象の内部に到達してデータやビヘイビアを直接変更することはできません。
これにより、演譜師は、対象を使用する譜面を変更することなく、対象の内部を変更してリファクタリングすることができます。

第7章でカプセル化を制御する方法について説明しました`pub`予約語を使用して、譜面内のどの役区、型、機能、操作法を公開するかを決めることができます。
たとえば、`i32`値のベクトルを含む欄を持つstruct `AveragedCollection`を定義できます。
構造体には、ベクトルの値の平均を含む欄もあります。つまり、必要に応じて、必要に応じて平均値を計算する必要はありません。
つまり、`AveragedCollection`は計算された平均をキャッシュします。
リスト17-1は、`AveragedCollection`構造体の定義を示しています。

<span class="filename">ファイル名。src / lib.rs</span>

```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```

<span class="caption">リスト17-1。整数リストと集まり内の項目の平均を保持する<code>AveragedCollection</code>構造体</span>

構造体は`pub`とマークされ、他の譜面でも使用できますが、構造体内の欄は内部用のままです。
この場合、値がリストに追加または削除されるたびに平均値も更新されるようにしたいので、これは重要です。
これは、リスト17-2に示すように、構造体に対して`add`、 `remove`、 `average`操作法を実装`add`で`remove`ます。

<span class="filename">ファイル名。src / lib.rs</span>

```rust
# pub struct AveragedCollection {
#     list: Vec<i32>,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            },
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```

<span class="caption">リスト17-2。 <code>AveragedCollection</code> public操作法<code>add</code> 、 <code>remove</code> 、 <code>average</code>実装</span>

`AveragedCollection`実例を変更するには、public操作法`add`、 `remove`、および`average`が唯一の方法です。
項目が`add`操作法を使用して`list`に`add`れるか、または`remove`操作法を使用して`remove`されると、それぞれの実装は`average`欄の更新を処理するprivate `update_average`操作法を呼び出します。

`list`と`average`欄を非公開にしているので、外部譜面が項目を`list`欄に直接追加または削除する方法はありません。
それ以外の場合は、`list`が変更されたときに`average`欄が同期しなくなることがあります。
`average`操作法は`average`欄の値を返します。これにより、外部譜面は`average`を読み取ることができますが、変更はできません。

struct `AveragedCollection`実装の詳細をカプセル化したので、将来、データ構造などのアスペクトを簡単に変更できます。
たとえば、`list`欄に`Vec<i32>`代わりに`HashSet<i32>`使用できます。
`add`、 `remove`、および`average`公開操作法の型指示が同じであれば、`AveragedCollection`を使用する譜面は変更する必要はありません。
行った場合`list`代わりに公開された、これは必ずしもそうではないでしょう。`HashSet<i32>`と`Vec<i32>`、外部譜面はおそらくそれが変更された場合は変更する必要がありますので、項目の追加と削除のためのさまざまな方法を持っている`list`直接。

カプセル化が、言語が対象指向とみなされるために必要な側面である場合、Rustはその要件を満たします。
譜面のさまざまな部分に`pub`を使用するかどうかを選択すると、実装の詳細をカプセル化できます。

### 型システムとしての継承と譜面共有

*継承*は、対象が別の対象の定義から継承することができるしくみであり、そのため、再度定義することなく、親対象のデータと動作が得られます。

言語が対象指向言語であるために継承を持たなければならない場合、Rustは1ではありません。
親構造体の欄と操作法の実装を継承する構造体を定義する方法はありません。
しかし、演譜道具ボックスに継承されることに慣れている場合は、最初に継承の理由に応じて、Rustの他のソリューションを使用することができます。

あなたは、主に2つの理由から継承を選択します。
1つは譜面の再利用です。ある型に対して特定の動作を実装することができ、継承を使用すると、その型の実装を再利用できます。
代わりに、黙用の特性操作法実装を使用してRust譜面を共有することができます。これは、リスト10-14で`Summary`特性の`summarize`操作法の黙用実装を追加したときに見ました。
実装する任意の型の`Summary`特性は持っているでしょう`summarize`任意の更なる譜面なしにそれに方法が利用できます。
これは、操作法の実装を持つ親クラスと、操作法の実装を持つ継承する子クラスに似ています。
また、`Summary`クラスの実装時には、親クラスから継承した操作法の実装を上書きする子クラスに似ている`Summary`プロパティを実装するときに、`summarize`操作法の黙用の実装を上書きすることもできます。

継承を使用するもう一つの理由は、型のシステムに関係します。子型を親型と同じ場所で使用できるようにすること。
これは、*ポリモフィズム*とも呼ばれ、特定の特性を共有する複数の対象を実行時に互いに置き換えることができます。

> ### 多相性
> 
> > 多くの人にとって、多相性は継承と同義です。
> > しかし、実際には、複数の型のデータで動作する譜面を指す、より一般的な概念です。
> > 継承の場合、これらの型は一般に下位クラスです。
> 
> > 代わりにRustは総称化を使用して、異なる型の可能性のある型と特性縛りを抽象化して、それらの型が提供しなければならないものに制約を課します。
> > これは、*有界パラメトリック多相性*とも呼ばれ*ます*。

継承は、多くの場合、必要以上に多くの譜面を共有するリスクがあるため、多くの演譜言語の演譜設計ソリューションとして、近年好まれていません。
下位クラスは、親クラスのすべての特性を常に共有してはいけませんが、継承ではそうします。
これにより、算譜の設計の柔軟性が低下する可能性があります。
また、操作法が下位クラスに適用されないため、意味を持たない下位クラスや誤りの原因となる下位クラスで操作法を呼び出す可能性があります。
さらに、言語によっては、下位クラスが1つのクラスから継承することしかできないため、算譜の設計の柔軟性がさらに制限されます。

これらの理由から、Rustは、継承の代わりに特性対象を使用する別のアプローチを採用しています。
Rustでどのように特性対象が多相性を可能にするかを見てみましょう。
