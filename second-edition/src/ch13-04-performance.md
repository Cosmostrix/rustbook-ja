## パフォーマンスの比較。ループと反復子

ループまたは反復子を使用するかどうかを判断するには、明示的な`for`ループを持つ版または反復子を持つ版を使用して、`search`機能のどの版が高速であるかを知る必要があります。

にアーサーコナンドイルによる*シャーロック・ホームズの冒険*のすべての内容を読み込みすることにより、ベンチマークを実行した`String`と内容で単語を探しています。
`for`ループと反復子を使用した版を使用した`search`の版に関するベンチマークの結果を次に示します。

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

反復子の版はやや速かったです！　
ここでは、2つの版が同等であることを証明するのではなく、これらの2つの実装がどのようにパフォーマンスを比較するかについて一般的な意味を理解するためのものです。

より包括的なベンチマークのためには、さまざまなサイズのさまざまなテキストを`contents`として`query`、異なる長さの単語と単語をさまざまな長さの単語として使用するかどうかを確認する必要があり`query`。
要点は、反復子は高水準の抽象化ではあるが、低水準の譜面を自分で記述した場合とほぼ同じ譜面に製譜されるということです。
反復子は、Rustの*ゼロコスト抽象化*の1つで、抽象化を使用することは追加の実行時オーバーヘッドを課さないことを意味します。
これは、C ++のオリジナルデザイナーで実装者であるBjarne Stroustrupが「Foundations of C ++」（2012年）で*ゼロオーバーヘッド*を定義する方法に似ています。

> > 一般に、C ++の実装は、ゼロオーバーヘッドの原則に従います。使用しないものは、支払うことはありません。
> > そしてさらに。使っていることは、譜面を手渡すことができませんでした。

別の例として、以下の譜面が音声デコーダから取られます。
復号化計算手続きは、線形予測算術演算を使用して、前のサンプルの線形機能に基づいて将来の値を推定します。
この譜面では、反復子チェーンを使用して有効範囲内の3つの変数、データの`buffer`スライス、12個の`coefficients`配列、および`qlp_shift`データをシフトする量を`qlp_shift`ます。
この例では変数を宣言しましたが、値は与えられていません。
この譜面は文脈の外ではあまり意味がありませんが、Rustが高水準のアイデアを低水準の譜面に変換する方法の現実的な簡潔な例です。

```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

`prediction`の値を計算するために、この譜面は`coefficients`の12個の値のそれぞれを反復し、`zip`操作法を使用して、係数値を`buffer`内の前の12個の値とペアにします。
次に、各ペアに対して、値を掛け合わせ、すべての結果を和し、和`qlp_shift`ビットのビットを右側にシフトします。

音声デコーダなどの譜体での計算では、パフォーマンスの優先順位が最も高くなることがよくあります。
ここでは、2つのアダプタを使用し、値を消費する反復子を作成しています。
このRust譜面はどのようなアセンブリ譜面に製譜されますか？　
まあ、この執筆時点では、手作業で書くと同じアセンブリに製譜されます。
`coefficients`の値に対する反復に対応するループは全くありません.Rustは反復が12回あることを知っているので、ループを "展開"します。
*アンロール*とは、ループ制御譜面のオーバーヘッドを取り除き、代わりにループの反復ごとに反復譜面を生成する最適化です。

すべての係数がレジスタに格納されるため、値へのアクセスは非常に高速です。
実行時に配列アクセスの境界チェックはありません。
Rustが適用できるこれらの最適化はすべて、結果譜面を非常に効率的にします。
これを知ったので、恐れなく反復子と閉包を使うことができます！　
それらは譜面をより高い水準のように見せますが、実行時のパフォーマンス上のペナルティを課すことはありません。

## 概要

閉包と反復子は、関数型演譜言語のアイデアに触発されたRustの機能です。
それらは低水準のパフォーマンスで高水準のアイデアを明確に表現するRustの能力に貢献します。
閉包と反復子の実装は、実行時のパフォーマンスに影響を与えないようなものです。
これはゼロコストの抽象化を提供しようとするRustの目標の一部です。

I/O企画の表現力を向上させたので、企画を世界と共有するのに役立つ`cargo`いくつかの機能を見てみましょう。
