## パフォーマンスの比較。ループと<ruby>反復子<rt>イテレータ</rt></ruby>

ループまたは<ruby>反復子<rt>イテレータ</rt></ruby>を使用するかどうかを判断するには、明示的な`for`ループを持つ版または<ruby>反復子<rt>イテレータ</rt></ruby>を持つ版を使用して、`search`機能のどの版が高速であるかを知る必要があります。

にアーサーコナンドイルによる*シャーロック・ホームズの冒険*のすべての内容を読み込みすることにより、ベンチマークを実行した`String`と内容で単語を探しています。
`for`ループと<ruby>反復子<rt>イテレータ</rt></ruby>を使用した版を使用した`search`の版に関するベンチマークの結果を次に示します。

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

<ruby>反復子<rt>イテレータ</rt></ruby>の版はやや速かったです！　
ここでは、2つの版が同等であることを証明するのではなく、これらの2つの実装がどのようにパフォーマンスを比較するかについて一般的な意味を理解するためのものです。

より包括的なベンチマークのためには、さまざまなサイズのさまざまなテキストを`contents`として`query`、異なる長さの単語と単語をさまざまな長さの単語として使用するかどうかを確認する必要があり`query`。
要点は、<ruby>反復子<rt>イテレータ</rt></ruby>は高水準の抽象化ではあるが、低水準の<ruby>譜面<rt>コード</rt></ruby>を自分で記述した場合とほぼ同じ<ruby>譜面<rt>コード</rt></ruby>に<ruby>製譜<rt>コンパイル</rt></ruby>されるということです。
<ruby>反復子<rt>イテレータ</rt></ruby>は、Rustの*ゼロコスト抽象化*の1つで、抽象化を使用することは追加の実行時オーバーヘッドを課さないことを意味します。
これは、C ++のオリジナルデザイナーで実装者であるBjarne Stroustrupが「Foundations of C ++」（2012年）で*ゼロオーバーヘッド*を定義する方法に似ています。

> > 一般に、C ++の実装は、ゼロオーバーヘッドの原則に従います。使用しないものは、支払うことはありません。
> > そしてさらに。使っていることは、<ruby>譜面<rt>コード</rt></ruby>を手渡すことができませんでした。

別の例として、以下の<ruby>譜面<rt>コード</rt></ruby>が音声デコーダから取られます。
復号化<ruby>計算手続き<rt>アルゴリズム</rt></ruby>は、線形予測算術演算を使用して、前のサンプルの線形機能に基づいて将来の値を推定します。
この<ruby>譜面<rt>コード</rt></ruby>では、<ruby>反復子<rt>イテレータ</rt></ruby>チェーンを使用して<ruby>有効範囲<rt>スコープ</rt></ruby>内の3つの変数、データの`buffer`スライス、12個の`coefficients`配列、および`qlp_shift`データをシフトする量を`qlp_shift`ます。
この例では変数を宣言しましたが、値は与えられていません。
この<ruby>譜面<rt>コード</rt></ruby>は文脈の外ではあまり意味がありませんが、Rustが高水準のアイデアを低水準の<ruby>譜面<rt>コード</rt></ruby>に変換する方法の現実的な簡潔な例です。

```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

`prediction`の値を計算するために、この<ruby>譜面<rt>コード</rt></ruby>は`coefficients`の12個の値のそれぞれを反復し、`zip`<ruby>操作法<rt>メソッド</rt></ruby>を使用して、係数値を`buffer`内の前の12個の値とペアにします。
次に、各ペアに対して、値を掛け合わせ、すべての結果を和し、和`qlp_shift`ビットのビットを右側にシフトします。

音声デコーダなどの<ruby>譜体<rt>アプリケーション</rt></ruby>での計算では、パフォーマンスの優先順位が最も高くなることがよくあります。
ここでは、2つのアダプタを使用し、値を消費する<ruby>反復子<rt>イテレータ</rt></ruby>を作成しています。
このRust<ruby>譜面<rt>コード</rt></ruby>はどのようなアセンブリ<ruby>譜面<rt>コード</rt></ruby>に<ruby>製譜<rt>コンパイル</rt></ruby>されますか？　
まあ、この執筆時点では、手作業で書くと同じアセンブリに<ruby>製譜<rt>コンパイル</rt></ruby>されます。
`coefficients`の値に対する反復に対応するループは全くありません.Rustは反復が12回あることを知っているので、ループを "展開"します。
*アンロール*とは、ループ制御<ruby>譜面<rt>コード</rt></ruby>のオーバーヘッドを取り除き、代わりにループの反復ごとに反復<ruby>譜面<rt>コード</rt></ruby>を生成する最適化です。

すべての係数がレジスタに格納されるため、値へのアクセスは非常に高速です。
実行時に配列アクセスの境界チェックはありません。
Rustが適用できるこれらの最適化はすべて、結果<ruby>譜面<rt>コード</rt></ruby>を非常に効率的にします。
これを知ったので、恐れなく<ruby>反復子<rt>イテレータ</rt></ruby>と<ruby>閉包<rt>クロージャー</rt></ruby>を使うことができます！　
それらは<ruby>譜面<rt>コード</rt></ruby>をより高い水準のように見せますが、実行時のパフォーマンス上のペナルティを課すことはありません。

## 概要

<ruby>閉包<rt>クロージャー</rt></ruby>と<ruby>反復子<rt>イテレータ</rt></ruby>は、関数型<ruby>演譜<rt>プログラミング</rt></ruby>言語のアイデアに触発されたRustの機能です。
それらは低水準のパフォーマンスで高水準のアイデアを明確に表現するRustの能力に貢献します。
<ruby>閉包<rt>クロージャー</rt></ruby>と<ruby>反復子<rt>イテレータ</rt></ruby>の実装は、実行時のパフォーマンスに影響を与えないようなものです。
これはゼロコストの抽象化を提供しようとするRustの目標の一部です。

I/O企画の表現力を向上させたので、企画を世界と共有するのに役立つ`cargo`いくつかの機能を見てみましょう。
