## `Sync`と`Send`<ruby>特性<rt>トレイト</rt></ruby>による拡張可能な並列実行

興味深いことに、Rust言語には並行処理機能はほとんどあり*ませ*ん。
これまでのところ、この章で説明したほぼすべての並行処理機能は、言語ではなく標準<ruby>譜集<rt>ライブラリー</rt></ruby>の一部です。
並行処理の<ruby>選択肢<rt>オプション</rt></ruby>は、言語や標準<ruby>譜集<rt>ライブラリー</rt></ruby>に限定されません。
あなた自身の並行処理機能を書くことも、他の人が書いたものを使うこともできます。

しかし、言語には2つの並列実行の概念が組み込まれています。 `std::marker` `Sync`と`Send`特徴を`Send`ます。

### `Send`<ruby>走脈<rt>スレッド</rt></ruby>間の所有権の転送を許可する

`Send`マーカー<ruby>特性<rt>トレイト</rt></ruby>は、`Send`を実装する型の所有権を<ruby>走脈<rt>スレッド</rt></ruby>間で転送できることを示します。
ほぼすべてのRustの種類がある`Send`が、を含むいくつかの例外がある`Rc<T>`これはできません`Send`ますが、クローン化された場合ので、`Rc<T>`値を、別の<ruby>走脈<rt>スレッド</rt></ruby>へのクローンの所有権を譲渡しようとした、両方の<ruby>走脈<rt>スレッド</rt></ruby>が更新かもしれません同時に参照カウント。
このため、`Rc<T>`は、<ruby>走脈<rt>スレッド</rt></ruby>セーフなパフォーマンス上のペナルティを支払う必要がない単一<ruby>走脈<rt>スレッド</rt></ruby>の状況で使用するために実装されています。

したがって、Rustの型体系と<ruby>特性<rt>トレイト</rt></ruby>縛りは、誤って<ruby>走脈<rt>スレッド</rt></ruby>間で`Rc<T>`値を誤って送信することがないようにします。
リスト16-14でこれを実行しようとしたとき`the trait Send is not implemented for Rc<Mutex<i32>>`という<ruby>誤り<rt>エラー</rt></ruby>が発生しまし`the trait Send is not implemented for Rc<Mutex<i32>>`。
`Send`である`Arc<T>`切り替えると、<ruby>譜面<rt>コード</rt></ruby>が<ruby>製譜<rt>コンパイル</rt></ruby>されました。

`Send`型から完全に構成された型は自動的に`Send`とマークされます。
ほとんどすべての基本型はRaw<ruby>指し手<rt>ポインタ</rt></ruby>以外の`Send`です。これについては第19章で説明します。

### `Sync`複数の<ruby>走脈<rt>スレッド</rt></ruby>からのアクセスを許可する

`Sync`マーカーの<ruby>特性<rt>トレイト</rt></ruby>は、`Sync`を実装する型が複数の<ruby>走脈<rt>スレッド</rt></ruby>から参照されることが安全であることを示します。
言い換えれば、`&T`（ `T`への参照）が`Send`であれば、どの型の`T`も`Sync`です。これは、参照が別の<ruby>走脈<rt>スレッド</rt></ruby>に安全に送信できることを意味します。
同様に`Send`、原始的な種類があり`Sync`、および完全にされている種類で構成される型の`Sync`またある`Sync`。

スマート<ruby>指し手<rt>ポインタ</rt></ruby>`Rc<T>`も`Send`はないのと同じ理由で`Sync`ではありません。
`RefCell<T>`型（第15章で説明した）と関連する`Cell<T>`型のファミリは`Sync`型ではありません。
`RefCell<T>`が実行時に行う借用チェックの実装は、<ruby>走脈<rt>スレッド</rt></ruby>セーフではありません。
スマート<ruby>指し手<rt>ポインタ</rt></ruby>`Mutex<T>`は`Sync`あり、「複数の<ruby>走脈<rt>スレッド</rt></ruby>間の`Mutex<T>`共有」の章で見たように、複数の<ruby>走脈<rt>スレッド</rt></ruby>とのアクセスを共有するために使用できます。

### `Send`と`Sync`手動で実装するのが安全でない

`Send`と`Sync`<ruby>特性<rt>トレイト</rt></ruby>で構成されている型は自動的に`Send`と`Sync`でもあるため、これらの<ruby>特性<rt>トレイト</rt></ruby>を手動で実装する必要はありません。
マーカーの<ruby>特性<rt>トレイト</rt></ruby>としては、実装する方法さえありません。
これらは、並列実行に関連する不変条件を強制型変換するのに役立ちます。

これらの<ruby>特性<rt>トレイト</rt></ruby>を手動で実装するには、安全でないRustの<ruby>譜面<rt>コード</rt></ruby>を実装する必要があります。
第19章では安全でないRustの<ruby>譜面<rt>コード</rt></ruby>を使用する方法について説明します。
今のところ重要な情報は、`Send`と`Sync`部分で構成されていない新しい並行型を構築するには、安全の保証を守るために慎重な考えが必要だということです。
[The Rustonomicon]は、これらの保証についてのより多くの情報と、それらを維持する方法があります。

[The Rustonomicon]: https://doc.rust-lang.org/stable/nomicon/

## 概要

これは本書の並列実行の最後ではありません。第20章の企画では、ここで説明した小さな例よりも現実的な状況でこの章の概念を使用します。

前述したように、Rustが並行処理をどのように処理するかは言語の一部であるため、多くの並行処理ソリューションが<ruby>通い箱<rt>クレート</rt></ruby>として実装されています。
これらは標準<ruby>譜集<rt>ライブラリー</rt></ruby>よりも迅速に進化していますので、<ruby>多脈処理<rt>マルチスレッド</rt></ruby>の状況で使用する最新の<ruby>通い箱<rt>クレート</rt></ruby>をオンラインで検索してください。

Rust標準<ruby>譜集<rt>ライブラリー</rt></ruby>は、並行文脈で安全に使用できる`Mutex<T>`や`Arc<T>`などのメッセージパッシングとスマート<ruby>指し手<rt>ポインタ</rt></ruby>型のチャネルを提供します。
型体系と借用検査器は、これらのソリューションを使用する<ruby>譜面<rt>コード</rt></ruby>がデータ競合や無効な参照で終わらないことを保証します。
<ruby>譜面<rt>コード</rt></ruby>を<ruby>製譜<rt>コンパイル</rt></ruby>すると、他の言語でよく見られるような追跡が困難なバグがなくても、複数の<ruby>走脈<rt>スレッド</rt></ruby>でうまく動作することが保証されます。
並行<ruby>演譜<rt>プログラミング</rt></ruby>は、もはや恐れている概念ではありません。<ruby>算譜<rt>プログラム</rt></ruby>を、恐れのないように並行させてください！　

次に、Rust<ruby>算譜<rt>プログラム</rt></ruby>が大きくなるにつれて、問題を模型化して解決策を構成する慣用的な方法について説明します。
加えて、Rustのイディオムが<ruby>対象<rt>オブジェクト</rt></ruby>指向<ruby>演譜<rt>プログラミング</rt></ruby>から慣れ親しんでいるものとどのように関係しているかについて説明します。
