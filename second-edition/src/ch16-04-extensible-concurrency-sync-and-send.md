## `Sync`と`Send`特性による拡張可能な並列実行

興味深いことに、Rust言語には並行処理機能はほとんどあり*ませ*ん。
これまでのところ、この章で説明したほぼすべての並行処理機能は、言語ではなく標準譜集の一部です。
並行処理の選択肢は、言語や標準譜集に限定されません。
あなた自身の並行処理機能を書くことも、他の人が書いたものを使うこともできます。

しかし、言語には2つの並列実行の概念が組み込まれています。 `std::marker` `Sync`と`Send`特徴を`Send`ます。

### `Send`走脈間の所有権の転送を許可する

`Send`マーカー特性は、`Send`を実装する型の所有権を走脈間で転送できることを示します。
ほぼすべてのRustの種類がある`Send`が、を含むいくつかの例外がある`Rc<T>`これはできません`Send`ますが、クローン化された場合ので、`Rc<T>`値を、別の走脈へのクローンの所有権を譲渡しようとした、両方の走脈が更新かもしれません同時に参照カウント。
このため、`Rc<T>`は、走脈セーフなパフォーマンス上のペナルティを支払う必要がない単一走脈の状況で使用するために実装されています。

したがって、Rustの型システムと特性縛りは、誤って走脈間で`Rc<T>`値を誤って送信することがないようにします。
リスト16-14でこれを実行しようとしたとき`the trait Send is not implemented for Rc<Mutex<i32>>`という誤りが発生しまし`the trait Send is not implemented for Rc<Mutex<i32>>`。
`Send`である`Arc<T>`切り替えると、譜面が製譜されました。

`Send`型から完全に構成された型は自動的に`Send`とマークされます。
ほとんどすべての基本型はRaw指し手以外の`Send`です。これについては第19章で説明します。

### `Sync`複数の走脈からのアクセスを許可する

`Sync`マーカーの特性は、`Sync`を実装する型が複数の走脈から参照されることが安全であることを示します。
言い換えれば、`&T`（ `T`への参照）が`Send`であれば、どの型の`T`も`Sync`です。これは、参照が別の走脈に安全に送信できることを意味します。
同様に`Send`、原始的な種類があり`Sync`、および完全にされている種類で構成される型の`Sync`またある`Sync`。

スマート指し手`Rc<T>`も`Send`はないのと同じ理由で`Sync`ではありません。
`RefCell<T>`型（第15章で説明した）と関連する`Cell<T>`型のファミリは`Sync`型ではありません。
`RefCell<T>`が実行時に行う借用チェックの実装は、走脈セーフではありません。
スマート指し手`Mutex<T>`は`Sync`あり、「複数の走脈間の`Mutex<T>`共有」の章で見たように、複数の走脈とのアクセスを共有するために使用できます。

### `Send`と`Sync`手動で実装するのが安全でない

`Send`と`Sync`特性で構成されている型は自動的に`Send`と`Sync`でもあるため、これらの特性を手動で実装する必要はありません。
マーカーの特性としては、実装する方法さえありません。
これらは、並列実行に関連する不変条件を強制型変換するのに役立ちます。

これらの特性を手動で実装するには、安全でないRustの譜面を実装する必要があります。
第19章では安全でないRustの譜面を使用する方法について説明します。
今のところ重要な情報は、`Send`と`Sync`部分で構成されていない新しい並行型を構築するには、安全の保証を守るために慎重な考えが必要だということです。
[The Rustonomicon]は、これらの保証についてのより多くの情報と、それらを維持する方法があります。

[The Rustonomicon]: https://doc.rust-lang.org/stable/nomicon/

## 概要

これは本書の並列実行の最後ではありません。第20章の企画では、ここで説明した小さな例よりも現実的な状況でこの章の概念を使用します。

前述したように、Rustが並行処理をどのように処理するかは言語の一部であるため、多くの並行処理ソリューションが通い箱として実装されています。
これらは標準譜集よりも迅速に進化していますので、マルチ走脈の状況で使用する最新の通い箱をオン行で検索してください。

Rust標準譜集は、並行文脈で安全に使用できる`Mutex<T>`や`Arc<T>`などのメッセージパッシングとスマート指し手型のチャネルを提供します。
型システムと借用検査器は、これらのソリューションを使用する譜面がデータ競合や無効な参照で終わらないことを保証します。
譜面を製譜すると、他の言語でよく見られるような追跡が困難なバグがなくても、複数の走脈でうまく動作することが保証されます。
並行演譜は、もはや恐れている概念ではありません。あなたの算譜を、恐れのないように並行させてください！　

次に、Rust算譜が大きくなるにつれて、問題を模型化して解決策を構成する慣用的な方法について説明します。
加えて、Rustのイディオムが対象指向演譜から慣れ親しんでいるものとどのように関係しているかについて説明します。
