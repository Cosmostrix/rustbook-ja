## UTF-8で符号化された文字列を格納する

第4章で文字列について説明しましたが、ここではそれらをさらに詳しく見ていきます。
新しい屋根裏部屋は、一般的に、可能性のある誤りを表示するためのRustの傾向、文字列が多くの演譜師よりも複雑なデータ構造であること、そしてUTF-8の3つの理由の組み合わせで文字列に突き当たります。
これらの要素は、他の演譜言語から来ているときには難しいように見えます。

文字列はバイトの集合として実装されているので、集まりの文脈で文字列を議論すると便利です。さらに、これらのバイトが文言として解釈されるときに便利な機能を提供するいくつかの操作法があります。
この章では、作成、更新、および読み込みなど、すべての集まり型に含まれる`String`の操作について説明します。
また、`String`が他の集まりと異なる方法、つまり人と計算機が`String`データをどのように解釈するかの違いによって、`String`への索引付けがどのように複雑になるかについても説明します。

### 文字列とは何でしょうか？　

まず、*文字列*という意味を定義し*ます*。
Rustには、コア言語の文字列型が1つしかありません。これは、通常は借用された形式`&str`で表示される文字列slice `str`です。
第4章では、*文字列スライス*について説明しました。これは、他の場所に格納されているUTF-8で符号化された文字列データへの参照です。
たとえば、文字列直書きは、算譜の二進譜出力に格納されるため、文字列スライスです。

コア言語に譜面化されるのではなく、Rustの標準譜集によって提供される`String`型は、拡張可能で変更可能なUTF-8符号化された文字列型です。
ラステーシャンがRustの "strings"を参照するとき、通常、それらの型の1つだけでなく、`String`とstring slice `&str`型を意味します。
この章では主に`String`について説明しますが、どちらの型もRustの標準譜集で頻繁に使用されており、`String`とstringスライスの両方がUTF-8で符号化されています。

Rustの標準譜集には、`OsString`、 `OsStr`、 `CString`、 `CStr`などの他の多くの文字列型も含まれてい`CStr`。
譜集のひな型は、文字列データを格納するためのさらに多くの選択肢を提供します。
それらの名前がす​​べて`String`または`Str`でどのように終わるかを見てください。
それらは、あなたが以前に見た`String`型や`str`型と同じように、所有し、借用している場合値を参照します。
これらの文字列型は、異なる符号化で文言を格納したり、異なる方法で記憶に式することができます。
この章では、他の文字列型については説明しません。
APIの使用方法とそれぞれが適切な場合のAPI開発資料を参照してください。

### 新しい文字列の作成

リスト8-11に示すように、`Vec<T>`利用可能な同じ操作の多くは、文字列を作成する`new`機能から始めて、`String`でも使用できます。

```rust
let mut s = String::new();
```

<span class="caption">リスト8-11。新しい空文字<code>String</code>作成</span>

この行は、`s`という新しい空文字列を作成し、データを読み込むことができます。
多くの場合、文字列を開始する初期データがあります。
そのためには、`to_string`操作法を使用します。これは、文字列直書きのように、`Display`特性を実装するすべての型で使用できます。
リスト8-12に2つの例を示します。

```rust
let data = "initial contents";

let s = data.to_string();

#// the method also works on a literal directly:
// この操作法は直書きでも直接動作します。
let s = "initial contents".to_string();
```

<span class="caption">リスト8-12。 <code>to_string</code>操作法を使って<code>String</code>列直書きから文字列を作成する</span>

この譜面は、`initial contents`を含む文字列を作成します。

`String::from`機能を使用して、文字列直書きから`String`を作成することもできます。
リスト8-13の譜面は、`to_string`を使用する譜面8-12の譜面に相当します。

```rust
let s = String::from("initial contents");
```

<span class="caption">リスト8-13。 <code>String::from</code>機能を使って<code>String</code>列直書きから文字列を作成する</span>

文字列は非常に多くのものに使用されているため、文字列にはさまざまな汎用APIを使用でき、多くの選択肢が用意されています。
それらのいくつかは冗長に見えるかもしれませんが、それらはすべて自分の場所を持っています！　
この場合、`String::from`と`to_string`は同じことを行います。したがって、あなたが選択するのはスタイルの問題です。

文字列はUTF-8で符号化されているので、リスト8-14に示すように、適切に符号化されたデータを符号化することができます。

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

<span class="caption">リスト8-14。文字列内の異なる言語でのグリーティングの保存</span>

これらはすべて有効な`String`値です。

### 文字列の更新

`Vec<T>`内容と同じように、`String`サイズが大きくなり、その内容が変更される可能性があります。
さらに、`+`演算子または`format!`マクロを使用すると、`String`値を連結することができます。

#### `push_str`と`push`文字列に`push_str` `push`

リスト8-15に示すように、`push_str`操作法を使用して文字列スライスを追加することによって、`String`を`push_str`できます。

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

<span class="caption">リスト8-15。に文字列スライス追加は<code>String</code>使用して<code>push_str</code>方法を</span>

この2行の後、`s`含まれています`foobar`。
`push_str`操作法は、必ずしもパラメータの所有権を取得する必要がないため、文字列スライスを使用します。
例えば、リスト8-16の譜面は、`s1`内容を追加した後に`s2`を使用できなかった場合、残念であることを示しています。

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {}", s2);
```

<span class="caption">リスト8-16。にその内容を付加した後、文字列のスライスを使用して<code>String</code></span>

`push_str`操作法が`s2`所有権を取得した場合、最後の行にその値を出力することはできません。
しかし、この譜面は期待どおりに動作します！　

`push`操作法は、パラメータとして単一の文字を取り、それを`String`追加します。
リスト8-17は`push`操作法を使って文字*l*を`String`追加する譜面を示しています。

```rust
let mut s = String::from("lo");
s.push('l');
```

<span class="caption">リスト8-17。 <code>push</code>を使って<code>String</code>値に文字を1つ追加する</span>

この譜面の結果、`s`には`lol`が含まれます。

#### `+`演算子または`format!`マクロとの連結

しばしば、2つの既存の文字列を結合したいと思うでしょう。
1つの方法は、リスト8-18に示すように、`+`演算子を使用することです。

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
#//let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
let s3 = s1 + &s2; //  note s1はここに移動されており、使用できなくなりました
```

<span class="caption">リスト8-18。 <code>+</code>演算子を使って2つの<code>String</code>値を新しい<code>String</code>値に結合する</span>

文字列`s3`は、この譜面の結果として`Hello, world!`が含まれます。
理由は、`s1`が加算の後にもはや有効でなく、`s2`への参照を使用した理由が、`+`演算子を使用したときに呼び出される操作法の型指示と関係があるためです。
`+`演算子は`add`操作法を使用します。その署名は次のようになります。

```rust,ignore
fn add(self, s: &str) -> String {
```

これは標準譜集にある正確な署名ではありません。標準譜集では、`add`は総称化を使って定義されています。
ここでは、genericの代わりに具体的な型`add`持つ`add`の型指示を見ています。これは、この操作法を`String`値で呼び出すときに起こります。
第10章で総称化について説明します。この型指示は、`+`演算子のトリッキーなビットを理解するために必要な手がかりを与えます。

まず、`s2`持っている`&`最初の文字列に2番目の文字列の*参照*追加していることを意味し、`s`中のパラメータ`add`機能を。我々だけ追加することができます`&str`に`String`。
2つの`String`値を一緒に追加することはできません。
しかし、待って-の型`&s2`ある`&String`ではない、`&str`ための2番目のパラメータで指定されているように、`add`。
なぜ、リスト8-18は製譜されますか？　

`add`の呼び出しで`&s2`を使用できる理由は、製譜器が`&String`引数を`&str` *強制型変換*することができるためです。
`add`操作法を呼び出すと、Rustは*deref強制型変換を*使用し`&s2[..]`ここで`&s2`は`&s2[..]`ます。
ので、第15章で詳しく被参照強制型変換を説明します`add`所有取らない`s`パラメータを、`s2`まだ有効になります`String`この操作の後。

次に、型指示では、`add`は`self`所有権があることがわかります。`self`は`&`が*ない*ためです。
これは、リスト8-18の`s1`が`add`呼び出しに移動され、その後は有効ではなくなることを意味します。
だから`let s3 = s1 + &s2;`
両方の文字列をコピーして新しいものを作成するように見えますが、この文は実際に`s1`所有権を持ち、`s2`の内容のコピーを追加してから、結果の所有権を返します。
言い換えれば、それはコピーをたくさん作っているように見えますが、そうではありません。
実装はコピーよりも効率的です。

複数の文字列を連結する必要がある場合、`+`演算子の動作は扱いにくくなります。

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

この時点で、`s`は`tic-tac-toe`ます。
すべてに`+`と`"`の文字、それは何が起こっているかを見ることは困難だより複雑な文字列を組み合わせることについて、使用することができます。`format!`マクロを。

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```

この譜面では、`s`を`tic-tac-toe`ます。
`format!`マクロは`println!`と同じように動作しますが、出力を画面に出力するのではなく、内容を含む`String`を返します。
`format!`を使用した譜面の版は読みやすく、そのパラメータの所有権を取得しません。

### 文字列への索引付け

他の多くの演譜言語では、文字列内の個々の文字に添字で参照してアクセスすることは、有効かつ一般的な操作です。
ただし、Rustの添字構文を使用して`String`一部にアクセスしようとすると、誤りが発生します。
リスト8-19の無効な譜面を考えてみましょう。

```rust,ignore
let s1 = String::from("hello");
let h = s1[0];
```

<span class="caption">譜面リスト8-19。文字列で添字構文を使用しようとする</span>

この譜面では、次の誤りが発生します。

```text
error[E0277]: the trait bound `std::string::String: std::ops::Index<{integer}>` is not satisfied
 -->
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String`
```

誤りとノートはストーリーに伝えます。Rust文字列は添字作成をサポートしていません。
しかし、どうしてでしょうか？　
その質問に答えるために、Rustが文字列を記憶にどのように格納するかについて議論する必要があります。

#### 内部式

`String`は、`Vec<u8>`上のの包みです。
リスト8-14の適切に符号化されたUTF-8のサンプル・文字列のいくつかを見てみましょう。
まず、この1つ。

```rust
let len = String::from("Hola").len();
```

この場合、`len`は4になります。これは、文字列 "Hola"を格納するベクトルが4バイト長であることを意味します。
これらの文字のそれぞれは、UTF-8で符号化されたときに1バイトをとります。
しかし、次の行はどうでしょうか？　
（この文字列は、アラビア数字3ではなく、キリル文字Zeで始まることに注意してください。）

```rust
let len = String::from("Здравствуйте").len();
```

しかし、Rustの答えは24です。これは、Unicodeの各スカラー値が2バイトの記憶域を必要とするため、UTF-8で符号化するのに必要なバイト数です。
したがって、文字列のバイトへの添字は、有効なUnicodeスカラー値と必ずしも相関しません。
実証するために、この無効なRustの譜面を考えてみましょう。

```rust,ignore
let hello = "Здравствуйте";
let answer = &hello[0];
```

`answer`の価値はどうあるべきでしょうか？　
それがあるべき`З`、最初の文字？　
UTF-8で符号化されている場合、`З`の最初のバイトは`208`で、2番目のバイトは`151`なので、`answer`は実際には`208`でなければなりませんが、`208`はそれ自体で有効な文字ではありません。
`208`返すことは、ユーザーがこの文字列の最初の文字を尋ねた場合、ユーザーが望むものではない可能性があります。
しかし、これはRustがバイト添字0で持つ唯一のデータです。文字列にラテン文字のみが含まれていても、ユーザーは一般的に返されるバイト値を望ましくありません。 `&"hello"[0]`がバイト値を返す有効な譜面それは`h`ではなく`104`を返します。
予期しない値を返さず、直ちに発見されない可能性のあるバグを引き起こさないように、Rustはこの譜面をまったく製譜せず、開発過程の初期段階で誤解を防止します。

#### バイトとスカラの値とグレーフェームクラスタ！　
UTF-8についてのもう一つの点は、実際には、Rustの観点から文字列をバイト、スカラー値、および文字列クラスター（*文字*と呼んで*いる*ものに最も近いもの）として見るための3つの関連する方法があるということです。

Devanagari台譜で書かれたヒンディー語の "नमस्ते"を見ると、次のような`u8`値のベクトルとして格納されます。

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

これは18バイトで、計算機が最終的にこのデータをどのように格納するかです。
Rustの`char`型であるUnicodeのスカラー値として見れば、これらのバイトは次のようになります。

```text
['न', 'म', 'स', '्', 'त', 'े']
```

ここには6つの`char`値がありますが、4番目と6番目の文字は文字ではありません。それは独自の意味を持たない発音区別記号です。
最後に、それらを書記官クラスターとして見ると、ヒンディー語を構成する4つの文字を人が何と呼ぶか​​を知ることができます。

```text
["न", "म", "स्", "ते"]
```

Rustは、データがどのような人間言語であっても、各算譜が必要とする解釈を選択できるように、計算機が格納する生の文字列データを解釈するさまざまな方法を提供します。

Rustが`String`を取得するために文字`String`に添字を付けることができないという最終的な理由は、添字処理が常に一定の時間（O（1））を取ることが予想されることです。
しかし、`String`でそのパフォーマンスを保証することはできません。なぜなら、有効な文字がいくつあるのかを判断するために、Rustは最初から最後まで内容を調べなければならないからです。

### スライシング文字列

文字列インデクシング操作の戻り値の型は、バイト値、文字、グラフェンクラスター、または文字列スライスのどれであるべきかが明確でないため、文字列への添字付けはしばしば悪い考えです。
したがって、実際に添字を使用して文字列スライスを作成する必要がある場合、Rustはより具体的になるように指示します。
より具体的に添字を作成し、文字列スライスが必要であることを示すには、`[]`を単一の数字で添字するのではなく、`[]`で範囲を指定して特定のバイトを含む文字列スライスを作成します。

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

ここで、`s`は`&str`の最初の4バイトを含む`&str`になります。
以前は、これらの文字のそれぞれが2バイトであることを述べ`Зд`。これは、 `s`が`Зд`であることを意味します。

`&hello[0..1]`を使用するとどうなりますか？　
答え。ベクトルで無効な添字がアクセスされたのと同じ方法で、実行時にRustがパニックに陥る。

```text
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
```

文字列スライスを作成するには、算譜を異常終了させる可能性があるため、範囲を使用して慎重に文字列スライスを作成する必要があります。

### オーバー文字列反復法

幸い、文字列内の要素には他の方法でアクセスできます。

個々のUnicodeスカラ値に対して操作を実行する必要がある場合は、`chars`操作法を使用するのが最善の方法です。
"नमस्ते"の`chars`を呼び出すと、`char`型の6つの値が返され、結果を繰り返して各要素にアクセスできます。

```rust
for c in "नमस्ते".chars() {
    println!("{}", c);
}
```

この譜面は以下を出力します。

```text
न
म
स
्
त
े
```

`bytes`操作法は、生の各`bytes`を返します。これは、あなたのドメインに適しています。

```rust
for b in "नमस्ते".bytes() {
    println!("{}", b);
}
```

この譜面は、この`String`を構成する18バイトを出力します。

```text
224
164
#// --snip--
//  --snip--
165
135
```

しかし、有効なUnicodeスカラ値は1バイト以上で構成されることを覚えておいてください。

文字列から書記素クラスタを得ることは複雑なので、この機能は標準譜集では提供されていません。
これがあなたが必要とする機能性のものであれば、[crates.io](https://crates.io) Cratesを利用できます。

### 文字列は単純ではありません

まとめると、文字列は複雑です。
異なる演譜言語は、この複雑さをどのように演譜師に提示するかについて異なる選択をします。
Rustは、すべてのRust算譜の黙用の動作である`String`データの正しい処理を行うことを選択しました。これは、演譜師がUTF-8データを先に処理することをもっと考慮する必要があることを意味します。
この相殺取引は、他の演譜言語よりも複雑な文字列を提供しますが、開発ライフ円環の後半で非ASCII文字を含む誤りを処理する必要がなくなります。

ちょっと複雑ではないものに切り替えることができます。ハッシュマップ！　
