# 恐れのない並列実行

並列演譜を安全かつ効率的に処理することは、Rustの主な目標の1つです。
*算譜の*異なる部分が独立して実行される*並行演譜*、および*算譜の*異なる部分が同時に実行される*並列演譜は*、より多くの計算機が複数のプロセッサを利用するにつれてますます重要になってきています。
歴史的に、これらの文脈での演譜は難しく、誤りが発生しやすくなりました.Rustはそれを変えたいと考えています。

当初、Rustチームは記憶域の安全性を保証し、並列実行の問題を防ぐことは、異なる方法で解決する2つの別々の課題であると考えていました。
時間の経過とともに、チームは、所有権と型の算系が、記憶域の安全性*と*同時実行性の問題を管理するための強力な道具群であることを発見しました。
所有権と型チェックを利用することで、多くの同時実行誤りは、実行時誤りではなく、Rustの製譜時誤りです。
したがって、実行時の並列実行のバグが発生する正確な状況を再現しようと多くの時間を費やすのではなく、誤った譜面が製譜を拒否し、問題を説明する誤りを表示します。
その結果、譜面を実際に運用に移した後ではなく、作業中に譜面を修正することができます。
Rustの*恐怖のない* *並列実行の*この側面にニックネームをつけた。
恐怖のない並行処理により、微妙なバグのない譜面を書くことができ、新しいバグを導入することなくリファクタリングが容易になります。

> > 注。わかりやすくするために、*同時および/または並行と*言って、より正確なものではなく、*同時の*ものとして多くの問題を参照します。
> > この本が並列実行や並列性に関するものであれば、より具体的なものになります。
> > この章では、*同時に*精神的に代替*同時および/または並列*に使用してくださいいつでも。

多くの言語は、並列問題を処理するために提供するソリューションについて独断的です。
たとえば、Erlangはメッセージパッシングの並行処理のための洗練された機能を持っていますが、走脈間で状態を共有するためのあいまいな方法しかありません。
可能なソリューションの下位セットのみをサポートすることは、より高水準の言語のための合理的な戦略です。なぜなら、より高い水準の言語は、抽象化を得るために何らかの制御を放棄することによる利益を約束するからです。
しかし、低水準の言語は、特定の状況で最高のパフォーマンスをソリューションに提供し、ハードウェア上の抽象度が低下することが予想されます。
したがって、Rustは、状況や要件に適した方法で問題を模型化するためのさまざまな道具を提供しています。

この章で説明する話題は次のとおりです。

* 複数の譜面を同時に実行する走脈を作成する方法
* チャネルが走脈間でメッセージを送信するメッセージ*パッシング*同時実行性
* 複数の走脈があるデータにアクセスできる、*共有状態の*同時実行性
* Rustの並列実行を保証する`Sync`および`Send`特性は、標準譜集によって提供される型だけでなく、利用者定義型にも保証されます
