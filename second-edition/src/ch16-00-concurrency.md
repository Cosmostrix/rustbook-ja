# 恐れのない並列実行

並列<ruby>演譜<rt>プログラミング</rt></ruby>を安全かつ効率的に処理することは、Rustの主な目標の1つです。
*<ruby>算譜<rt>プログラム</rt></ruby>の*異なる部分が独立して実行される*並行<ruby>演譜<rt>プログラミング</rt></ruby>*、および*<ruby>算譜<rt>プログラム</rt></ruby>の*異なる部分が同時に実行される*並列<ruby>演譜<rt>プログラミング</rt></ruby>は*、より多くの<ruby>計算機<rt>コンピューター</rt></ruby>が複数のプロセッサを利用するにつれてますます重要になってきています。
歴史的に、これらの文脈での<ruby>演譜<rt>プログラミング</rt></ruby>は難しく、<ruby>誤り<rt>エラー</rt></ruby>が発生しやすくなりました.Rustはそれを変えたいと考えています。

当初、Rustチームは<ruby>記憶域<rt>メモリー</rt></ruby>の安全性を保証し、並列実行の問題を防ぐことは、異なる方法で解決する2つの別々の課題であると考えていました。
時間の経過とともに、チームは、所有権と型体系が、<ruby>記憶域<rt>メモリー</rt></ruby>の安全性*と*同時実行性の問題を管理するための強力な道具群であることを発見しました。
所有権と型チェックを利用することで、多くの同時実行<ruby>誤り<rt>エラー</rt></ruby>は、実行時<ruby>誤り<rt>エラー</rt></ruby>ではなく、Rustの<ruby>製譜<rt>コンパイル</rt></ruby>時<ruby>誤り<rt>エラー</rt></ruby>です。
したがって、実行時の並列実行のバグが発生する正確な状況を再現しようと多くの時間を費やすのではなく、誤った<ruby>譜面<rt>コード</rt></ruby>が<ruby>製譜<rt>コンパイル</rt></ruby>を拒否し、問題を説明する<ruby>誤り<rt>エラー</rt></ruby>を表示します。
その結果、<ruby>譜面<rt>コード</rt></ruby>を実際に運用に移した後ではなく、作業中に<ruby>譜面<rt>コード</rt></ruby>を修正することができます。
Rustの*恐怖のない* *並列実行の*この側面にニックネームをつけた。
恐怖のない並行処理により、微妙なバグのない<ruby>譜面<rt>コード</rt></ruby>を書くことができ、新しいバグを導入することなくリファクタリングが容易になります。

> > 注。わかりやすくするために、*同時および/または並行と*言って、より正確なものではなく、*同時の*ものとして多くの問題を参照します。
> > この本が並列実行や並列性に関するものであれば、より具体的なものになります。
> > この章では、*同時に*精神的に代替*同時および/または並列*に使用してくださいいつでも。

多くの言語は、並列問題を処理するために提供するソリューションについて独断的です。
たとえば、Erlangはメッセージパッシングの並行処理のための洗練された機能を持っていますが、<ruby>走脈<rt>スレッド</rt></ruby>間で状態を共有するためのあいまいな方法しかありません。
可能なソリューションの下位セットのみをサポートすることは、より高水準の言語のための合理的な戦略です。なぜなら、より高い水準の言語は、抽象化を得るために何らかの制御を放棄することによる利益を約束するからです。
しかし、低水準の言語は、特定の状況で最高のパフォーマンスをソリューションに提供し、ハードウェア上の抽象度が低下することが予想されます。
したがって、Rustは、状況や要件に適した方法で問題を模型化するためのさまざまな道具を提供しています。

この章で説明する話題は次のとおりです。

* 複数の<ruby>譜面<rt>コード</rt></ruby>を同時に実行する<ruby>走脈<rt>スレッド</rt></ruby>を作成する方法
* チャネルが<ruby>走脈<rt>スレッド</rt></ruby>間でメッセージを送信するメッセージ*パッシング*同時実行性
* 複数の<ruby>走脈<rt>スレッド</rt></ruby>があるデータにアクセスできる、*共有状態の*同時実行性
* Rustの並列実行を保証する`Sync`および`Send`<ruby>特性<rt>トレイト</rt></ruby>は、標準<ruby>譜集<rt>ライブラリー</rt></ruby>によって提供される型だけでなく、利用者定義型にも保証されます
