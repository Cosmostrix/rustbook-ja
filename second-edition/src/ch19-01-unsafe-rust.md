## 安全でないRust

これまで説明したすべての譜面では、製譜時にRustの記憶安全性が保証されています。
しかし、Rustは内部に隠された第2言語を持っています。これは、*安全でないRust*と呼ばれ、通常のRustのように動作しますが、余分な超電力を与えます。

事実、静的分析は保守的であるため、安全でないRustが存在します。
製譜器が譜面が保証を維持するかどうかを判断しようとすると、いくつかの無効な算譜を受け入れるのではなく、有効な算譜を拒否する方が良いでしょう。
譜面は大丈夫かもしれませんが、Rustが言うことができる限り、そうではありません！　
このような場合、安全でない譜面を使用して、製譜器に「信頼してください、私がやっていることを知っています。」ということを伝えることができます。危険な譜面を使用することは危険です。安全でない譜面を誤って使用すると、ヌル・指し手ー逆参照などの安全でないものが発生する可能性があります。

Rustが危険な自我を持っているもう一つの理由は、基本的な計算機のハードウェアが本質的に危険であるということです。
Rustが安全でない操作をさせなかった場合、あなたは特定の作業を行うことができませんでした。
Rustは、オペレーティングシステムと直接対話する、または独自のオペレーティングシステムを作成するなど、低レベルのシステム演譜を可能にする必要があります。
低レベルのシステム演譜を使用することは、言語の目標の1つです。
安全でないRustに何ができるのか、それをどうするかを探そう。

### 安全でない超大国

安全でないRustに切り替えるには、`unsafe`予約語を使用し、`unsafe`ない譜面を保持する新しい段落を開始します。
安全では*ないスーパーパワー*と呼ばれる*安全*でないルストでは、4つの動作を取ることができます。
これらの超大国には以下の能力が含まれます。

* 未処理の指し手を参照解除する
* 安全でない機能または操作法を呼び出す
* 可変静的変数へのアクセスまたは変更
* 安全でない特性を実装する

`unsafe`ないと借用検査器を無効にしたり、Rustの安全チェックを無効にしたりすることはないことを理解することが重要です。`unsafe`でない譜面で参照を使用してもチェックされます。
`unsafe`予約語は、記憶安全性のために製譜器によってチェックされない4つの機能にのみアクセスできます。
あなたはまだ安全でない段落の中である程度の安全を得るでしょう。

さらに、`unsafe`ないということは、段落内の譜面が必然的に危険であるということ、または記憶域の安全上の問題があることを意味するわけではありません。演譜師として、`unsafe`段落内の譜面が、。

人々は間違いがあり、間違いが起こりますが、これらの4つの安全でない操作に安全で`unsafe`ことが注釈された段落の内側にあることを要求することにより、記憶域の安全性に関する誤りは`unsafe`段落内になければなりません。
`unsafe`段落は小さくしてください。
後で記憶バグを調べると感謝しています。

安全でない譜面を可能な限り分離するには、安全でない譜面を安全な抽象的に囲み、安全なAPIを提供することが最善です。これについては、安全でない機能や操作法を調べるときの章で後述します。
標準譜集の一部は、監査された安全でない譜面に対して安全な抽象として実装されています。
危険な譜面を安全な抽象的に包むことで、安全な抽象を使用することは`unsafe`であるため、安全で`unsafe`譜面を実装する機能を使用したいと思うすべての場所に`unsafe`で`unsafe`ものが漏れるのを防ぎます。

安全でない4つの超大国のそれぞれを順番に見てみましょう。
また、安全でない譜面との安全な接点を提供する抽象概念についても見ていきます。

### 未処理の指し手を参照解除する

第4章の「Dangling References」章では、製譜器が参照が常に有効であることを保証していると述べました。
Unsafe Rustには、参照に似ている*生指し手*という2つの新しい型があります。
参照の場合と同様に、生指し手は不変または変更可能であり、それぞれ`*const T`および`*mut T`として記述されます。
アスタリスクは逆参照演算子ではありません。
それは型名の一部です。
生指し手の文脈では、*immutable*は、逆参照された後に指し手を直接割り当てることができないことを意味します。

参照とスマート指し手とは異なり、生指し手。

* 不変および変更可能な指し手または同じ場所への複数の変更可能な指し手の両方を持つことによって、借用ルールを無視することができます
* 有効な記憶を指すことが保証されていない
* nullにできる
* 自動後始末を実装しないでください

Rustにこれらの保証を適用することを拒否することにより、より高いパフォーマンスとRustの保証が適用されない別の言語またはハードウェアとの接点機能と引き換えに保証された安全性を放棄することができます。

リスト19-1は、参照から不変および変更可能な生指し手を作成する方法を示しています。

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

<span class="caption">リスト19-1。参照からの生指し手の作成</span>

この譜面に`unsafe`予約語は含まれていないことに注意してください。
安全な譜面で生指し手を作成することができます。
安全でない段落の外に生の指し手を逆参照することはできません。

`as`を使っ`as`不変の参照と変更可能な参照を対応する未処理の指し手型にキャストすることで、未加工の指し手を作成しました。
有効であることが保証されている参照から直接作成したため、これらの特定のロー指し手が有効であることがわかりましたが、ロー指し手についてはその仮定をすることはできません。

次に、有効性がそれほど高くない生の指し手を作成します。
リスト19-2は、記憶内の任意の場所への生指し手を作成する方法を示しています。
任意の記憶を使用しようとすると、その番地にデータが存在する可能性があります。そうしないと、製譜器は譜面を最適化して記憶アクセスがないか、セグメンテーションフォルトで誤りが発生する可能性があります。
通常、このような譜面を記述する正当な理由はありませんが、可能です。

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

<span class="caption">リスト19-2。任意の記憶番地への生指し手の作成</span>

安全な譜面で生指し手を作成できることを思い出してください。しかし、生指し手を*逆参照*したり、指し示されているデータを読み込んだりすることはできません。
リスト19-3では、`unsafe`段落を必要とする生指し手に対して逆参照演算子`*`を使用しています。

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

<span class="caption">リスト19-3。 <code>unsafe</code>段落内で生指し手を参照解除する</span>

指し手を作成することは問題ありません。
無効な値を扱うことになるかもしれないと指摘している値にアクセスしようとするときだけです。

リスト19-1と19-3では、`num`が格納されている同じ記憶位置を指していた`*const i32`と`*mut i32`生指し手を作成したことにも注意してください。
代わりに、不変で変更可能な`num`への参照を作成しようとした場合、Rustの所有権規則は不変参照と同時に変更可能な参照を許可しないため、譜面は製譜されません。
生の指し手では、可変指し手と不変の指し手を同じ場所に作成し、可変指し手を介してデータを変更することができ、データ競合が発生する可能性があります。
注意してください！　

これらの危険性のすべてを理由に、なぜ生指し手を使用するのでしょうか？　
次の章「安全ではない機能または操作法を呼び出す」のように、C譜面と接点するときの主な使用例があります。もう1つのケースは、借用検査器が理解できない安全な抽象を構築する場合です。
安全でない機能を導入し、安全でない譜面を使用する安全な抽象の例を見ていきます。

### 安全でない機能または操作法を呼び出す

安全でない段落を必要とする第2の型の操作は、安全でない機能を呼び出すことです。
安全ではない機能や操作法は、通常の機能や操作法とまったく同じように見えますが、残りの定義よりも`unsafe`なります。
この文脈の`unsafe`予約語は、機能がこの機能を呼び出すときに必要とする要件があることを示しています。なぜなら、Rustはこれらの要件を満たしているとは保証できないからです。
`unsafe`段落内で`unsafe`ない機能を呼び出すことによって、この機能の開発資料を読み、その機能の契約を守る責任があると言います。

ここに`dangerous`名前の`dangerous`な機能があります。危険な機能は本体内に何もしません。

```rust
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
```

`unsafe`別の段落内で`dangerous`機能を呼び出す必要があります。
`unsafe`段落なしで`dangerous`を呼び出そうとすると、誤りが発生します。

```text
error[E0133]: call to unsafe function requires unsafe function or block
 -->
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
```

`unsafe`段落を`dangerous`呼び出しの周りに挿入することで、機能の開発資料を読んだこと、正しく使用する方法を理解していること、そして機能の規約を満たしていることが確認されました。

危険な機能の本体が効果的です`unsafe`段落、とても危険な機能内で他の危険な操作を実行するために、別の追加する必要はありません`unsafe`段落を。

#### 安全でない譜面に対する安全な抽象化の作成

機能が安全でない譜面を含んでいるからといって、機能全体を危険なものとしてマークする必要はありません。
実際、安全でない譜面を安全な機能に包むことは一般的な抽象化です。
一例として、標準譜集`split_at_mut`から安全でない譜面が必要な機能を調べて、実装する方法を調べてみましょう。
この安全な操作法は可変スライスで定義されています。スライスを1つ取り、引数として与えられた添字でスライスを分割して2つにします。
リスト19-4は、`split_at_mut`使い方を示しています。

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

<span class="caption">リスト19-4。safe <code>split_at_mut</code>機能の使用</span>

安全なRustだけを使用してこの機能を実装することはできません。
リスト19-5のようなものがありますが、これは製譜されません。
`split_at_mut`ために、`split_at_mut`を操作法ではなく機能として実装し、総称型`T`ではなく`i32`値のスライスに対してのみ実装します。

```rust,ignore
fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);

    (&mut slice[..mid],
     &mut slice[mid..])
}
```

<span class="caption">リスト19-5。 <code>split_at_mut</code>だけを使って<code>split_at_mut</code>を実装しようとした</span>

この機能は、最初にスライスの全長を取得します。
次に、パラメータとして指定された添字が長さ以下であるかどうかをチェックすることによってスライス内にあることを示します。
アサーションとは、スライスを分割する添字よりも大きい添字を渡すと、その添字を使用しようとする前に機能がパニックすることを意味します。

次に、元のスライスの始めから`mid`添字まで、スライスの`mid`から終わりまでの2つの可変スライスを組に返します。

リスト19-5の譜面を製譜しようとすると、誤りが発生します。

```text
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 -->
  |
6 |     (&mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
```

Rustの借用検査器は、スライスのさまざまな部分を借りていることを理解できません。
同じスライスから2回借りていることを知っているだけです。
2つのスライスが重なっていないので、スライスの異なる部分を借用するのは基本的に問題ありませんが、Rustはこれを知るには十分スマートではありません。
譜面は大丈夫だが、Rustはそうでないことが分かっているときは、安全でない譜面に手を差し伸べるべき時です。

リスト19-6は、`unsafe`段落、生指し手、および安全ではない機能への呼び出しを使用して`split_at_mut`の実装を`split_at_mut`させる方法を`split_at_mut`います。

```rust
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
```

<span class="caption">譜面リスト19-6。 <code>split_at_mut</code>機能の実装で安全でない譜面を使用する</span>

第4章の「スライス型」の章から、スライスはそれ用のデータへの指し手とスライスの長さを思い出してください。
`len`操作法を使用してスライスの長さを取得し、`as_mut_ptr`操作法を使用してスライスの生指し手にアクセスします。
この場合、`i32`値に対する可変スライスを持っているので、`as_mut_ptr`は変数`ptr`格納した`*mut i32`型の生指し手を返します。

`mid`添字がスライス内にあるという主張を維持します。
次に安全でない譜面に到達します。 `slice::from_raw_parts_mut`機能は生指し手と長さを取り、スライスを作成します。
この機能を使用して、`ptr`から始まり、長い`mid`項目のスライスを作成します。
その後、呼んで`offset`の方法`ptr`して`mid`から始まる生の指し手を取得するには、引数として`mid`、その指し手を使用してスライスし、後の項目の残り数作成`mid`の長さなどを。

`slice::from_raw_parts_mut`機能は、生指し手を取り、この指し手が有効であると信頼する必要があるため、安全ではありません。
未処理の指し手に対する`offset`操作法も安全ではありません。なぜなら、オフセット位置も有効な指し手であると信頼する必要があるからです。
したがって、`slice::from_raw_parts_mut`と`offset`呼び出しのあちこちに`unsafe`段落を置く`slice::from_raw_parts_mut`ありました。
譜面を見て、`mid`が`len`以下でなければならないというアサーションを追加することで、`unsafe`段落内で使用されるすべての生指し手がスライス内のデータへの有効な指し手になることがわかります。
これは、`unsafe`では`unsafe`許容され、適切に使用されます。

結果として生じる`split_at_mut`機能を`unsafe`ものとしてマークする必要はなく、この機能を安全なRustから呼び出すことができます。
使用する機能の実装に危険な譜面への安全な抽象化を作成した`unsafe`ことは、この機能がアクセスできるデータから、唯一の有効な指し手を作成するので、安全な方法で譜面を。

対照的に、リスト19-7の`slice::from_raw_parts_mut`使用は、`slice::from_raw_parts_mut`の使用時に異常終了する可能性があります。
この譜面は任意の記憶位置をとり、10,000個の項目のスライスを作成します。

```rust
use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
```

<span class="caption">リスト19-7。任意の記憶位置からスライスを作成する</span>

この任意の場所に記憶を所有しておらず、この譜面が作成するスライスに有効な`i32`値が含まれているという保証はありません。
有効なスライスであるかのように`slice`を使用しようとすると、未定義の動作が発生します。

#### `extern`機能を使用した外部譜面の呼び出し

時々、あなたのRustの譜面は、別の言語で書かれた譜面と対話する必要があるかもしれません。
このため、Rustには*外部機能接点（FFI）*の作成と使用を容易にする`extern`という予約語があります。
FFIは、演譜言語が機能を定義し、それらの機能を呼び出すために異なる（外部の）演譜言語を使用可能にする方法です。

リスト19-8は、C標準譜集の`abs`機能との統合を設定する方法を示しています。
`extern`段落内で宣言された機能は、必ずしもRust譜面から呼び出すのは安全ではありません。
その理由は、他の言語はRustの規則と保証を強制型変換せず、Rustはそれらを検査できないため、安全性を確保するために演譜師が責任を負うからです。

<span class="filename">ファイル名。src / main.rs</span>

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

<span class="caption">リスト19-8。別の言語で定義された<code>extern</code>機能の宣言と呼び出し</span>

`extern "C"`段落内では、外部機能の名前と署名を、別の言語から呼び出したいとします。
`"C"`部分は、外部機能が使用する*譜体二進譜接点（ABI）を*定義します。ABIは、アセンブリレベルで機能を呼び出す方法を定義します。
`"C"` ABIは最も一般的であり、C演譜言語のABIに従います。

> #### 他の言語からRust機能を呼び出す
> 
> > `extern`を使用して、他の言語がRust機能を呼び出すことができるようにする接点を作成することもできます。
> > 代わりに`extern`段落、追加`extern`予約語をし、直前に使用するABIを指定`fn`予約語。
> > また、`#[no_mangle]`注釈を追加して、この機能の名前をmangleしないようにRust製譜器に指示する必要があります。
> > *Mangling*は製譜器が機能を与えた名前を、製譜過程の他の部分が消費するが人間の読取り可能性は低いというより多くの情報を含む別の名前に変更するときです。
> > すべての演譜言語製譜器は名前を若干違うようにマングルするので、Rust機能が他の言語で名前を付けるためには、Rust製譜器の名前マングリングを無効にする必要があります。
> 
> > 次の例では、`call_from_c`機能を共有譜集に製譜してC譜面からリンクした後で、C譜面からアクセスできるようにします。
> 
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
> 
> > `extern`この使用法は`unsafe`ないことを要求しませ`unsafe`。

### 可変静的変数へのアクセスまたは変更

今まで、Rustはサポートしていますが、Rustの所有権ルールでは問題になる可能性がある*全体変数*については説明していません。
2つの走脈が同じ可変全体変数にアクセスしている場合、データ競合が発生する可能性があります。

Rustでは、全体変数は*静的*変数と呼ばれます。
リスト19-9は、文字列sliceを値として持つ静的変数の宣言と使用例を示しています。

<span class="filename">ファイル名。src / main.rs</span>

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```

<span class="caption">リスト19-9。不変の静的変数の定義と使用</span>

静的変数は定数と似ています。これについては第3章の「変数と定数の違い」で説明しました。静的変数の名前は慣習的に`SCREAMING_SNAKE_CASE`に*あり*、変数の型に注釈を付ける*必要があり* `&'static str`。この例。
静的変数は`'static`寿命を持つ参照のみを格納できます。これは、Rust製譜器が寿命を把握できることを意味します。
明示的に注釈を付ける必要はありません。
不変の静的変数へのアクセスは安全です。

定数と不変の静的変数は同じように見えるかもしれませんが、微妙な違いは静的な変数の値が記憶内の固定番地を持つことです。
値を使用すると常に同じデータにアクセスします。
一方、定数は使用されるたびにデータを複製することができます。

定数と静的変数の別の違いは、静的変数が変更可能であることです。
可変静的変数へのアクセスと変更は*安全で*はあり*ません*。
リスト19-10は、`COUNTER`という可変静的変数を宣言、アクセス、および変更する方法を示しています。

<span class="filename">ファイル名。src / main.rs</span>

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

<span class="caption">リスト19-10。可変静的変数からの読み書きは安全ではありません</span>

通常の変数と同様に、`mut`予約語を使用してmutabilityを指定します。
`COUNTER`から読み取りまたは書き込みを行う譜面は、`unsafe`段落内になければなりません。
この譜面は、単一走脈であるため、`COUNTER: 3`を製譜して出力します。
複数の走脈が`COUNTER`アクセスすると、データ競合が発生する可能性があります。

全体が操作可能な変更可能なデータでは、データの競合がないことを保証することは難しいため、Rustは変更可能な静的変数を安全でないとみなしています。
可能であれば、第16章で説明した並行処理手法と走脈セーフスマート指し手を使用することが望ましいため、製譜器は、異なる走脈からアクセスされたデータが安全に実行されることをチェックします。

### 安全でない特性の実装

`unsafe`で`unsafe`場合にのみ機能する最終的な動作は、安全でない特性を実装することです。
少なくとも1つの操作法に製譜器が検証できない不変量がある場合、特性は安全ではありません。
リスト19-11に示すように、特性の前に`unsafe`予約語を追加し、`trait`の実装を`unsafe`ものとしてマークすることで、特性が`unsafe`ことを宣言することができます。

```rust
unsafe trait Foo {
#    // methods go here
    // 操作法はここに行く
}

unsafe impl Foo for i32 {
#    // method implementations go here
    // 操作法実装はここに
}
```

<span class="caption">リスト19-11。危険な特性の定義と実装</span>

`unsafe impl`を使用することで、製譜器が検証できない不変条件を維持することを約束しています。

たとえば、第16章の「 `Sync`と`Send`特性による拡張可能な並列実行」の章で説明した`Sync`と`Send`マーカーの特性を思い出して`Send`これらの特性は、すべての型が`Send`型と`Sync`型で構成されていれば自動的に実装されます。
未処理の指し手など、`Send`または`Sync`ではない型を実装している場合、その型を`Send`または`Sync`としてマークするには、`unsafe`ないものを使用する必要があります。
Rustは、型が走脈間で安全に送信されたり、複数の走脈からアクセスされたりする保証があることを検証することはできません。
したがって、これらのチェックを手動で行い、`unsafe`で`unsafe`として指示する必要があります。

### 安全でない譜面を使用する場合

今話題にされた4つの行動（超大国）のうちの1つを取るために`unsafe`を使用することは、間違っていないか、あるいは悩まされることさえありません。
しかし、製譜器が記憶域の安全性を支えることができないため、`unsafe`譜面を正しいものにするのは難しいです。
`unsafe`譜面を使用する理由がある場合は、そうすることができます。明示的で`unsafe`注釈があれば、問題が発生した場合に問題の原因を追跡するのが簡単になります。
