# 付録G -Rustがどのように作られ、"夜間のRust"

この付録は、Rustがどのように作られたのか、それがRustの開発者としてどのように影響するのかについてです。
この本の出力は安定したRust 1.21.0によって生成されたと述べましたが、それより大きな安定版の安定版であれば<ruby>製譜<rt>コンパイル</rt></ruby>を続けるべきです。
この章では、これが正しいことをどのように保証するかについて説明します。

### 停滞のない安定

言語として、Rustは<ruby>譜面<rt>コード</rt></ruby>の安定性について*多くの*ことを心配しています。
ルストを上に構築できる堅固な基盤にしたいと思っています。物事が絶えず変化しているのなら、それは不可能でしょう。
同時に、新しい機能を試すことができない場合、リリース後、物事を変えることができなくなるまで、重要な欠陥を見つけられないことがあります。

この問題に対する当社の解決策は、「停滞のない安定性」と呼ばれるものであり、指針はこれです。安定したRustの新しい版へのアップグレードを恐れる必要はありません。
各アップグレードは苦しみなくあるべきですが、新機能、バグの削減、<ruby>製譜<rt>コンパイル</rt></ruby>時間の短縮も必要です。

### 汽車ポッポ！　
Rustの開発は*電車のスケジュールで行われ*ます。
つまり、すべての開発はRustリポジトリの`master`分岐で行われます。
リリースは、Cisco IOSおよびその他の<ruby>譜体<rt>アプリケーション</rt></ruby>企画で使用されている<ruby>譜体<rt>アプリケーション</rt></ruby>リリーストレイン模型に従います。
Rustには3つの*リリースチャネル*があります。

* ナイトリー
* ベータ
* 安定

ほとんどのRustの開発者は、主に安定したチャネルを使用しますが、実験的な新機能を試してみたい人は、夜間またはベータ版を使用できます。

RustチームがRust 1.5のリリースに取り組んでいると仮定してみましょう。
このリリースは2015年12月に行われましたが、現実的な版番号を提供します。
新しい機能がRustに追加されました。新しいコミットが`master`分岐に着きます。
毎晩新しいRustの夜間版が制作されます。
毎日がリリース日です。これらのリリースは、リリースインフラストラクチャによって自動的に作成されます。
だから時間がたつにつれて、リリースは、一晩に一度、このようになります。

```text
nightly: * - - * - - *
```

6週間ごとに、新しいリリースを準備する時です！　
Rustリポジトリの`beta`分岐は、夜間に使用される`master`分岐から分岐します。
今、2つのリリースがあります。

```text
nightly: * - - * - - *
                     |
beta:                *
```

ほとんどのRust利用者はベータ版を積極的に使用していませんが、Rustが可能な退行現象を発見するのを支援するために、CIシステムのベータ版をテストします。
それまでの間は、毎晩夜間にリリースされています。

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

退行現象が見つかったとしましょう。
退行現象が安定したリリースになる前に、ベータ版をテストする時間がありました。
この修正は`master`に適用され、毎晩修正され、修正は`beta`分岐にバックポートされ、新しいベータ版がリリースされます。

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

最初のベータ版が作成されてから6週間後、安定版がリリースされました。
`stable`分岐は`beta`分岐から生成されます。

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

やめ！　
Rust1.5は終わった！　
しかし、1つのことを忘れてしまった。6週間が経過したため、*次の*版のRust 1.6の新しいベータ版も必要となます。
だから、後の`stable`の分岐`beta`、次期版`beta`の分岐`nightly`再び。

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

これは「列車模型」と呼ばれ、6週間ごとにリリースが「駅を離れる」ため、安定版として到着する前にベータ・チャネルを通る必要があります。

Rustは時計のように6週間ごとに放出されます。
1回のRust放出の日付を知っていれば、次の日付を知ることができます。6週間後です。
6週間ごとにリリースが予定されていることの素晴らしい点は、すぐに次の列車が来ることです。
ある機能が特定のリリースを見逃した場合、短期間に別の機能が使用されていることを心配する必要はありません。
これにより、リリースの締め切りに近い時点で未研磨の特徴を潜り込ませるというプレッシャーを軽減できます。

この過程のおかげで、いつでもRustの次の<ruby>組み上げ<rt>ビルド</rt></ruby>をチェックして、アップグレードが容易であることを自分自身で確認することができます。ベータ版が期待通りに機能しない場合は、チームに報告し、次の安定リリースが起こります！　
ベータリリースでの破損は比較的まれですが、`rustc`はまだ<ruby>譜体<rt>アプリケーション</rt></ruby>の1つであり、バグも存在します。

### 不安定な機能

このリリース模型にはもう一つの欠点があります。不安定な機能です。
Rustは、特定のリリースでどの機能が有効になっているかを判断するために、「機能フラグ」という技術を使用します。
新しい機能が積極的に開発されている場合、それは`master`になるため、夜間に*機能フラグの*後ろにあり*ます*。
利用者として、作業中の機能を試してみることができますが、夜間リリースのRustを使用し、原譜に適切なフラグを付けてオプトインする必要があります。

Rustのベータ版または安定版を使用している場合、機能フラグは使用できません。
これは、永遠に安定して宣言する前に、新しい機能を実用化するための鍵です。
出血を望む人はそ​​うすることができ、堅実な経験を望む人は安定していて、<ruby>譜面<rt>コード</rt></ruby>が壊れないことを知ることができます。
停滞のない安定性。

この本には安定した機能に関する情報しか含まれていませんが、進行中の機能はまだ変化しています。この本が書かれたときと安定した<ruby>組み上げ<rt>ビルド</rt></ruby>で有効になる時期は異なっています。
オンラインで夜間のみの機能に関する開発資料を見つけることができます。

### Rustびた夜のRustの役割

Rustupを使用すると、Rustのさまざまなリリースチャネル間で大域または企画単位で簡単に変更できます。
自動的には、安定したRustが導入されます。
夜間に導入するには、たとえば。

```text
$ rustup install nightly
```

導入されているすべての*<ruby>工程譜<rt>ツールチェーン</rt></ruby>*（Rustのリリースと関連部品）が`rustup`状態で`rustup`れます。
作者のWindows<ruby>計算機<rt>コンピューター</rt></ruby>の例を以下に示します。

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

ご覧のとおり、安定した<ruby>工程譜<rt>ツールチェーン</rt></ruby>が自動的にす。
ほとんどのRust利用者は、ほとんどの時間安定して使用します。
ほとんどの場合、安定した使い方をしたいと思うかもしれませんが、夜間には特定の企画で使用することをお勧めします。
そうするためには、使用することができます`rustup override` 1として、毎晩<ruby>工程譜<rt>ツールチェーン</rt></ruby>を設定し、その企画のディレクトリに`rustup`そのディレクトリにいるときに使用する必要があります。

```text
$ cd ~/projects/needs-nightly
$ rustup override add nightly
```

今では、*〜/ projects/needs-* `rustup` *-* `rustc`中に`rustc`や`cargo`を呼び出す`rustc`、 `rustup`と安定したRustの自動的にはなく、夜間のRustを使用していることが確認されます。
これはRust企画がたくさんあるときに便利です！　

### RFC過程とチーム

では、これらの新機能についてどのように学びますか？　
Rustの開発模型は*Request For Comments（RFC）過程に*従い*ます*。
Rustの改善を望むなら、RFCと呼ばれる提案書を書くことができます。

誰でもRustを改善するためのRFCを書くことができ、提案は多くの話題下位チームで構成されるRustチームによって審査され、議論されます。
[Rustのウェブサイトには](https://www.rust-lang.org/en-US/team.html)、言語設計、<ruby>製譜器<rt>コンパイラー</rt></ruby>の実装、インフラストラクチャ、開発資料など、企画の各分野のチームが含まれています。
適切なチームが提案と<ruby>注釈<rt>コメント</rt></ruby>を読み、独自の<ruby>注釈<rt>コメント</rt></ruby>を書き、最終的には機能を受け入れるか拒否するかの合意があります。

この機能が受け入れられると、Rustリポジトリに問題がオープンされ、誰かがそれを実装することができます。
それを非常にうまく実装する人は、最初にその機能を提案した人ではないかもしれません！　
実装が準備完了すると、「不安定な機能」の項で説明したように、特徴ゲートの背後にある`master`分岐に着陸します。

しばらくすると、夜間リリースを使用しているRustの開発者が新しい機能を試してみると、チーム要素がその機能について話し合い、夜間にどのように動いているのか、安定したRustにするかどうかを決定します。
意思決定が前進する場合、特徴ゲートは削除され、特徴は安定していると見なされます。
それは列車を新しい安定したリリースのRustに乗せます。
